/*
 * Treeview 1.4.2 - jQuery plugin to hide and show branches of a tree
 *
 * http://bassistance.de/jquery-plugins/jquery-plugin-treeview/
 *
 * Copyright JÃ¶rn Zaefferer
 * Released under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 */

;(function($) {

	// TODO rewrite as a widget, removing all the extra plugins
	$.extend($.fn, {
		swapClass: function(c1, c2) {
			var c1Elements = this.filter('.' + c1);
			this.filter('.' + c2).removeClass(c2).addClass(c1);
			c1Elements.removeClass(c1).addClass(c2);
			return this;
		},
		replaceClass: function(c1, c2) {
			return this.filter('.' + c1).removeClass(c1).addClass(c2).end();
		},
		hoverClass: function(className) {
			className = className || "hover";
			return this.hover(function() {
				$(this).addClass(className);
			}, function() {
				$(this).removeClass(className);
			});
		},
		heightToggle: function(animated, callback) {
			animated ?
				this.animate({ height: "toggle" }, animated, callback) :
				this.each(function(){
					jQuery(this)[ jQuery(this).is(":hidden") ? "show" : "hide" ]();
					if(callback)
						callback.apply(this, arguments);
				});
		},
		heightHide: function(animated, callback) {
			if (animated) {
				this.animate({ height: "hide" }, animated, callback);
			} else {
				this.hide();
				if (callback)
					this.each(callback);
			}
		},
		prepareBranches: function(settings) {
			if (!settings.prerendered) {
				// mark last tree items
				this.filter(":last-child:not(ul)").addClass(CLASSES.last);
				// collapse whole tree, or only those marked as closed, anyway except those marked as open
				this.filter((settings.collapsed ? "" : "." + CLASSES.closed) + ":not(." + CLASSES.open + ")").find(">ul").hide();
			}
			// return all items with sublists
			return this.filter(":has(>ul)");
		},
		applyClasses: function(settings, toggler) {
			// TODO use event delegation
			this.filter(":has(>ul):not(:has(>a))").find(">span").unbind("click.treeview").bind("click.treeview", function(event) {
				// don't handle click events on children, eg. checkboxes
				if ( this == event.target )
					toggler.apply($(this).next());
			}).add( $("a", this) ).hoverClass();

			if (!settings.prerendered) {
				// handle closed ones first
				this.filter(":has(>ul:hidden)")
						.addClass(CLASSES.expandable)
						.replaceClass(CLASSES.last, CLASSES.lastExpandable);

				// handle open ones
				this.not(":has(>ul:hidden)")
						.addClass(CLASSES.collapsable)
						.replaceClass(CLASSES.last, CLASSES.lastCollapsable);

	            // create hitarea if not present
				var hitarea = this.find("div." + CLASSES.hitarea);
				if (!hitarea.length)
					hitarea = this.prepend("<div class=\"" + CLASSES.hitarea + "\"/>").find("div." + CLASSES.hitarea);
				hitarea.removeClass().addClass(CLASSES.hitarea).each(function() {
					var classes = "";
					$.each($(this).parent().attr("class").split(" "), function() {
						classes += this + "-hitarea ";
					});
					$(this).addClass( classes );
				})
			}

			// apply event to hitarea
			this.find("div." + CLASSES.hitarea).click( toggler );
		},
		treeview: function(settings) {

			settings = $.extend({
				cookieId: "treeview"
			}, settings);

			if ( settings.toggle ) {
				var callback = settings.toggle;
				settings.toggle = function() {
					return callback.apply($(this).parent()[0], arguments);
				};
			}

			// factory for treecontroller
			function treeController(tree, control) {
				// factory for click handlers
				function handler(filter) {
					return function() {
						// reuse toggle event handler, applying the elements to toggle
						// start searching for all hitareas
						toggler.apply( $("div." + CLASSES.hitarea, tree).filter(function() {
							// for plain toggle, no filter is provided, otherwise we need to check the parent element
							return filter ? $(this).parent("." + filter).length : true;
						}) );
						return false;
					};
				}
				// click on first element to collapse tree
				$("a:eq(0)", control).click( handler(CLASSES.collapsable) );
				// click on second to expand tree
				$("a:eq(1)", control).click( handler(CLASSES.expandable) );
				// click on third to toggle tree
				$("a:eq(2)", control).click( handler() );
			}

			// handle toggle event
			function toggler() {
				$(this)
					.parent()
					// swap classes for hitarea
					.find(">.hitarea")
						.swapClass( CLASSES.collapsableHitarea, CLASSES.expandableHitarea )
						.swapClass( CLASSES.lastCollapsableHitarea, CLASSES.lastExpandableHitarea )
					.end()
					// swap classes for parent li
					.swapClass( CLASSES.collapsable, CLASSES.expandable )
					.swapClass( CLASSES.lastCollapsable, CLASSES.lastExpandable )
					// find child lists
					.find( ">ul" )
					// toggle them
					.heightToggle( settings.animated, settings.toggle );
				if ( settings.unique ) {
					$(this).parent()
						.siblings()
						// swap classes for hitarea
						.find(">.hitarea")
							.replaceClass( CLASSES.collapsableHitarea, CLASSES.expandableHitarea )
							.replaceClass( CLASSES.lastCollapsableHitarea, CLASSES.lastExpandableHitarea )
						.end()
						.replaceClass( CLASSES.collapsable, CLASSES.expandable )
						.replaceClass( CLASSES.lastCollapsable, CLASSES.lastExpandable )
						.find( ">ul" )
						.heightHide( settings.animated, settings.toggle );
				}
			}
			this.data("toggler", toggler);

			function serialize() {
				function binary(arg) {
					return arg ? 1 : 0;
				}
				var data = [];
				branches.each(function(i, e) {
					data[i] = $(e).is(":has(>ul:visible)") ? 1 : 0;
				});
				$.cookie(settings.cookieId, data.join(""), settings.cookieOptions );
			}

			function deserialize() {
				var stored = $.cookie(settings.cookieId);
				if ( stored ) {
					var data = stored.split("");
					branches.each(function(i, e) {
						$(e).find(">ul")[ parseInt(data[i]) ? "show" : "hide" ]();
					});
				}
			}

			// add treeview class to activate styles
			this.addClass("treeview");

			// prepare branches and find all tree items with child lists
			var branches = this.find("li").prepareBranches(settings);

			switch(settings.persist) {
			case "cookie":
				var toggleCallback = settings.toggle;
				settings.toggle = function() {
					serialize();
					if (toggleCallback) {
						toggleCallback.apply(this, arguments);
					}
				};
				deserialize();
				break;
			case "location":
				var current = this.find("a").filter(function() {
					return location.href.toLowerCase().indexOf(this.href.toLowerCase()) == 0;
				});
				if ( current.length ) {
					// TODO update the open/closed classes
					var items = current.addClass("selected").parents("ul, li").add( current.next() ).show();
					if (settings.prerendered) {
						// if prerendered is on, replicate the basic class swapping
						items.filter("li")
							.swapClass( CLASSES.collapsable, CLASSES.expandable )
							.swapClass( CLASSES.lastCollapsable, CLASSES.lastExpandable )
							.find(">.hitarea")
								.swapClass( CLASSES.collapsableHitarea, CLASSES.expandableHitarea )
								.swapClass( CLASSES.lastCollapsableHitarea, CLASSES.lastExpandableHitarea );
					}
				}
				break;
			}

			branches.applyClasses(settings, toggler);

			// if control option is set, create the treecontroller and show it
			if ( settings.control ) {
				treeController(this, settings.control);
				$(settings.control).show();
			}

			return this;
		}
	});

	// classes used by the plugin
	// need to be styled via external stylesheet, see first example
	$.treeview = {};
	var CLASSES = ($.treeview.classes = {
		open: "open",
		closed: "closed",
		expandable: "expandable",
		expandableHitarea: "expandable-hitarea",
		lastExpandableHitarea: "lastExpandable-hitarea",
		collapsable: "collapsable",
		collapsableHitarea: "collapsable-hitarea",
		lastCollapsableHitarea: "lastCollapsable-hitarea",
		lastCollapsable: "lastCollapsable",
		lastExpandable: "lastExpandable",
		last: "last",
		hitarea: "hitarea"
	});

})(jQuery);

var utils = {
    ordinal_suffix_of: function(i) {
        var j = i % 10,
        k = i % 100;
        if (j == 1 && k != 11) {
            return "";
            // return i + "st";
        }
        if (j == 2 && k != 12) {
            return i + "nd";
        }
        if (j == 3 && k != 13) {
            return i + "rd";
        }
        return i + "th";
    },
    isInt: function(value) {
        return !isNaN(value) && (function(x) { return (x | 0) === x; })(parseFloat(value))
    },
    formatNumber: function(number) {
        var sizes = ['', 'K', 'M', 'G', 'T', 'P', 'E'];
        if (number == null || typeof number == 'undefined') {
            return {
                value: '-',
                unit: '',
                original:number
            }
        }

        var sign = Math.sign(number);
        n = Math.abs(number);

        var i = parseInt(Math.floor(Math.log(n) / Math.log(1000)));
        if (i > -1) {
            if (typeof sizes[i] != 'undefined') {
                return {
                    value: sign * (n / Math.pow(1000, i)).toFixed(2),
                    unit: sizes[i],
                    original:number
                };    
            } else {
                return {
                    value: sign * (n / Math.pow(1000, i)).toFixed(2),
                    unit:'e+'+i*3,
                    original:number
                }
            }
        } else {
            return {
                value: sign * (n).toFixed(2),
                unit: '',
                original:number
            };
        }
    },
    formatValue: function(number, unit) {
        var sizes = ['', 'K', 'M', 'G', 'T', 'P', 'E'];
        if (number == null || typeof number == 'undefined') {
            return {
                value: '-',
                unit: unit,
                number:number
            }
        }
        if (number == 0) { 
            return {
                value: parseFloat(number).toFixed(2),
                unit: unit,
                number:number
            };
        }
        if (unit.charAt(0).toLowerCase() == 'k') {
            unit = unit.substr(1);
            number = number * 1000;
        } 
        else {
            return {
                value: parseFloat(number).toFixed(2),
                unit: unit,
                number:number
            }
        }
        var sign = Math.sign(number);
        n = Math.abs(number);

        var i = parseInt(Math.floor(Math.log(n) / Math.log(1000)));
        if (i > -1) {
            if (typeof sizes[i] != 'undefined') {
                return {
                    value: sign * (n / Math.pow(1000, i)).toFixed(2),
                    unit: sizes[i] + '' + unit,
                    number:number
                };    
            } else {
                return {
                    value: sign * (n / Math.pow(1000, i)).toFixed(2),
                    unit:'e+'+i*3 + ' '+unit,
                    number:number
                }
            }

        } else {
            return {
                value: sign * (n).toFixed(2),
                unit: unit,
                number:number
            };
        }
    },
    formatCurrency: function(amount, sf, text) {
        var word = "";
        var original_value = amount;
        amount = parseFloat(amount);
        if (isNaN(amount))
            return "";
        var isMinus = amount < 0;
        if (isMinus)
            amount = Math.abs(amount);
        if (amount > 999999999) {
            amount = amount / 1000000000;
            word = "billions";
        } else if (amount > 9999999) {
            amount = amount / 10000000;
            word = "crores";
        } else if (amount > 99999) {
            amount = amount / 100000;
            word = "lakhs";
        }
        var prefix = isMinus ? "-" : "";
        return text ? prefix + amount.toFixed(2) + " " + word : {
            amount: amount.toFixed(2),
            unit: word,
            original_value: original_value
        };

    },
    formatData: function(amount, sf, text) {
        if (amount == undefined || amount == null)
            return amount;
        var original_value = amount;

        amount = parseFloat(amount, 10) || 0;
        var isMinus = amount < 0;
        if (isMinus)
            amount = Math.abs(amount);
        var word = "";
        if (amount > 999999) {
            amount = amount / 1000000;
            word = "giga watt-hours";
            if (sf)
                word = "GWh";
        } else if (amount > 999) {
            amount = amount / 1000;
            word = "mega watt-hours";
            if (sf)
                word = "MWh";
        } else if (amount > 0) {
            word = "kilo watt-hours";
            if (sf)
                word = "kWh";
        } else {
            word = 'watt-hours';
            if (sf)
                word = "wh";
        }
        var prefix = isMinus ? "-" : "";
        return text ? prefix + amount.toFixed(2) + " " + word : {
            amount: (original_value < 0 ? -1 : 1) * parseFloat(amount).toFixed(2),
            unit: word,
            original_value: original_value
        };
    },
    roundAbs: function(input) {
        if (input) {
            input = input.toString();
            var splits = input.split(".");
            var output = splits[0];
            if (splits.length > 1) {
                output = splits[0] + "." + splits[1].substr(0, 2);
            }
            if (utils.isNumeric(output))
                return parseFloat(output);
            else
                return output;
        }
        return input;
    },
    isNumeric(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    },
    random: function(length, numeric, possible) {
        length = length || 8;
        var randomId = "";
        possible = possible || "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        if (numeric) {
            possible = "0123456789";
        }
        for (var i = 0; i < length; i++)
            randomId += possible.charAt(Math.floor(Math.random() * possible.length));
        return randomId;
    },
    unflatten: function(data, typeWiseData) {
        var that = this;
        var tree = [],
        mappedArr = {},
        arrElem,
        mappedElem,
        arr = data.sensordata;

        if (!arr)
            return false;
        // First map the nodes of the array to an object -> create a hash table.
        if (data.locationid && !data.mappedlocationid) {
            data.mappedlocationid = {
                locationid: data.locationid,
                parentlocationid: null,
                name: data.locationname
            }
            mappedArr[data.locationid] = data;
            mappedArr[data.locationid]['children'] = [];
        }
        var newVirtualItems = [];
        if (data && data.virtual_locations) {
            var virtualLocations = data.virtual_locations;
            for (var i = 0; i < virtualLocations.length; i++) {
                var curLoc = virtualLocations[i];
                newVirtualItems.push({
                    name: curLoc.locatiname,
                    id: curLoc.locationid,
                    mappedlocationid: {
                        locationid: curLoc.locationid,
                        parentlocationid: curLoc.parentlocationid,
                        name: curLoc.locatiname
                    }
                });
            }
        }
        arr = arr.concat(newVirtualItems);
        for (var i = 0, len = arr.length; i < len; i++) {
            arrElem = arr[i];
            if (arrElem.mappedlocationid) {
                if (arrElem.mappedlocationid.locationid != arrElem.mappedlocationid.parentlocationid) {
                    mappedArr[arrElem.mappedlocationid.locationid] = arrElem;
                    mappedArr[arrElem.mappedlocationid.locationid]['children'] = [];
                }
            }
        }

        for (var id in mappedArr) {
            if (mappedArr.hasOwnProperty(id)) {
                mappedElem = mappedArr[id];
                // If the element is not at the root level, add it to its parent array of children.
                if (mappedElem.mappedlocationid.parentlocationid) {
                    if (mappedArr[mappedElem.mappedlocationid['parentlocationid']])
                        mappedArr[mappedElem.mappedlocationid['parentlocationid']]['children'].push(mappedElem);
                    else {
                        // console.log("location not found", mappedArr, mappedElem.mappedlocationid['parentlocationid']);
                    }
                }
                // If the element is at the root level, add it to first level elements array.
                else {
                    //console.log(mappedElem.mappedlocationid['parentlocationid'], mappedElem);
                    tree.push(mappedElem);
                }
            }
        }

        function hasItem(array, item) {
            for (var i = 0; i < array.length; i++) {
                if (array[i].name == item.name && array[i].sensorid == item.sensorid)
                    return true;
            }
            return false;
        }
        for (var i = 0, len = arr.length; i < len; i++) {
            arrElem = arr[i];
            if (arrElem.mappedlocationid) {
                if (arrElem.sensortypeid) {
                    if (typeWiseData[arrElem.sensortypeid.sensortypename])
                        typeWiseData[arrElem.sensortypeid.sensortypename]++;
                    else
                        typeWiseData[arrElem.sensortypeid.sensortypename] = 1;
                }
                if (arrElem.mappedlocationid.parentlocationid && mappedArr[arrElem.mappedlocationid.parentlocationid]) {
                    if (!hasItem(mappedArr[arrElem.mappedlocationid.parentlocationid]['children'], arrElem))
                        mappedArr[arrElem.mappedlocationid.parentlocationid]['children'].push(arrElem);
                }
            }
        }
        return tree.pop();
    },
    prepareTreeData: function(data, key) {
        key = key || "";
        var that = this;
        if (key)
            localStorage.setItem("locationData" + key, JSON.stringify(data));
        return data;
    },
    fullScreen: function(element) {
        if (element.requestFullscreen) {
            element.requestFullscreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
    },
    exitFullScreen: function() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
    },
    toTitleCase: function(str) {
        return str.replace(/\w\S*/g, function(txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
    },
    swap: function(json) {
        var ret = {};
        for (var key in json) {
            ret[json[key]] = key;
        }
        return ret;
    },
    /*
     * Recursively merge properties of two objects
     */
     MergeRecursive: function(obj1, obj2) {

        for (var p in obj2) {
            try {
                // Property in destination object set; update its value.
                if (obj2[p].constructor == Object) {

                    obj1[p] = utils.MergeRecursive(obj1[p], obj2[p]);
                } else {
                    obj1[p] = obj2[p];
                }
            } catch (e) {
                // Property in destination object not set; create it and set its value.
                obj1[p] = obj2[p];
            }
        }

        return obj1;
    },
    isValidDate: function(date_str) {
        var d = moment(date_str);
        return d!=null && d.isValid();
    },
    dayDiff: function(endDate, startDate) {
        var startDate = moment(startDate);
        var endDate = moment(endDate);
        var duration = moment.duration(endDate.diff(startDate));
        return duration.asDays();
    },
    isSameDay:function(startDate, endDate) {
        var dateFormat = "YYYY-MM-DD";
        var startDate = moment(startDate).format(dateFormat);
        var endDate = moment(endDate).format(dateFormat);
        var today = moment().format(dateFormat);
        return (startDate == endDate)?true:false;
    },
    isToday:function(startDate, endDate) {
        var dateFormat = "YYYY-MM-DD";
        var startDate = moment(startDate).format(dateFormat);
        var endDate = moment(endDate).format(dateFormat);
        var today = moment().format(dateFormat);
        return (startDate == endDate && endDate == today)?true:false;
    },
    /**
    * Swap the elements in an array at indexes x and y.
    *
    * @param (a) The array.
    * @param (x) The index of the first element to swap.
    * @param (y) The index of the second element to swap.
    * @return {Array} A new array with the elements swapped.
    */
    swapArrayElements:function (a, x, y) {
        if (a.length === 1) return a;
        a.splice(y, 1, a.splice(x, 1, a[y])[0]);
        return a;
    },
    exportToCsv: function(filename, rows) {
        var processRow = function(row) {
            var finalVal = '';
            for (var j = 0; j < row.length; j++) {
                var innerValue = row[j] === null ? '' : row[j].toString();
                if (row[j] instanceof Date) {
                    innerValue = row[j].toLocaleString();
                };
                var result = innerValue.replace(/"/g, '""');
                if (result.search(/("|,|\n)/g) >= 0)
                    result = '"' + result + '"';
                if (j > 0)
                    finalVal += ',';
                finalVal += result;
            }
            return finalVal + '\n';
        };

        var csvFile = '';
        for (var i = 0; i < rows.length; i++) {
            csvFile += processRow(rows[i]);
        }

        var blob = new Blob([csvFile], {
            type: 'text/csv;charset=utf-8;'
        });
        if (navigator.msSaveBlob) { // IE 10+
            navigator.msSaveBlob(blob, filename);
        } else {
            var link = document.createElement("a");
            if (link.download !== undefined) { // feature detection
                // Browsers that support HTML5 download attribute
                var url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    },
    getWidgetRefreshTime:function(refreshTime) {
        refreshTime = refreshTime ? (refreshTime>5 ? refreshTime : 5): 1440;
        // Convert minutes to miliseconds
        return refreshTime * 1000 * 60;
    },
    strToJson:function(item) {
        if (typeof(item) == 'string') {
            return JSON.parse(item || "{}");
        } else {
            return item;
        }
    },
    scrollTo:function(height) {
        $('html, body').animate({
            scrollTop:  height
        }, 500);
    },
    bootstrapClass: function(size) {
        var sizes = {
            'full' :{
                'label':'Large - Full Width',
                'value':'col-lg-12 col-md-12 col-sm-12 col-xs-12'
            },
            'half' :{
                'label':'Medium - Half Width',
                'value':'col-lg-6 col-md-6 col-sm-12 col-xs-12'
            },
            'medium' : {
                'label':'Medium - 1/3th Width',
                'value':'col-lg-4 col-md-4 col-sm-12 col-xs-12'
            },
            'small' :{
                'label':'Small - 1/4th Width',
                'value':'col-lg-3 col-md-3 col-sm-4 col-xs-12'
            },
            'xsmall': {
                'label':'Extra Small - 1/6th Width',
                'value':'col-lg-2 col-md-3 col-sm-4 col-xs-12'
            }
        }
        if(sizes.full !== size) {
            return sizes.full.value
        }
        if(sizes.half !== size) {
            return sizes.half.value
        }
        if(sizes.medium !== size) {
            return sizes.medium.value
        }
        if(sizes.medium !== size) {
            return sizes.medium.value
        }
        if(sizes.small !== size) {
            return sizes.small.value
        }
        if(sizes.xsmall !== size) {
            return sizes.xsmall.value
        }
    },
    saveAs: function(data, exts, filename) {
        var mimetype = "";
        exts = exts.toLowerCase();
        if (exts == "xlsx") {
            mimetype = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
        } else if (exts == "xls") {
            mimetype = "application/vnd.ms-excel";
        } else if (exts == "csv") {
            mimetype = "text/csv";
        }
        var blob = new Blob([data], {
            type: mimetype
        });
        var objectUrl = URL.createObjectURL(blob);
        var anchor = angular.element('<a/>');
        angular.element(document.body).append(anchor);
        anchor.attr({
            href: objectUrl,
            target: '_self',
            download: filename + '.' + exts
        })[0].click();
    }
};

$(function() {
    $(document).keyup(function(e) {
        //if (e.keyCode === 13) // enter
        if (e.keyCode === 27) {
            // esc
            if ($(".daterangepicker").is(":visible"))
                $(".daterangepicker .cancelBtn").click();
            $(".datetimepicker:visible").parent().parent().removeClass("open");
        }
    });
});
/* Convert DMS format of latitude and longitude to float number (DD) */
function ParseDMS(input) {
    var parts = input.split(/[^\d\w]+/);
    var lat = ConvertDMSToDD(parts[0], parts[1], parts[2], parts[3]);
    var lng = ConvertDMSToDD(parts[4], parts[5], parts[6], parts[7]);
    return {
        lat: lat,
        lng: lng
    };
}

function ConvertDMSToDD(degrees, minutes, seconds, direction) {
    var dd = parseInt(degrees) + parseInt(minutes) / 60 + parseInt(seconds) / (60 * 60);
    if (direction == "S" || direction == "W") {
        dd = dd * -1;
    } // Don't do anything for N or E
    return dd;
}

function convertToDD(pos) {
    if (isNaN(pos.lat) || isNaN(pos.lng)) {
        pos = ParseDMS(pos.lat + '' + pos.lng);
    }
    return pos;
}

Array.prototype.remove = function(from, to) {
    var rest = this.slice((to || from) + 1 || this.length);
    this.length = from < 0 ? this.length + from : from;
    return this.push.apply(this, rest);
};

/* Template module will be used in distribution for caching all template file */
angular.module("templates", []);

var smartsenseApp = angular.module('smartsenseApp', [
    "ui.router",
    'pascalprecht.translate',
    'ncy-angular-breadcrumb',
    'ngSanitize',
    'ngMessages',
    // Date Modules
    // TODO: Need to figure out to use unify datetime picker and minimize multi module dependencies
    'daterangepicker',
    'ui.bootstrap.datetimepicker',
    'ui.dateTimeInput',
    'ui.validate',
    'datetime',
    'ui.select',
    'templates',
    'ngCookies',
    'angular-growl',
    'ui.bootstrap-slider',
    'angularMoment',
    'smartsenseConfig',
    'angular-google-analytics',
    'angularUtils.directives.dirPagination',
    'ui.bootstrap',
    'highcharts-ng',
    'angularFileUpload',
    'angular-timeline',
    'ngTable',
    'checklist-model',
    'LocalStorageModule',
    'ngJsTree',
    'ngFileUpload',
    'summernote'
]);

smartsenseApp.config(['$stateProvider', '$urlRouterProvider', '$breadcrumbProvider', '$translateProvider', 'growlProvider', '$httpProvider', '$compileProvider', 'localStorageServiceProvider',
    function($stateProvider, $urlRouterProvider, $breadcrumbProvider, $translateProvider, growlProvider, $httpProvider, $compileProvider, localStorageServiceProvider) {

        // Whitelist URL protocols to prevent unsafe script load warning
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|local|data|mailto|blob|chrome-extension):/);

        localStorageServiceProvider.setPrefix('smartsense')
        $httpProvider.interceptors.push('httpRequestInterceptor');
        $stateProvider.state('page', {
                abstract: true,
                url: '',
                views: {
                    '@': {
                        templateUrl: 'shared/layouts/page/pageView.html',
                        controller: 'PageController',
                    },
                    'header@page': {
                        templateUrl: 'shared/header/page/header.tpl.html'
                    },
                    'footer@page': {
                        templateUrl: 'shared/footer/page/footer.tpl.html'
                    }
                }
            })
            .state('page.login', {
                url: '/login/{token}',
                params: {
                    token: {
                        value: 'SmartSense'
                    }
                },
                templateUrl: 'components/login/loginView.html',
                controller: 'LoginController',
                onEnter: function($stateParams) {
                    document.title = "Login - SmartSense";
                }
            })
            .state('error', {
                url: '/error',
                templateUrl: 'components/error/errorView.html'
            })
            .state('home', {
                abstract: true,
                url: '',
                views: {
                    '@': {
                        templateUrl: 'shared/layouts/home/homeView.html',
                        controller: 'HomeController'
                    },
                    'header@home': {
                        templateUrl: 'shared/header/home/header.tpl.html'
                    },
                    'footer@home': {
                        templateUrl: 'shared/footer/home/footer.tpl.html'
                    }
                },
                ncyBreadcrumb: {
                    label: '{{"Home" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Dashboard - SmartSense";
                }
            })
            .state('home.configuration', {
                url: '/configuration/',
                templateUrl: 'components/configuration/configurationView.html',
                controller: 'ConfigurationController',
                ncyBreadcrumb: {
                    label: '{{"Configuration" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Configuration - SmartSense";
                },
            })
            .state('home.sensordata', {
                url: '/sensor-data/',
                templateUrl: 'components/sensor-data/sensorDataView.html',
                controller: 'SensorDataController',
                ncyBreadcrumb: {
                    label: '{{"Sensor Data Generate & Upload" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Sensor Data - SmartSense";
                },
            })
            .state('home.dmrcdashboard', {
                url: '/dmrc-dashboard/',
                templateUrl: 'components/dmrc-dashboard/dmrc-dashboardView.html',
                controller: 'DMRCDashboardController',
                ncyBreadcrumb: {
                    label: '{{"Equipment Error Management - DMRC" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Equipment Error Management - DMRC - SmartSense";
                }
            })
            .state('home.mydashboard', {
                url: '/mydashboard/',
                templateUrl: 'components/mydashboard/mydashboardView.html',
                controller: 'MyDashboardController',
                ncyBreadcrumb: {
                    label: '{{"My Dashboard" | translate}}'
                },
                resolve: {
                    widget_list: function(apiService, $q, $state) {
                        var deferred = $q.defer();
                        return apiService.widget_list().success(function(data) {
                            deferred.resolve(data);
                        }).error(function(data) {
                            $state.go('error');
                            deferred.reject(deferred.resolve(data));
                        });
                    }
                },
                onEnter: function($stateParams) {
                    document.title = "My Dashboard - SmartSense";
                },
            })
            .state('home.widgetBuilder', {
                url: '/widgetBuilder',
                templateUrl: 'components/widgetBuilder/templates/widgetBuilderView.html',
                controller: 'widgetBuilderController',
                ncyBreadcrumb: {
                    label: '{{"Widget Builder" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Widget Builder - SmartSense";
                },
                resolve: {
                    widgetTypes: function(apiService) {
                        return apiService.widget_type();
                    },
                    widgets: function(apiService) {
                        return apiService.widget_list();
                    }
                }
            })
            .state('home.widgetBuilder.add', {
                url: '/add/:widgetid',
                views: {
                    '@home': {
                        templateUrl: 'components/widgetBuilder/templates/widgetBuilderAddView.html',
                        controller: 'widgetBuilderController',
                    }
                },
                ncyBreadcrumb: {
                    label: '{{"New Widget" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "New Widget - SmartSense";
                }
            })
            .state('home.networkInsights', {
                url: '/networkInsights/{locID}',
                templateUrl: 'components/networkInsights/networkInsightsView.html',
                controller: 'NetworkInsightsController',
                ncyBreadcrumb: {
                    label: '{{"Network Insights" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Network Insights - SmartSense";
                },
                resolve: {
                    billingLocations: function(apiService) {
                        return apiService.location_billing();
                    }
                }
            })
            .state('home.motorInsights', {
                url: '/motorInsights/{locID}',
                templateUrl: 'components/motorInsights/motorInsightsView.html',
                controller: 'MotorInsightsController',
                ncyBreadcrumb: {
                    label: '{{"Motor Insights" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Motor Insights - SmartSense";
                },
                resolve: {
                    billingLocations: function(apiService) {
                        return apiService.location_billing();
                    }
                }
            })
            .state('home.transformerInsights', {
                url: '/transformerInsights/{locID}',
                templateUrl: 'components/transformerInsights/transformerInsightsView.html',
                controller: 'TransformerInsightsController',
                ncyBreadcrumb: {
                    label: '{{"Transformer Insights" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Transformer Insights - SmartSense";
                },
                resolve: {
                    summary: function(apiService) {
                        return apiService.tx_insights_summary();
                    }
                }
            })
            .state('home.motorInsightsNew', {
                url: '/motorInsightsNew/{locID}',
                templateUrl: 'components/motorInsightsNew/motorInsightsNewView.html',
                controller: 'MotorInsightsNewController',
                ncyBreadcrumb: {
                    label: '{{"Motor Insights" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Motor Insights - SmartSense";
                }
            })
            .state('home.chillerInsights', {
                url: '/chillerInsights/{sensorId}',
                templateUrl: 'components/chillerInsights/chillerInsightsView.html',
                controller: 'ChillerInsightsController',
                ncyBreadcrumb: {
                    label: '{{"Chiller Insights" | translate}}'
                },
                resolve: {
                    chillers: function(apiService, local) {
                        var sensors = Object.keys(local.data.sensors);
                        return apiService.chiller_list(sensors);
                    },
                    chiller_uiconfigs: function(apiService) {
                        return apiService.chiller_uiconfigs();
                    }
                },
                onEnter: function($stateParams) {
                    document.title = "Chiller Insights - SmartSense";
                }
            })
            .state('home.billingInsights', {
                url: '/billingInsights/{locID}',
                templateUrl: 'components/billingInsights/billingInsightsView.html',
                controller: 'BillingInsightsController',
                ncyBreadcrumb: {
                    label: '{{"Billing Insights" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Billing Insights - SmartSense";
                },
                resolve: {
                    locations: function(apiService) {
                        return apiService.location_all();
                    },
                    billingLocations: function(apiService) {
                        return apiService.location_billing();
                    }
                }
            })
            .state('home.profile', {
                url: '/profile',
                templateUrl: 'components/profile/profileView.html',
                controller: 'ProfileController',
                ncyBreadcrumb: {
                    label: '{{"Profile" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Profile - SmartSense";
                }
            })
            .state('home.alert', {
                url: '/alert',
                templateUrl: 'components/alert/alertView.html',
                controller: 'AlertController',
                ncyBreadcrumb: {
                    label: '{{"Alert" | translate}}'
                },
                resolve: {
                    sensors: function(apiService) {
                        return apiService.sensors();
                    }
                },
                onEnter: function($stateParams) {
                    document.title = "Alerts - SmartSense";
                }
            })
            .state('home.alert.event', {
                url: '/event',
                views: {
                    '@home': {
                        templateUrl: 'components/alert/eventNewView.html',
                        controller: 'AlertController',
                    }
                },
                ncyBreadcrumb: {
                    label: '{{"New Event" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "New Event - SmartSense";
                }
            })
            .state('home.alert.event.edit', {
                url: '/:eventId',
                views: {
                    '@home': {
                        templateUrl: 'components/alert/eventNewView.html',
                        controller: 'AlertController',
                    }
                },
                ncyBreadcrumb: {
                    label: '{{"Edit Event" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Edit Event - SmartSense";
                }
            })
            .state('home.alert.new', {
                url: '/new',
                views: {
                    '@home': {
                        templateUrl: 'components/alert/alertNewView.html',
                        controller: 'AlertController',
                    }
                },
                ncyBreadcrumb: {
                    label: '{{"New Alert" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "New Alert - SmartSense";
                }
            })
            .state('home.alert.edit', {
                url: '/:alertId',
                views: {
                    '@home': {
                        templateUrl: 'components/alert/alertNewView.html',
                        controller: 'AlertController',
                    }
                },
                ncyBreadcrumb: {
                    label: '{{"Edit Alert" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Edit Alert - SmartSense";
                }
            })
            .state('home.analyse', {
                url: '/analyse',
                templateUrl: 'components/analyse/analyseView.html',
                controller: 'AnalyseController',
                ncyBreadcrumb: {
                    label: '{{"Analyse" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Analyse - SmartSense";
                }
            })
            .state('home.reports', {
                url: '/reports',
                templateUrl: 'components/reports/reportsView.html',
                controller: 'ReportsController',
                ncyBreadcrumb: {
                    label: 'Reports'
                },
                onEnter: function($stateParams) {
                    document.title = "Reports - SmartSense";
                }
            })
            .state('home.dmrcreports', {
                url: '/dmrc-reports/',
                templateUrl: 'components/reports/dmrcReportsView.html',
                controller: 'ReportsController',
                ncyBreadcrumb: {
                    label: 'Reports'
                },
                onEnter: function($stateParams) {
                    document.title = "Reports - SmartSense";
                }
            })
            .state('home.dmrcalert', {
                url: '/dmrc-alert/',
                templateUrl: 'components/dmrc-alert/dmrc-alertView.html',
                controller: 'DMRCAlertController',
                ncyBreadcrumb: {
                    label: '{{"DMRC Alert" | translate}}'
                },
                resolve: {
                    sensors: function(apiService) {
                        return apiService.sensors();
                    }
                },
                onEnter: function($stateParams) {
                    document.title = "DMRC Alerts - SmartSense";
                }
            })
            .state('home.dmrcalert.event', {
                url: 'event',
                views: {
                    '@home': {
                        templateUrl: 'components/dmrc-alert/eventNewView.html',
                        controller: 'DMRCAlertController',
                    }
                },
                ncyBreadcrumb: {
                    label: '{{"New Event" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "New Event - SmartSense";
                }
            })
            .state('home.dmrcalert.event.edit', {
                url: '/:eventId',
                views: {
                    '@home': {
                        templateUrl: 'components/dmrc-alert/eventNewView.html',
                        controller: 'DMRCAlertController',
                    }
                },
                ncyBreadcrumb: {
                    label: '{{"Edit Event" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Edit Event - SmartSense";
                }
            })
            .state('home.dmrcalert.new', {
                url: 'new',
                views: {
                    '@home': {
                        templateUrl: 'components/dmrc-alert/alertNewView.html',
                        controller: 'DMRCAlertController',
                    }
                },
                ncyBreadcrumb: {
                    label: '{{"New Alert" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "New Alert - SmartSense";
                }
            })
            .state('home.dmrcalert.edit', {
                url: '/:alertId',
                views: {
                    '@home': {
                        templateUrl: 'components/dmrc-alert/alertNewView.html',
                        controller: 'DMRCAlertController',
                    }
                },
                ncyBreadcrumb: {
                    label: '{{"Edit Alert" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Edit Alert - SmartSense";
                }
            })
            .state('home.kpi', {
                url: '/kpi',
                templateUrl: 'components/kpi/kpiView.html',
                controller: 'KPIController',
                ncyBreadcrumb: {
                    label: '{{"Key Performance Index" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Key Performance Index - SmartSense";
                }
            })
            .state('home.utilization', {
                url: '/utilization/',
                templateUrl: 'components/utilization/utilizationView.html',
                controller: 'UtilizationController',
                ncyBreadcrumb: {
                    label: '{{"Utilization" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Utilization - SmartSense";
                }
            })
            .state('home.treeBuilder', {
                url: '/treeBuilder',
                templateUrl: 'components/treeBuilder/treeBuilderView.html',
                controller: 'TreeBuilderController',
                ncyBreadcrumb: {
                    label: '{{"Tree Builder" | translate}}'
                },
                onEnter: function($stateParams) {
                    document.title = "Tree Builder - SmartSense";
                }
            });

        $urlRouterProvider.otherwise('/mydashboard/');


        $breadcrumbProvider.setOptions({
            templateUrl: 'shared/breadcrumbs/breadcrumbsView.html'
        });

        //$translateProvider.useUrlLoader('/i18n/en.json');
        $translateProvider.useStaticFilesLoader({
            prefix: '/i18n/',
            suffix: '.json'
        });

        $translateProvider.useLocalStorage();
        $translateProvider.preferredLanguage('en');
        $translateProvider.useSanitizeValueStrategy(null);

        growlProvider.globalTimeToLive(15000);
        // growlProvider.globalDisableCloseButton(true);
        growlProvider.globalDisableCountDown(true);
        growlProvider.globalPosition('top-right');

    }
]);

// Google Analytics
smartsenseApp
    .config(['AnalyticsProvider', function(AnalyticsProvider) {
        // Add configuration code as desired
        AnalyticsProvider.setAccount('UA-92796058-1'); //UU-XXXXXXX-X should be your tracking code
        AnalyticsProvider.trackPages(true);
        AnalyticsProvider.setPageEvent('$stateChangeSuccess');
    }])
    .run(['Analytics', function(Analytics) {
        Analytics.trackPage('Landed on SmartSense');
    }]);

// Enable API call caching
smartsenseApp
    .config(['$provide', function($provide) {
        $provide.decorator('$cacheFactory', function($delegate) {
            $delegate.removeAll = function() {
                angular.forEach($delegate.info(), function(ob, key) {
                    $delegate.get(key).removeAll();
                });
            }

            $delegate.destroyAll = function() {
                angular.forEach($delegate.info(), function(ob, key) {
                    $delegate.get(key).destroy();
                });
            }
            return $delegate;
        });
    }]);


smartsenseApp.factory('httpRequestInterceptor', function($q, $injector, Session, SETTINGS) {
    return {
        request: function(config) {
            /* Add Authorization header for API call only */
            if (config.url.indexOf(SETTINGS.BASE_URL) > -1) {
                var authToken = Session.get('authToken');
                // keep user logged in after page refresh
                if (authToken) {
                    config.headers['Authorization'] = 'token:' + authToken;
                }
            }
            return config;
        },
        responseError: function(rejection) {
            // console.error(rejection.config,rejection.config.headers);
            var defer = $q.defer();
            if (rejection.status == 401) {

            }
            if (rejection.status == 403) {
                Session.remove('authToken');
                Session.remove('memberId');
                $injector.get("$state").go('page.login');
            }
            defer.reject(rejection);
            return defer.promise;
        }
    };
});


smartsenseApp.run(['$rootScope', '$state', '$http', 'loading', 'local', 'authService', 'Session', '$stateParams', 'pendingRequests', 'apiCacheFactory', function($rootScope, $state, $http, loading, local, authService, Session, $stateParams, pendingRequests, apiCacheFactory) {

    apiCacheFactory.clearAll();
    // redirect to login page if not logged in and trying to access a restricted page
    $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams, options) {
        pendingRequests.cancelAll();
        loading(true);
        var authToken = Session.get('authToken');
        var publicPages = ['page.login'];
        var restrictedPage = publicPages.indexOf(toState.name) == -1;
        if (restrictedPage && !authToken) {
            loading(false);
            event.preventDefault();
            $state.go('page.login');
        }

    });
    $rootScope.$on('$viewContentLoading', function(event, toState, toParams, fromState, fromParams) {
        loading(false);
    });
    $rootScope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
        if (toState && toState.name) {
            local.data.activeMenu = toState.name.split(".")[1];
        }
    });
    $rootScope.$on('$stateNotFound', function(event, unfoundState, fromState, fromParams) {
        loading(false);
    });

    $rootScope.$on('$stateChangeError',
        function(event, toState, toParams, fromState, fromParams, error) {
            loading(false);
            if (error.status == 403) {
                authService.logout();
                var token = $stateParams["token"] || "SmartSense";
                $state.go("page.login", {
                    token: token
                });
            }
        });

}]);
smartsenseApp.factory('loading', function($rootScope, $timeout) {
    return function(show) {
        $timeout(function() {
            $rootScope.$broadcast('showLoadingIndicator', show);
        });
    }
});

smartsenseApp.directive("loadingContainer", function() {
    return {
        restrict: "A",
        scope: false,
        link: function(scope, element, attrs) {
            var loadingLayer = angular.element("<div class='loading'></div>");
            element.append(loadingLayer);
            element.addClass("loading-container");
            scope.$watch(attrs.loadingContainer, function(value) {
                loadingLayer.toggleClass("ng-hide", !value);
            });
        }
    };
});

smartsenseApp.filter('filterByLocations', ['local', function(local) {
    return function(readingtypes, locations) {
        return readingtypes.filter(function(readingtype) {
            if (locations) {
                for (var i = 0; i < locations.length; i++) {
                    var messageversions = locations[i].messageversions;
                    for (var j = 0; j < messageversions.length; j++) {
                        if (local.data.version_readingtype_mapping[messageversions[j]].indexOf(readingtype.readingtypeid) > -1) {
                            return true;
                        }
                    }
                }
            }
            return false;
        })

    };
}]);

smartsenseApp.filter('filterByLocation', ['local', function(local) {
    return function(readingtypes, location) {
        return readingtypes.filter(function(readingtype) {
            if (location) {
                var messageversions = location.messageversions;
                for (var j = 0; j < messageversions.length; j++) {
                    if (local.data.version_readingtype_mapping[messageversions[j]].indexOf(readingtype.readingtypeid) > -1) {
                        return true;
                    }
                }
            }
            return false;
        })

    };
}]);

smartsenseApp.directive('ngConfirmClick', [
    function() {
        return {
            link: function(scope, element, attr) {
                var msg = attr.ngConfirmClick || "Are you sure?";
                var clickAction = attr.confirmedClick;
                element.bind('click', function(event) {
                    var dialog = bootbox.confirm(msg, function(result) {
                        if (result)
                            scope.$eval(clickAction);
                    });
                    if (attr.defaultCancelBtn) {
                        dialog.on('shown.bs.modal', function() {
                            dialog.find(".btn-default:first").focus();
                        });
                    }
                });
            }
        };
    }
]);

smartsenseApp.directive('arrayRequired', function() {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, elem, attrs, ngModel) {
            ngModel.$validators.arrayRequired = function(modelValue, viewValue) {
                var modelValue = modelValue || {}
                return (modelValue.length > 0 ? true : false);
            };
        }
    };
});

smartsenseApp.filter('propsFilter', function() {
    return function(items, props) {
        var out = [];

        if (angular.isArray(items)) {
            var keys = Object.keys(props);

            items.forEach(function(item) {
                var itemMatches = false;

                for (var i = 0; i < keys.length; i++) {
                    var prop = keys[i];
                    var text = props[prop].toLowerCase();
                    if (item[prop] && item[prop].toString().toLowerCase().indexOf(text) !== -1) {
                        itemMatches = true;
                        break;
                    }
                }

                if (itemMatches) {
                    out.push(item);
                }
            });
        } else {
            // Let the output be the input untouched
            out = items;
        }

        return out;
    };
});

function validateEmail(email) {
    var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(email);
}

function isEmailListValid(email_string, limit) {

    var emailArray = email_string.split(",");
    var validEmails = 0;
    for (var i = 0; i < emailArray.length; i++) {
        if (validateEmail(emailArray[i].replace(/^\s+|\s+$/gm, ''))) {
            validEmails++;
        }
    }
    if (limit) {
        return validEmails == emailArray.length && emailArray.length <= limit;
    } else {
        return validEmails == emailArray.length;
    }


}

smartsenseApp.directive('validateEmail', function() {
    var EMAIL_REGEXP = /^([_a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})|)( *, *[_a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})){0,9}$/;
    return {
        require: 'ngModel',
        restrict: '',
        link: function(scope, elm, attrs, ctrl) {
            // only apply the validator if ngModel is present and Angular has added the email validator
            if (ctrl) {
                // this will overwrite the default Angular email validator
                ctrl.$validators.email = function(modelValue) {
                    return ctrl.$isEmpty(modelValue) || isEmailListValid(modelValue);
                };

                ctrl.$validators.limitExceed = function(modelValue) {
                    return ctrl.$isEmpty(modelValue) || modelValue.split(",").length <= attrs.limit;
                }


            }
        }
    };
});


smartsenseApp.directive('validateNumbers', function() {
    return {
        require: 'ngModel',
        restrict: '',
        link: function(scope, elm, attrs, ctrl) {
            // only apply the validator if ngModel is present and Angular has added the email validator
            if (ctrl) {
                // this will overwrite the default Angular email validator
                ctrl.$validators.email = function(modelValue) {
                    return ctrl.$isEmpty(modelValue) || isEmailListValid(modelValue);
                };
            }
        }
    };
});

smartsenseApp.directive('ngSpinnerBar', ['$rootScope',
    function($rootScope) {
        return {
            link: function(scope, element, attrs) {
                // by defult hide the spinner bar
                element.addClass('hide'); // hide spinner bar by default

                // display the spinner bar whenever the route changes(the content part started loading)
                $rootScope.$on('$stateChangeStart', function() {
                    element.removeClass('hide'); // show spinner bar
                });

                // hide the spinner bar on rounte change success(after the content loaded)
                $rootScope.$on('$stateChangeSuccess', function() {
                    element.addClass('hide'); // hide spinner bar
                    $('body').removeClass('page-on-load'); // remove page loading indicator
                });

                // handle errors
                $rootScope.$on('$stateNotFound', function() {
                    element.addClass('hide'); // hide spinner bar
                });

                // handle errors
                $rootScope.$on('$stateChangeError', function() {
                    element.addClass('hide'); // hide spinner bar
                });
            }
        };
    }
]);

smartsenseApp.directive('focusOn', function() {
    return function(scope, elem, attr) {
        scope.$on('focusOn', function(e, name) {
            if (name === attr.focusOn) {
                elem[0].focus();
            }
        });
    };
});

smartsenseApp.directive('ngRefreshWidget', ['$interval', function($interval) {
    return {
        scope: {
            refreshTime: '=',
            refreshFn: '&refreshFn',
            refreshToggle: '=',
            refreshDate: '='
        },
        restrict: '',
        link: function(scope, element, attrs) {
            var timer = null;
            var refreshtime = utils.getWidgetRefreshTime(scope.refreshTime);
            scope.$watch('refreshToggle', function(newValue, oldValue) {
                if (newValue) {
                    timer = $interval(function() {
                        scope.refreshDate.endDate = moment();
                        scope.refreshFn();
                    }, refreshtime);
                } else {
                    $interval.cancel(timer);
                }
            });
            scope.$on('$destroy', function() {
                if (timer) {
                    $interval.cancel(timer);
                }
            });
        }
    }
}]);

smartsenseApp.factory('focus', function($rootScope, $timeout) {
    return function(name) {
        $timeout(function() {
            $rootScope.$broadcast('focusOn', name);
        });
    }
});


smartsenseApp.directive('accessibleForm', function() {
    return {
        restrict: 'A',
        link: function(scope, elem) {
            // set up event handler on the form element
            elem.on('submit', function() {
                // find the first invalid element
                var firstInvalid = elem[0].querySelector('.ng-invalid');
                // if we find one, set focus
                if (firstInvalid) {
                    firstInvalid.focus();
                }
            });
        }
    };
});


smartsenseApp.directive('loadingIndicator', [function() {
    'use strict';
    return {
        restrict: 'E',
        link: function(scope) {
            var localDelay = (function() {
                var timer = 0;
                return function(callback, ms) {
                    clearTimeout(timer);
                    timer = setTimeout(callback, ms);
                };
            })();
            scope.$on('showLoadingIndicator', function(e, show) {
                localDelay(function() {
                    render(show);
                }, 100);
            });
            if ($("#loadingIndicatorModal").length == 0) {
                $("body").append('<div id="loadingIndicatorModal" class="modal fade bs-example-modal-lg" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel" aria-hidden="true"><div class="modal-dialog modal-sm"><div class="modal-content" ng-transclude><div class="modal-header"><h4 class="modal-title"> Please wait...</h4></div></div></div></div>');
                $("#loadingIndicatorModal").modal({
                    show: false,
                    keyboard: false,
                    backdrop: 'static'
                });
            }
            var render = function(show) {
                if (show) {
                    clearTimeout(smartsenseApp.loadingIndicatorTimeout);
                    if (!$("#loadingIndicatorModal").is(":visible")) {
                        $('.modal-backdrop').remove();
                        $("#loadingIndicatorModal").modal('show');
                    }
                } else {
                    $("#loadingIndicatorModal").modal('hide');
                    $('.modal-backdrop').remove();
                    smartsenseApp.loadingIndicatorTimeout = setTimeout(function() {
                        if (!$("#loadingIndicatorModal").is(":visible")) {
                            $('.modal-backdrop').remove();
                        }
                        smartsenseApp.loadingIndicatorTimeout = setTimeout(function() {
                            if (!$("#loadingIndicatorModal").is(":visible")) {
                                $('.modal-backdrop').remove();
                            }
                        }, 500);
                    }, 500);
                }
            };
        }
    };
}]);

$.extend($.expr[":"], {
    "containsIN": function(elem, i, match, array) {
        return (elem.textContent || elem.innerText || "").toLowerCase().indexOf((match[3] || "").toLowerCase()) >= 0;
    }
});
jQuery(document).ready(function($) {
    $(document).on('click', '.expand-collapse-trigger', function(e) {
        var $this = $(this);
        if (!$this.hasClass('panel-collapsed')) {
            $this.closest('div').find('.body').slideUp();
            $this.addClass('panel-collapsed');
            $this.find('i.icon').removeClass('fa-angle-up').addClass('fa-angle-down');
        } else {
            $this.closest('div').find('.body').slideDown();
            $this.removeClass('panel-collapsed');
            $this.find('i.icon').removeClass('fa-angle-down').addClass('fa-angle-up');
        }
    });
});

$.fn.isolatedScroll = function() {
    this.bind('mousewheel DOMMouseScroll', function(e) {
        var delta = e.wheelDelta || (e.originalEvent && e.originalEvent.wheelDelta) || -e.detail,
            bottomOverflow = this.scrollTop + $(this).outerHeight() - this.scrollHeight >= 0,
            topOverflow = this.scrollTop <= 0;

        if ((delta < 0 && bottomOverflow) || (delta > 0 && topOverflow)) {
            e.preventDefault();
        }
    });
    return this;
};

function generateRandomCode() {
    return Math.random().toString(36).substr(2, 10);
}
// Check if specified array has item
Array.prototype.has = function(value) {
    var i;
    for (var i = 0, loopCnt = this.length; i < loopCnt; i++) {
        if (this[i] === value) {
            return true;
        }
    }
    return false;
};


smartsenseApp.directive('file', function() {
    return {
        scope: {
            file: '='
        },
        link: function(scope, el, attrs) {
            el.bind('change', function(event) {
                var file = event.target.files[0];
                scope.file = file ? file : undefined;
                scope.$apply();
            });
        }
    };
});

smartsenseApp.filter('unique', function() {
    return function(input, key) {
        var unique = {};
        var uniqueList = [];
        for (var i = 0; i < input.length; i++) {
            if (typeof unique[input[i][key]] == "undefined") {
                unique[input[i][key]] = "";
                uniqueList.push(input[i]);
            }
        }
        return uniqueList;
    };
});

smartsenseApp.filter('filterMultiple', ['$filter', function($filter) {
    return function(items, keyObj) {
        var filterObj = {
            data: items,
            filteredData: [],
            applyFilter: function(obj, key) {
                var fData = [];
                if (this.filteredData.length == 0)
                    this.filteredData = this.data;
                if (obj) {
                    var fObj = {};
                    if (angular.isString(obj)) {
                        fObj[key] = obj;
                        fData = fData.concat($filter('filter')(this.filteredData, fObj));
                    } else if (angular.isArray(obj)) {
                        if (obj.length > 0) {
                            for (var i = 0; i < obj.length; i++) {
                                if (angular.isString(obj[i])) {
                                    fObj[key] = obj[i];
                                    fData = fData.concat($filter('filter')(this.filteredData, fObj));
                                }
                            }
                        }
                    }
                    if (fData.length > 0) {
                        this.filteredData = fData;
                    }
                }
            }
        };

        if (keyObj) {
            angular.forEach(keyObj, function(obj, key) {
                filterObj.applyFilter(obj, key);
            });
        }

        return filterObj.filteredData;
    }
}]);

smartsenseApp.directive('includeReplace', function () {
    return {
        require: 'ngInclude',
        restrict: 'A', /* optional */
        link: function (scope, el, attrs) {
            el.replaceWith(el.children());
        }
    };
});
smartsenseApp
.directive('uiTreeSelect', [
  '$timeout',
  function ($timeout) {
    return {
      restrict: 'E',
      scope: { model: '=',data:'=' },
      link: function (scope, el) {

        scope.breadcrumbs = [{"locationid":0,"name":"All"}];
        scope.groups = scope.data[0];

        scope.loadChildGroupsOf = function(group, $select) {
          $select.search = '';
          scope.breadcrumbs.push(group);
          scope.groups = scope.data[group.locationid];
          scope.$broadcast('uiSelectFocus');
        };

        scope.navigateBackTo = function (crumb, $select) {    
          $select.search = '';
          var index = _.findIndex(scope.breadcrumbs, {locationid: crumb.locationid});
          scope.breadcrumbs.splice(index + 1, scope.breadcrumbs.length);
          scope.groups = scope.data[_.last(scope.breadcrumbs).locationid];
          $select.open = false;
          scope.$broadcast('uiSelectFocus');
        };

      },
      templateUrl: 'directives/ui-tree-select/ui-tree-select.tpl.html'
    };
  }
  ])

// Couldn't get on-focus to work, so wrote my own
.directive('uiSelectFocuser', function ($timeout) {
  return {
    restrict: 'A',
    require: '^uiSelect',
    link: function (scope, elem, attrs, uiSelect) {
      scope.$on('uiSelectFocus', function () {
        $timeout(uiSelect.activate);
      });
    }
  };
})

.run(['$templateCache', function ($templateCache) {
  // Overrides selectize template for group select tree.
  $templateCache.put('selectize/choices.tpl.html', [
    '<div ng-show="$select.open"',
    '  class="ui-select-choices group-tree selectize-dropdown single">',
    '  <div ng-show="breadcrumbs.length > 1" class="ui-select-breadcrumbs">',
    '    <span class="ui-breadcrumb" ng-repeat="crumb in breadcrumbs"',
    '       ng-click="navigateBackTo(crumb, $select)">',
    '       {{crumb.name}}',
    '    </span>',
    '  </div>',
    '  <div class="ui-select-choices-content selectize-dropdown-content">',
    '    <div class="ui-select-choices-group optgroup">',
    '      <div ng-show="$select.isGrouped"',
    '        class="ui-select-choices-group-label optgroup-header">',
    '        {{$group}}',
    '      </div>',
    '      <div class="ui-select-choices-row">',
    '        <div class="option ui-select-choices-row-inner"',
    '           data-selectable="">',
    '        </div>',
    '      </div>',
    '    </div>',
    '  </div>',
    '</div>'
    ].join(''));
}])




smartsenseApp.filter('ranked', function() {
    return function(obj, searchKey) {
        if (!obj || !searchKey)
            return obj;
        searchKey = searchKey.toLowerCase();
        for (var i = 0; i < obj.length; i++) {
            var currentObj = obj[i];
            currentObj.rank = currentObj.name.toLowerCase().indexOf(searchKey);
        }
        return obj;
    }
});

smartsenseApp.filter('INR', function() {
    return function(input) {
        if (!isNaN(input)) {
            var currencySymbol = 'â¹';
            var result = input.toString().split('.');
            var lastThree = result[0].substring(result[0].length - 3);
            var otherNumbers = result[0].substring(0, result[0].length - 3);
            if (otherNumbers != '')
                lastThree = ',' + lastThree;
            var output = otherNumbers.replace(/\B(?=(\d{2})+(?!\d))/g, ",") + lastThree;
            if (result.length > 1) {
                output += "." + result[1];
            }
            return output;
        }
    }
});

smartsenseApp.filter('formatData', function() {
    return function(number, sf, text) {
        return utils.formatData(number, sf, text);
    };
});

smartsenseApp.filter('formatCurrency', function() {
    return function(number, sf, text) {
        return utils.formatCurrency(number, sf, text);
    };
});

smartsenseApp.filter('ROUND', function() {
    return function(input) {
        return utils.roundAbs(input);
    }
});

smartsenseApp.filter('cut', function () {
    return function (value, wordwise, max, tail) {
        if (!value) return '';
        max = parseInt(max, 10);
        if (!max) return value;
        if (value.length <= max) return value;
        value = value.substr(0, max);
        if (wordwise) {
            var lastspace = value.lastIndexOf(' ');
            if (lastspace !== -1) {
                //Also remove . and , so its gives a cleaner result.
                if (value.charAt(lastspace-1) === '.' || value.charAt(lastspace-1) === ',') {
                    lastspace = lastspace - 1;
                }
                value = value.substr(0, lastspace);
            }
        }
        return value + (tail || ' â¦');
    };
});


/* depends on MomentJS being available as a global */
smartsenseApp.filter('dateFormatter', function() {
  return function(date, format) {
    if(!moment) {
      console.log('Error: momentJS is not loaded as a global');
      return '!momentJS';
    }
    if(!format) {
      return moment(date).fromNow();
    } else {
      return moment(date).format(format); //in absence of format parameter, return the relative time from the given date
    }
  }
});

smartsenseApp.filter('range', function() {
  return function(input, total) {
    total = parseInt(total);

    for (var i=0; i<total; i++) {
      input.push(i);
    }

    return input;
  };
});

smartsenseApp.filter('trustAsHtml',function($sce){
    return function(htmlCode){
        return $sce.trustAsHtml(htmlCode);
    }
});
smartsenseApp.factory('RecursionHelper', ['$compile', function($compile){
    return {
        /**
         * Manually compiles the element, fixing the recursion loop.
         * @param element
         * @param [link] A post-link function, or an object with function(s) registered via pre and post properties.
         * @returns An object containing the linking functions.
         */
         compile: function(element, link){
            // Normalize the link parameter
            if(angular.isFunction(link)){
                link = { post: link };
            }

            // Break the recursion loop by removing the contents
            var contents = element.contents().remove();
            var compiledContents;
            return {
                pre: (link && link.pre) ? link.pre : null,
                /**
                 * Compiles and re-adds the contents
                 */
                 post: function(scope, element){
                    // Compile the contents
                    if(!compiledContents){
                        compiledContents = $compile(contents);
                    }
                    // Re-add the compiled contents to the element
                    compiledContents(scope, function(clone){
                        element.append(clone);
                    });

                    // Call the post-linking function, if any
                    if(link && link.post){
                        link.post.apply(null, arguments);
                    }
                }
            };
        }
    };
}]);

/*
** @author Hardik Sondagar
** @abstract Load Google Map API script dynamically.
*/
(function() {
    'use strict';

    smartsenseApp.factory('googleMapReady', ['$document', '$q', '$rootScope',
        function($document, $q, $rootScope) {
            var d = $q.defer();

            function onScriptLoad() {
            // Load client in the browser
            $rootScope.$apply(function() {
                d.resolve();
            });
        }

        /* Check if already loaded */
        if (typeof google === 'object' && typeof google.maps === 'object') {
            d.resolve();
        } else {
            // Create a script tag with d3 as the source
            // and call our onScriptLoad callback when it
            // has been loaded
            // var scriptTag = $document[0].createElement('script');
            // scriptTag.type = 'text/javascript';
            // scriptTag.async = true;
            // scriptTag.src = '//maps.googleapis.com/maps/api/js?key=AIzaSyC8MJ0ZbPh59Xa47rf_yaAJy_4z_oA4yVc';
            // scriptTag.onreadystatechange = function() {
            //     if (this.readyState == 'complete') onScriptLoad();
            // };
            // scriptTag.onload = onScriptLoad;

            // var s = $document[0].getElementsByTagName('body')[0];
            // s.appendChild(scriptTag);
        }
        return {
            ready: function() {
                return d.promise;
            }
        };
    }
    ]);

}());


// Inspectlet Service for Tagging loggedin member
smartsenseApp.factory('inspectletService', inspectletService);
inspectletService.$inject = [];
function inspectletService() {
    var service = {
        tagMember: tagMember
    };
    return service;
    ////////////
    function tagMember(member) {
        __insp.push(['tagSession', {'username':member.username,'memberid':member.memberid}]);
    }
}


smartsenseApp.factory('menuService', ['apiService', '$state','$q', function (apiService, $state, $q) {
    var _this = this;

    _this.URLMapping = {
        "/dashboard/" : {
            sref : "home.dashboard",
            menukey : "overview",
            title : "Overview",
            desc : "Overview allows you to have hawk-eye view of location on a single page",
            icon : "fa-eye"
        },
        "/configuration/" : {
            sref : "home.configuration",
            menukey : "configuration",
            title : "Configuration",
            desc : "Configuration allows you to add Sensor and Manual data of sensors.",
            icon : "fa-cog"
        },
        "/sensor-data/" : {
            sref : "home.sensordata",
            menukey : "sensordata",
            title : "SensorData",
            desc : "Sensor Data allows you to generate sheets for upload data manually.",
            icon : "fa-upload"
        },
        "/mydashboard/" : {
            sref : "home.mydashboard",
            menukey : "mydashboard",
            title : "My Dashboard",
            desc : "My Dashboard show all configured widgets.",
            icon : "fa-desktop"
        },
        "/alert/" : {
            sref : "home.alert",
            menukey : "alert",
            title : "Alert",
            desc : "Manage and configure Alerts",
            icon : "fa-bell icon-custom-color"
        },
        "/analyse/" : {
            sref : "home.analyse",
            menukey : "analyse",
            title : "Analyse",
            desc : "Graphical visualization of the parameters",
            icon : "fa-search fa-1 icon-custom-color"
        },
        "/reports/" : {
            sref : "home.reports",
            menukey : "reports",
            title : "Reports",
            desc : "Download reports",
            icon : "fa-file-o fa-1g icon-custom-color"
        },
        "/networkInsights/" : {
            sref : "home.networkInsights",
            menukey : "networkInsights",
            title : "Network Insights",
            desc : "Check all issues and tickets related to your network",
            icon : "fa-sitemap"
        },
        "/motorInsights/" : {
            sref : "home.motorInsights",
            menukey : "motorInsights",
            title : "Motor Insights",
            desc : "Analyse isuses and tickets related to your motors",
            icon : "fa-gear"
        },
        "/transformerInsights/" : {
            sref : "home.transformerInsights",
            menukey : "transformerInsights",
            title : "Transformer Insights",
            desc : "Analyse isuses and tickets related to your transformers",
            icon : "fa-flash"
        },
        "/billingInsights/" : {
            sref : "home.billingInsights",
            menukey : "billingInsights",
            title : "Billing Insights",
            desc : "Analyse your billing",
            icon : "fa-rupee"
        },
        "/chillerInsights/" : {
            sref : "home.chillerInsights",
            menukey : "chillerInsights",
            title : "Chiller Insights",
            desc : "Analyse isuses and tickets related to your chillers",
            icon : ""
        },
        "/dmrc-dashboard/" : {
            sref : "home.dmrcdashboard",
            menukey : "dmrcdashboard",
            title : "Equipment Error Management",
            desc : "DMRC Equipment error management dashboard",
            icon : "fa-sort"
        },
        "/dmrc-alert/" : {
            sref : "home.dmrcalert",
            menukey : "dmrcalert",
            title : "Alert",
            desc : "Manage and configure Alerts",
            icon : "fa-bell icon-custom-color"
        },
        "/dmrc-reports/" : {
            sref : "home.dmrcreports",
            menukey : "dmrcreports",
            title : "Reports",
            desc : "Download reports",
            icon : "fa-file-o fa-1g icon-custom-color"
        },
        "/utilization/" : {
            sref : "home.utilization",
            menukey : "utilization",
            title : "Utilization",
            desc : "Utilization Dashboard",
            icon : "fa-bar-chart"
        }
    };
    return _this;
}]);

var prepareLocationTree = function(locations, member_locations) {
    var tree = {
        0:[]
    };
    locations.map(function(location, index) {
        var parent = location.parentlocationid || 0;
        tree[parent] = new Array();
    });
    tree[0].push({
        locationid:null,
        name:'All Locations',
        parent:false
    })
    locations.map(function(location, index) {
        var parent = location.parentlocationid || 0;
        location.parent = tree.hasOwnProperty(location.locationid)
        tree[parent].push(location);
    });
    member_locations.map(function(location, index) {
        if(location.parentlocationid) {
            tree[0].push(location);
        }
    });
    return tree;
}


var arrayToObject = function(arr, key) {
    var obj = {};
    for (var i = 0, len = arr.length; i < len; i++) {
        if(arr[i].hasOwnProperty(key)) {
            obj[arr[i][key]] = arr[i];
        }
    }
    return obj;
}

var arrayGroupBy = function(arr, key) {
    var arrGroup = {};
    for (var i = 0, len = arr.length; i < len; i++) {
        if(arr[i].hasOwnProperty(key)) {
            if(!arrGroup.hasOwnProperty(arr[i][key])) {
                arrGroup[arr[i][key]] = [];
            }
            arrGroup[arr[i][key]].push(arr[i]);
        }
    }
    return arrGroup;
}

smartsenseApp.service('apiCacheFactory', apiCacheFactory);
apiCacheFactory.$inject = ['$cacheFactory'];
function apiCacheFactory($cacheFactory) {
    this.clearAll = function(){
        angular.forEach($cacheFactory.info(), function(ob, key) {
            if(key == '$http') {
                $cacheFactory.get(key).removeAll();
            }
        });
    }
}


smartsenseApp.service('Session', Session);
Session.$inject = ['localStorageService'];
function Session(localStorageService) {

    _this = this;

    _this.put = function(key, value) {
        return localStorageService.set(key,value);
    };

    _this.remove = function(key) {
        return localStorageService.remove(key)
    };

    _this.get = function(key) {
        return localStorageService.get(key)
    }

    _this.clearAll = function() {
        return localStorageService.clearAll();
    }

    _this.messageVersionsByLocationId = function(locationid) {
        var versions = [], location = _this.data.locations[locationid];
        if(location) {
            if(!location.virtual) {
                var sensorids = _this.data.location_sensors_mapping[location.locationid] || [];
                for(var i=0; i<sensorids.length; i++) {
                    versions.push(_this.data.sensors[sensorids[i]].messageversion);
                }
             } else {
                angular.forEach(_this.data.location_parent_mapping[locationid],function(child_location){
                    versions = versions.concat(_this.messageVersionsByLocationId(child_location.locationid));
                });
            }
        }
        return versions;
    }

    _this.init = function(data) {
        // Memner Info
        _this.data.member = data.member;
        // Member's Serivces
        _this.data.member_services = data.member_services;
        // Location list
        _this.data.member_locations = data.member_locations;
        // Location list
        _this.data.locationlist = data.locations;
        // Message versions -> ReadingType mapping
        _this.data.version_readingtype_mapping = data.version_readingtype_mapping;
        _this.data.locations = arrayToObject(_this.data.locationlist,'locationid');
        _this.data.locations[0] = {locationid:null,name:'All Locations',parentlocationid:null,virtual:true, messageversions:Object.keys(_this.data.version_readingtype_mapping)};
        // Location Tree
        _this.data.location_parent_mapping = {};
        for (var i = 0, len = _this.data.locationlist.length; i < len; i++) {
            var parent = _this.data.locationlist[i]['parentlocationid'] || 0;
            if(!_this.data.location_parent_mapping.hasOwnProperty(parent)) {
                _this.data.location_parent_mapping[parent] = [];
            }
            _this.data.location_parent_mapping[parent].push(_this.data.locationlist[i]);
        }
        // Sensor List
        _this.data.sensorlist = data.sensors;
        // Sensors Object with SensorId as key
        _this.data.sensors = arrayToObject(_this.data.sensorlist,'sensorid');
        // Location -> Sensors mapping
        _this.data.location_sensors_mapping = {};
        for (var i = 0, len = _this.data.sensorlist.length; i < len; i++) {
            var locationid = _this.data.sensorlist[i]['mappedlocationid'];
            if(!_this.data.location_sensors_mapping.hasOwnProperty(locationid)) {
                _this.data.location_sensors_mapping[locationid] = [];
            }
            _this.data.location_sensors_mapping[locationid].push(_this.data.sensorlist[i].sensorid);
        }
        // Readingtype List
        _this.data.readingtypeslist = data.readingtypes;
        // Readingtypes object with readingtypeid as a key
        _this.data.readingtypes = arrayToObject(_this.data.readingtypeslist,'readingtypeid');
        // 12
        // _this.data.version_readingtype_mapping = data.version_readingtype_mapping;
        // 13
        _this.data.sensortypes = [{value: null, label: "All"},{value: "1001", label: "Consumption"}, {value: "1002,1003", label: "Generation"}];
        // 14
        _this.data.dateFormat = 'YYYY-MM-DD HH:mm:ss';

        for(var i=0; i<_this.data.locationlist.length; i++) {
            _this.data.locationlist[i].messageversions = _this.messageVersionsByLocationId(_this.data.locationlist[i].locationid);
        }

        // Store data
        this.put('member',_this.data.member);
        this.put('member_services',_this.data.member_services);
        this.put('member_locations',_this.data.member_locations);
        this.put('locationlist',_this.data.locationlist);
        this.put('locations',_this.data.locations);
        this.put('location_parent_mapping',_this.data.location_parent_mapping);
        this.put('sensorlist',_this.data.sensorlist);
        this.put('sensors',_this.data.sensors);
        this.put('location_sensors_mapping',_this.data.location_sensors_mapping);
        this.put('readingtypeslist',_this.data.readingtypeslist);
        this.put('readingtypes',_this.data.readingtypes);
        this.put('version_readingtype_mapping',_this.data.version_readingtype_mapping);
        this.put('sensortypes',_this.data.sensortypes);
        this.put('dateFormat',_this.data.dateFormat);

    }

    _this.getAll = function() {
        var keys = localStorageService.keys();
        var obj = {};
        for (var i = 0, len = keys.length; i < len; i++) {
            obj[keys[i]] = _this.get(keys[i]);
        }
        return obj;
    }

    _this.data = _this.getAll();


}



smartsenseApp.factory('authService', authService);

authService.$inject = ['$q', '$rootScope', 'apiCacheFactory', 'Session', 'apiService'];

function authService($q, $rootScope, apiCacheFactory, Session, apiService) {

    var service = {
        login: login,
        logout: logout,
        isAuthenticated: isAuthenticated,
        refreshData:refreshData
    };

    function login(params) {
        var deferred = $q.defer();
        return apiService.auth_login(params).success(function(data) {
            Session.put('authToken', data.token);
            Session.put('memberId', data.memberid);
            Session.init(data.data);
            $rootScope.$emit('loginSuccess');
            deferred.resolve(data);
        }).error(function(data) {
            Session.clearAll();
            $rootScope.$emit('loginFailed');
            deferred.reject(deferred.resolve(data));
        });
    };

    function logout() {
        Session.clearAll()
        apiService.auth_logout();
        apiCacheFactory.clearAll();
        $rootScope.$broadcast('loggedOut');
    }

    function isAuthenticated() {
        return !!Session.get('authToken');
    }

    function refreshData() {
        apiService.data_preload().success(function(data) { 
            Session.init(data);
            $rootScope.$emit('dataRefrehed');
        });
    }

    return service;

}

smartsenseApp.factory('apiService', apiService);

apiService.$inject = ['$http', 'SETTINGS', 'grainService', 'timeseriesService', 'local'];

function apiService($http, SETTINGS, grainService, timeseriesService, local) {

    var reading_date_format = 'YYYY-MM-DD HH:mm:ss';
    var sld_date_format = 'YYYY-MM-DD';
    var time_zone = 'Asia/Kolkata';

    var service = {

        // Auth Module
        auth_login: auth_login,
        auth_logout: auth_logout,
        auth_token_refresh: auth_token_refresh,
        auth_password_reset_request: auth_password_reset_request,
        auth_password_reset: auth_password_reset,
        member_services: member_services,
        auth_password_change: auth_password_change,
        data_preload: data_preload,

        // Profile Module
        profile_get: profile_get,
        profile_save: profile_save,

        // Independent APIs
        unitcost: unitcost,
        member: member,
        member_theme: member_theme,
        readingtype: readingtype,
        sensors: sensors,
        sensor_health: sensor_health,
        livetable: livetable,
        member_tc_accept: member_tc_accept,

        // Location Module
        location_main: location_main,
        location_all: location_all,
        location_billing: location_billing,
        location_child: location_child,
        location_tree: location_tree,

        // Reading Module
        reading_series: reading_series,
        reading_trend: reading_trend,
        reading_value: reading_value,
        reading_live: reading_live,
        reading_live_multiple: reading_live_multiple,
        reading_computed: reading_computed,
        reading_computed_data:reading_computed_data,
        reading_computed_live:reading_computed_live,

        // SLD Module
        sld_treeview: sld_treeview,
        sld_blockview: sld_blockview,

        // Alert & Event Module
        alert_get: alert_get,
        alert_list: alert_list,
        alert_save: alert_save,
        alert_update_status: alert_update_status,
        alert_delete: alert_delete,
        event_get: event_get,
        event_save: event_save,
        event_delete: event_delete,

        // Report Module
        report_send: report_send,
        report_download: report_download,
        report_list: report_list,
        report_config: report_config,
        report_delete: report_delete,
        report_config_download: report_config_download,


        // Widget Module
        widget_list: widget_list,
        widget_get: widget_get,
        widget_save: widget_save,
        widget_delete: widget_delete,
        widget_changeorder: widget_changeorder,
        widget_livetable: widget_livetable,
        widget_daterule: widget_daterule,
        widget_type: widget_type,

        // Network Insights
        network_get_issue_summary: network_get_issue_summary,
        network_get_activity_log: network_get_activity_log,
        network_get_issue_data: network_get_issue_data,
        network_submit_activity_log: network_submit_activity_log,
        network_get_baseline: network_get_baseline,
        network_get_actual: network_get_actual,

        //Motor Insights
        motor_get_issue_summary: motor_get_issue_summary,
        motor_get_event_date: motor_get_event_date,
        motor_get_activity_log: motor_get_activity_log,
        motor_get_baseline: motor_get_baseline,

        //Motor Insights New
        motor_events_summary: motor_events_summary,
        motor_events_summary_date: motor_events_summary_date,
        motorevents_monitorloading: motorevents_monitorloading,
        motorevents_monitorimbalance: motorevents_monitorimbalance,
        motor_submit_activity_log: motor_submit_activity_log,

        //Billing Insights
        billing_get_widgets: billing_get_widgets,
        billing_simulator_widgets: billing_simulator_widgets,
        billing_get_city_list: billing_get_city_list,
        billing_simulate_solar_pv: billing_simulate_solar_pv,
        billing_get_consumption_details: billing_get_consumption_details,
        billing_get_bill_by_billing_cycle: billing_get_bill_by_billing_cycle,
        billing_get_pf_details: billing_get_pf_details,

        //DMRC Specific
        get_location_with_geo: get_location_with_geo,
        getLiftDeftails : getLiftDeftails,
        getLiftNotifications : getLiftNotifications,
        getLiftErrorStats : getLiftErrorStats,
        gis_widget_dmrc: gis_widget_dmrc,
        get_sldfordmrc: get_sldfordmrc,

        gis_widget: gis_widget,

        //Transformer Insights
        transformer_get_recent_event_date: transformer_get_recent_event_date,
        transformer_get_issue_summary: transformer_get_issue_summary,
        transformer_get_details: transformer_get_details,
        transformer_submit_activity_log: transformer_submit_activity_log,
        transformer_get_action_items: transformer_get_action_items,

        //Transformer Insights New
        transformer_get_summary: transformer_get_summary,
        transformer_get_event_date: transformer_get_event_date,
        transformer_get_graph_details: transformer_get_graph_details,
        transformer_get_monitoring_graph: transformer_get_monitoring_graph,

        // Transformer 2.0
        tx_insights_summary: tx_insights_summary,
        tx_insights_activity_log: tx_insights_activity_log,

        // Chiller Insights
        chiller_list: chiller_list,
        chiller_uiconfigs: chiller_uiconfigs,

        //Sensor Configuration
        get_sensor_list: get_sensor_list,
        get_appliance_type: get_appliance_type,
        get_meter_list: get_meter_list,
        download_template: download_template,
        get_reading_type_list: get_reading_type_list,
        create_sensor: create_sensor,
        update_sensor: update_sensor,
        create_or_update_motor_meta: create_or_update_motor_meta,
        create_or_update_tx_meta: create_or_update_tx_meta,
        get_motor_meta: get_motor_meta,
        get_tx_meta: get_tx_meta,
        send_command : send_command,

        //Data upload
        generate_excel_for_manual_sensor: generate_excel_for_manual_sensor,
        upload_excel_for_manual_sensor: upload_excel_for_manual_sensor,

        // Cycle Distribution
        cycle_get_distribution: cycle_get_distribution,

        //Activity Log for Tx and Motor
        get_insights_activity_log: get_insights_activity_log,
        insights_activity_type: insights_activity_type,
        add_manual_insights_log: add_manual_insights_log,
        activityLog_download: activityLog_download,
        activityLog_email: activityLog_email,

        //Eaton Utilization Dashboard
        eaton_utilization_categories: eaton_utilization_categories,
        eaton_utilization_timeseries: eaton_utilization_timeseries,

        //Tree Builder
        create_tree: create_tree,
        retrieve_tree: retrieve_tree,
        create_node: create_node,
        get_tree_nodes: get_tree_nodes,
        edit_node: edit_node,
        delete_node: delete_node,
        get_single_node: get_single_node,

        //Image Upload
        media_handler: media_handler,
        media_handler_img: media_handler_img,

        // Json Data
        jsondata: jsondata
    };

    function setFromAndToDate(fromdate, todate, format, allow_futuredate) {
        format = format || reading_date_format;
        fromdate = moment(fromdate);
        if (!allow_futuredate) {
            todate = moment.min(moment(todate), moment());
        }
        return {
            fromdate: fromdate.tz(time_zone).format(format),
            todate: todate.tz(time_zone).format(format)
        };
    }

    // Helper Functions Get allowed grain of given daterange. Useful to set grain
    // when it's not passed
    function getDefaultGrain(fromdate, todate) {

        var grainObj = grainService.getFirst(moment(fromdate), moment(todate));
        if (grainObj.value == 1) {
            grainObj.value = 15;
        }
        if (grainObj.value <= grain) {
            return grain;
        }
        return grainObj.value;

    }

    //////////////////

    function auth_login(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/api_token_auth/',
            headers: {
                'Content-Type': "application/x-www-form-urlencoded"
            },
            method: "POST",
            data: $.param(params),
        };
        return $http(req);
    }

    function auth_logout() {
        var req = {
            url: SETTINGS.BASE_URL + '/logout/',
            method: 'GET'
        };
        return $http(req);
    }

    function auth_token_refresh() {
        var req = {
            url: SETTINGS.BASE_URL + '/api_token_refresh/',
            method: 'GET'
        };
        return $http(req);
    }

    function auth_password_change(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/change_my_password/',
            headers: {
                'Content-Type': "application/x-www-form-urlencoded"
            },
            method: "POST",
            data: $.param(params),
        };
        return $http(req);
    }

    function auth_password_reset_request(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/reset_password/',
            method: 'GET',
            params: {}
        };
        if (params.mobilenumber) {
            req.params.mobilenumber = params.mobilenumber;
        }
        if (params.emailid) {
            req.params.emailid = params.emailid;
        }
        if (params.username) {
            req.params.username = params.username;
        }
        return $http(req);
    }

    function auth_password_reset(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/newpassword/',
            params: {
                token: params.token.replace("token=", ""),
                newpassword1: params.newpassword1,
                newpassword2: params.newpassword2
            },
            method: 'GET'
        };
        return $http(req);
    }

    function data_preload() {
        var req = {
            url: SETTINGS.BASE_URL + '/preload/',
            method: 'GET'
        };
        return $http(req);
    }

    function profile_get() {
        var req = {
            url: SETTINGS.BASE_URL + '/profile/',
            params: {
                dontShowError: true
            },
            method: 'GET'
        };
        return $http(req);
    }

    function profile_save(payload) {
        payload.dontShowError = true;
        var req = {
            url: SETTINGS.BASE_URL + '/profile/',
            data: $.param(payload),
            method: 'POST'
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    // Unitcost = (Reading value)*(UnitRate of passed location or sensor)
    function unitcost(params) {

        var daterange = setFromAndToDate(params.fromdate, params.todate);

        var req = {
            url: SETTINGS.BASE_URL + '/unitcost/',
            method: 'GET',
            params: {
                fromdate: daterange.fromdate,
                todate: daterange.todate,
                readingtypeid: params.readingtypeid
            }
        };

        if (params.sensorid) {
            req.params.sensorid = params.sensorid;
        } else if (params.locationid) {
            req.params.locationid = params.locationid;
        }

        if (params.sensortypeid) {
            req.params.sensortypeid = params.sensortypeid;
        }

        return $http(req);

    }

    function member() {

        var req = {
            url: SETTINGS.BASE_URL + '/member/',
            method: 'GET'
        };

        return $http(req);
    }

    function member_theme() {

        var req = {
            url: SETTINGS.BASE_URL + '/member_theme/',
            method: 'GET'
        };

        return $http(req);

    }

    function member_services() {
        var req = {
            url: SETTINGS.BASE_URL + '/member_services/',
            method: 'GET'
        };
        return $http(req);
    }

    function member_tc_accept() {
        var req = {
            url: SETTINGS.BASE_URL + '/member_tc_accept/',
            headers: {
                'Content-Type': "application/x-www-form-urlencoded"
            },
            method: "POST"
        };
        return $http(req);
    }

    function readingtype(params) {

        params = params || {};

        var req = {
            url: SETTINGS.BASE_URL + '/reading_type/',
            method: 'GET',
            cache: true,
            params: {}
        };

        if (params.sensorid) {
            req.params.sensorid = params.sensorid;
        } else if (params.locationid && utils.isNumeric(params.locationid)) {
            req.params.locationid = params.locationid;
        }

        return $http(req);

    }

    function sensors() {
        var req = {
            url: SETTINGS.BASE_URL + '/sensor/',
            method: 'GET',
            cache: true
        };
        return $http(req);
    }

    function sensor_health() {
        var req = {
            url: SETTINGS.BASE_URL + '/sensor_health_summary/',
            method: 'GET',
            params: {
                type: 'live'
            }
        };
        return $http(req);
    }

    function livetable() {
        var req = {
            url: SETTINGS.BASE_URL + '/get_live/',
            method: 'GET'
        };
        return $http(req);
    }

    function location_main() {

        var req = {
            url: SETTINGS.BASE_URL + '/location/',
            method: 'GET',
            cache: true
        };

        return $http(req);

    }

    function location_all() {
        var req = {
            url: SETTINGS.BASE_URL + '/location/',
            method: 'GET',
            params: {
                all: true
            },
            cache: true
        };
        return $http(req);
    }

    function location_billing() {
        var req = {
            url: SETTINGS.BASE_URL + '/getallbillinglocations/',
            method: 'GET'
        };
        return $http(req);
    }

    function location_child(locationid) {
        var req = {
            url: SETTINGS.BASE_URL + '/sublocation/',
            method: 'GET',
            params: {
                locationid: locationid
            },
            cache: true
        };
        return $http(req);
    }

    function location_tree(locationid) {
        var req = {
            url: SETTINGS.BASE_URL + '/treeview_location_data/',
            method: 'GET',
            params: {
                locationid: locationid
            }
        };
        return $http(req);
    }

    function reading_live(params) {

        var req = {
            url: SETTINGS.BASE_URL + '/reading_live/',
            method: 'GET',
            params: {
                readingtypeid: params.readingtypeid,
                sensortypeid: params.sensortypeid
            }
        };

        if (params.sensorid) {
            req.params.sensorid = params.sensorid;
        } else if (params.locationid) {
            req.params.locationid = params.locationid;
        }

        if (params.sensortypeid) {
            req.params.sensortypeid = params.sensortypeid;
        }

        return $http(req);

    }

    function reading_live_multiple(sensorids, readingtypeids) {

        var req = {
            url: SETTINGS.BASE_URL + '/reading_live/',
            method: 'POST',
            data: {
                readingtypeids: readingtypeids,
                sensorids: sensorids
            }
        };

        return $http(req);

    }

    function reading_value(params) {

        var daterange = setFromAndToDate(params.fromdate, params.todate);

        var req = {
            url: SETTINGS.BASE_URL + '/reading_data/',
            method: 'GET',
            params: {
                fromdate: daterange.fromdate,
                todate: daterange.todate,
                readingtypeid: params.readingtypeid
            },
            cache: true
        };

        if (params.sensorid) {
            req.params.sensorid = params.sensorid;
        } else if (params.locationid) {
            req.params.locationid = params.locationid;
        }

        if (params.sensortypeid) {
            req.params.sensortypeid = params.sensortypeid;
        }

        return $http(req);

    }

    function reading_series(params) {

        var daterange = setFromAndToDate(params.fromdate, params.todate);

        var req = {
            url: SETTINGS.BASE_URL + '/reading_series/',
            method: 'GET',
            params: {
                fromdate: daterange.fromdate,
                todate: daterange.todate,
                grain: params.grain,
                readingtypeid: params.readingtypeid
            },
            cache: true
        };

        if (params.sensorid) {
            req.params.sensorid = params.sensorid;
        } else if (params.locationid) {
            req.params.locationid = params.locationid;
        }

        if (params.sensortypeid) {
            req.params.sensortypeid = params.sensortypeid;
        }

        return $http(req);
    }

    function reading_trend(params) {

        var daterange = setFromAndToDate(params.fromdate, params.todate);

        var daterange_to_compare = setFromAndToDate(params.fromdate_tocompare, params.todate_tocompare);

        var req = {
            url: SETTINGS.BASE_URL + '/reading_trend/',
            method: 'GET',
            params: {
                fromdate: daterange.fromdate,
                todate: daterange.todate,
                fromdate_tocompare: daterange_to_compare.fromdate_tocompare,
                todate_tocompare: daterange_to_compare.todate_tocompare,
                grain: params.grain,
                readingtypeid: params.readingtypeid
            },
            cache: true
        };

        if (params.sensorid) {
            req.params.sensorid = params.sensorid;
        } else if (params.locationid) {
            req.params.locationid = params.locationid;
        }

        if (params.sensortypeid) {
            req.params.sensortypeid = params.sensortypeid;
        }

        return $http(req);
    }

    function reading_computed(params) {

        var daterange = setFromAndToDate(params.fromdate, params.todate);

        if (!params.grain) {
            params.grain = getDefaultGrain(fromdate, todate);
        }
        var payload = {
            fromdate: daterange.fromdate,
            todate: daterange.todate,
            grain: params.grain,
            computed_parameter: params.computed_parameter
        };
        var req = {
            url: SETTINGS.BASE_URL + '/reading_computed/',
            method: 'POST',
            data: payload
        };
        return $http(req);
    }

    function reading_computed_data(params) {

        var daterange = setFromAndToDate(params.fromdate, params.todate);

        var payload = {
            fromdate: daterange.fromdate,
            todate: daterange.todate,
            computed_parameter: params.computed_parameter
        };
        var req = {
            url: SETTINGS.BASE_URL + '/reading_computed_data/',
            method: 'POST',
            data: payload
        };
        return $http(req);
    }

    function reading_computed_live(params) {

        var payload = {
            computed_parameter: params.computed_parameter
        }
        var req = {
            url: SETTINGS.BASE_URL + '/reading_computed_live/',
            method: 'POST',
            data: payload
        };
        return $http(req);
    }


    function sld_treeview(params) {

        var daterange = setFromAndToDate(params.fromdate, params.todate);

        var req = {
            url: SETTINGS.BASE_URL + '/location_treeview/',
            method: 'GET',
            params: {
                fromdate: daterange.fromdate,
                todate: daterange.todate,
                readingtypeid: params.readingtypeid,
                dist: true
            },
            cache: true

        };
        return $http(req);
    }

    function sld_blockview(params) {

        var fromdate = params
            .fromdate.clone()
            .startOf("day")
            .format(sld_date_format);
        var todate = params
            .todate.clone()
            .endOf("day")
            .format(sld_date_format);

        var req = {
            url: SETTINGS.BASE_URL + '/sld/',
            method: 'GET',
            params: {
                fromdate: fromdate,
                todate: todate,
                readingtypeid: params.readingtypeid
            },
            cache: true
        };

        return $http(req);

    }

    function alert_get(alertid) {
        var req = {
            url: SETTINGS.BASE_URL + '/alert_detail/',
            method: 'GET',
            params: {
                alertid: alertid
            }
        };
        return $http(req);
    }

    // This API gives both the alerts and events list
    function alert_list() {
        var req = {
            url: SETTINGS.BASE_URL + '/alert/',
            method: 'GET'
        };
        return $http(req);
    }

    function alert_save(payload) {
        var req = {
            url: SETTINGS.BASE_URL + '/java_auth_layerfrompython/',
            method: 'POST',
            data: $.param({
                data: JSON.stringify(payload),
                url: 'alerts/update'
            })
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function alert_update_status(alertlist) {
        var req = {
            url: SETTINGS.BASE_URL + '/java_auth_layerfrompython/',
            method: 'POST',
            data: $.param({
                data: JSON.stringify({ alertStatus: alertlist }),
                url: 'alerts/status'
            })
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function alert_delete(alertid) {
        var req = {
            url: SETTINGS.BASE_URL + '/java_auth_layerfrompython/',
            method: 'POST',
            data: $.param({
                data: JSON.stringify({ alertId: alertid }),
                url: 'alerts/delete'
            })
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function event_get(eventid) {
        var req = {
            url: SETTINGS.BASE_URL + '/alert_detail/',
            method: 'GET',
            params: {
                eventid: eventid
            }
        };
        return $http(req);
    }

    function event_save(payload) {
        var req = {
            url: SETTINGS.BASE_URL + '/java_auth_layerfrompython/',
            method: 'POST',
            data: $.param({
                data: JSON.stringify(payload),
                url: "alerts/update-events"
            })
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function event_delete(eventid) {
        var req = {
            url: SETTINGS.BASE_URL + '/java_auth_layerfrompython/',
            method: 'POST',
            data: $.param({
                data: JSON.stringify({ eventId: eventid }),
                url: "alerts/delete-event"
            })
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function report_send(payload) {
        var req = {
            url: SETTINGS.BASE_URL + '/java_auth_layerfrompython/',
            method: 'POST',
            data: $.param({
                data: JSON.stringify({
                    "grain": payload
                        .grain
                        .toString(),
                    "fromTime": payload
                        .fromDate
                        .valueOf(),
                    "toTime": payload
                        .toDate
                        .valueOf(),
                    "reportFormat": payload.reportFormat,
                    "aggregation": payload.aggregation,
                    "emailId": payload.email,
                    "locations": payload.locations,
                    "readingTypes": payload.IndividualParameters,
                    "reportGroups": payload.GroupParameters
                }),
                url: 'report-data'
            })
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function report_download(payload) {
        var req = {
            url: SETTINGS.BASE_URL + '/java_auth_layerfrompython/',
            method: 'POST',
            data: $.param({
                data: JSON.stringify({
                    "grain": payload
                        .grain
                        .toString(),
                    "fromTime": payload
                        .fromDate
                        .valueOf(),
                    "toTime": payload
                        .toDate
                        .valueOf(),
                    "reportFormat": payload.reportFormat,
                    "aggregation": payload.aggregation,
                    "locations": payload.locations,
                    "readingTypes": payload.IndividualParameters,
                    "reportGroups": payload.GroupParameters
                }),
                url: 'report-download'
            }),
            responseType: 'arraybuffer'
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function widget_list() {
        var req = {
            url: SETTINGS.BASE_URL + '/widgets/',
            method: 'GET'
        };
        return $http(req);
    }

    function widget_get(widgetid) {
        var req = {
            url: SETTINGS.BASE_URL + '/widgets/' + widgetid + '/',
            method: 'GET'
        };
        return $http(req);
    }

    function widget_save(widget) {

        widget = angular.copy(widget);
        widget.config = angular.toJson(widget.config);
        var req = {
            url: SETTINGS.BASE_URL + '/widgets/',
            method: 'POST',
            data: $.param(widget),
            headers: {
                "Content-Type": "application/x-www-form-urlencoded"
            }
        };

        if (widget.widgetid) {
            req.url = req.url + widget.widgetid + '/';
        }

        return $http(req);

    }

    function widget_delete(widget) {

        var req = {
            url: SETTINGS.BASE_URL + '/widgets/' + widget.widgetid + '/',
            method: 'DELETE',
            data: $.param(widget),
            headers: {
                "Content-Type": "application/x-www-form-urlencoded"
            }
        };

        return $http(req);

    }

    function widget_changeorder(widgets) {

        var req = {
            url: SETTINGS.BASE_URL + '/widgets/changeorder/',
            method: 'POST',
            headers: {
                "Content-Type": "application/x-www-form-urlencoded"
            },
            data: $.param({
                'widgets': JSON.stringify(widgets)
            })
        };

        return $http(req);

    }

    function widget_livetable(widgetid) {

        var req = {
            url: SETTINGS.BASE_URL + '/widgets/livetable/' + widgetid + '/',
            method: 'GET'
        };

        return $http(req);

    }

    function widget_daterule(daterule) {
        var req = {
            url: SETTINGS.BASE_URL + '/widgets/daterule/',
            method: 'GET',
            params: {
                freq: daterule.freq,
                start: daterule.start,
                end: daterule.end,
                reference: daterule.reference
            }
        };
        return $http(req);
    }

    function widget_type() {
        var req = {
            url: SETTINGS.BASE_URL + '/widgets/widgettype/',
            method: 'GET',
        };
        return $http(req);
    }

    /*Network Insights*/
    function network_get_issue_summary(startDate, endDate, billingLocation) {
        var req = {
            url: SETTINGS.BASE_URL + '/issuecountsummary/',
            params: {
                startdate: startDate,
                enddate: endDate
            }
        };
        if (billingLocation) {
            req.params.LocationId = billingLocation;
        }

        return $http(req);
    }

    function network_get_activity_log(issueId, key) {
        var req = {
            url: SETTINGS.BASE_URL + '/insightsActivityLog/',
            params: {
                issueid: issueId,
                key: key
            }
        };

        return $http(req);
    }

    function network_get_issue_data(date, issueId, key, category, billingLocation) {
        var req = {
            url: SETTINGS.BASE_URL + '/issuecountsummary/',
            params: {
                startdate: date,
                issueidslist: issueId,
                key: key
            }
        };
        if (billingLocation) {
            req.params.LocationId = billingLocation;
        }
        if (category) {
            req.params.category = category;
        }

        return $http(req);
    }

    function network_submit_activity_log(issueId, key, action, comment, date) {
        var req = {
            method: "POST",
            url: SETTINGS.BASE_URL + '/insightsActivityLog/',
            params: {
                issueid: issueId,
                key: key,
                action: action,
                comment: comment,
                actiondate: date
            }
        };

        return $http(req);
    }

    function network_get_baseline(issue, category, categoryId) {
        var startDate = issue.StartDate;
        var endDate = issue.EndDate;
        if (category == "Underload") {
            startDate = moment(startDate, "YYYY-MM-DD")
                .subtract(1, "days")
                .format("YYYY-MM-DD");
            endDate = moment(endDate, "YYYY-MM-DD")
                .add(1, "days")
                .format("YYYY-MM-DD");
        }

        var req = {
            url: SETTINGS.BASE_URL + '/custom_baseline_data/',
            params: {
                startdate: startDate,
                enddate: endDate,
                sensorids: issue
                    .SensorsIds
                    .join(),
                readingtypeid: issue.ReadingTypeId,
                categoryid: categoryId
            }
        };

        return $http(req);

    }

    function network_get_actual(issue, category, grain) {
        issue.SensorsIds = issue.SensorsIds ? issue.SensorsIds : issue.SensorIds;
        var startDate = issue.StartDate;
        var endDate = issue.EndDate;
        if (category == "Underload") {
            startDate = moment(startDate, "YYYY-MM-DD")
                .subtract(1, "days")
                .format("YYYY-MM-DD");
            endDate = moment(endDate, "YYYY-MM-DD")
                .add(1, "days")
                .format("YYYY-MM-DD");
        }
        return timeseriesService.get({
            fromdate: startDate,
            todate: endDate,
            sensorid: issue
                .SensorsIds
                .join(),
            readingtypeid: issue.ReadingTypeId,
            grain: grain
        });
    }

    /*Motor Insights*/
    function motor_get_issue_summary(startDate, endDate) {
        var req = {
            url: SETTINGS.BASE_URL + '/motoreventscount/',
            params: {
                startdate: startDate,
                enddate: endDate
            }
        };

        return $http(req);
    }

    function motor_get_event_date() {
        var req = {
            url: SETTINGS.BASE_URL + '/motoreventscount/'
        };

        return $http(req);
    }

    function motor_get_activity_log(issueId, tableName) {
        var req = {
            url: SETTINGS.BASE_URL + '/motoreventscount/',
            params: {
                issueid: issueId,
                tablename: tableName
            }
        };

        return $http(req);
    }

    // function motor_submit_activity_log(issueData, activity) {
    //     var userResponse = [];
    //     for (var response in activity.act) {
    //         if (activity.act[response])
    //             userResponse.push(response);
    //         }
    //     var req = {
    //         url: SETTINGS.BASE_URL + '/motoreventscount/',
    //         method: "POST",
    //         params: {
    //             command: "motoreventscount",
    //             eventstatus: activity.action,
    //             eventcomment: activity.comment,
    //             eventuserresponse: "" + userResponse.join(","),
    //             sensorid: issueData.SensorId,
    //             eventdate: issueData.eventdate,
    //             eventid: issueData.eventid,
    //             eventuseractiondate: moment(activity.actionDate).format("YYYY/MM/DD HH:mm:ss")
    //         }
    //     };

    //     return $http(req);
    // }

    function motor_get_baseline(issue, start, end, otherData) {

        var req = {
            url: SETTINGS.BASE_URL + '/motoreventscount/',
            params: {
                startdate: start,
                enddate: end,
                sensorid: issue
                    .SensorsIds
                    .join(),
                readingtypeid: issue.ReadingTypeId,
                eventid: issue.EventId,
                eventdate: issue.EventDate
            }
        };
        if (otherData) {
            req.params.otherdata = true;
        }

        return $http(req);

    }

    /*Motor Insights New*/
    function motor_events_summary(startDate, endDate) {
        var req = {
            url: SETTINGS.BASE_URL + '/motorevents_summary/',
            params: {
                startdate: startDate,
                enddate: endDate
            }
        };

        return $http(req);
    }

    function motor_events_summary_date() {
        var req = {
            url: SETTINGS.BASE_URL + '/motorevents_summary/'
        };

        return $http(req);
    }

    function motorevents_monitorloading(params) {

        var req = {
            url: SETTINGS.BASE_URL + '/motorevents_monitorloading/',
            params: params
        };

        return $http(req);
    }

    function motorevents_monitorimbalance(params) {

        var req = {
            url: SETTINGS.BASE_URL + '/motorevents_monitorimbalance/',
            params: params
        };

        return $http(req);
    }

    function motor_submit_activity_log(eventid, eventdate, eventstatus, eventcomment, eventuserresponse, eventuseractiondate) {
        var params = {
            eventid: eventid,
            eventdate: eventdate,
            eventstatus: eventstatus,
            eventcomment: eventcomment,
            eventuserresponse: eventuserresponse,
            eventuseractiondate: eventuseractiondate
        };
        var req = {
            url: SETTINGS.BASE_URL + '/motorevents_summary/',
            method: "POST",
            data: $.param(params)
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }


    /*Billing Insights*/
    function billing_get_widgets(locationID) {
        var req = {
            url: SETTINGS.BASE_URL + '/billing_detail_widgets/',
            params: {
                locationid: locationID
            }
        };
        return $http(req);
    }

    function billing_simulator_widgets(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/billing_simulator_widgets/',
            params: params
        };
        return $http(req);
    }

    function billing_get_city_list() {
        var req = {
            url: SETTINGS.BASE_URL + '/solar_pv_city_list/'
        };
        return $http(req);
    }

    function billing_simulate_solar_pv(area, area_unit, avg_monthly_units, avg_monthly_bill, solar_efficiency, avg_cost_per_unit, city) {
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        var req = {
            url: SETTINGS.BASE_URL + '/solar_pv_simulation/',
            method: "POST",
            data: $.param({
                area: area,
                area_unit: area_unit,
                avg_monthly_units: avg_monthly_units,
                avg_monthly_bill: avg_monthly_bill,
                solar_efficiency: solar_efficiency,
                avg_cost_per_unit: avg_cost_per_unit,
                city: city
            })
        };
        return $http(req);
    }

    function billing_get_consumption_details(time_slot, locationid, readingtypeid) {
        var req = {
            url: SETTINGS.BASE_URL + '/get_consumption_details/',
            params: {
                'time_slot': time_slot,
                locationid: locationid,
                readingtypeid: readingtypeid
            }
        };
        return $http(req);
    }

    function billing_get_bill_by_billing_cycle(locationID) {
        var req = {
            url: SETTINGS.BASE_URL + '/get_bill_by_billing_cycle/',
            params: {
                locationid: locationID
            }
        };
        return $http(req);
    }

    function billing_get_pf_details(locationID) {
        var req = {
            url: SETTINGS.BASE_URL + '/get_readingtype_value_for_location/',
            params: {
                readingtypeid: 2006,
                locationid: locationID
            }
        };
        return $http(req);
    }

    /*DMRC APIs*/
    function getLiftDeftails(startDate, endDate){
        var params = {
            startdate: startDate,
            enddate: endDate,
        };
        if (!startDate && !endDate) {
            params.limit = 10;
        }
        var req = {
            url: SETTINGS.BASE_URL + '/error_details/',
            method: "POST",
            data: $.param(params)
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function getLiftErrorStats(startDate, endDate){
        var params = {
            startdate: moment(startDate).format("YYYY-MM-DD"),
            enddate:  moment(endDate).format("YYYY-MM-DD")
        };
        var req = {
            url: SETTINGS.BASE_URL + '/error_statistics/',
            headers: {
                'Content-Type': "application/x-www-form-urlencoded"
            },
            method: "POST",
            data: $.param(params)
        };
        return $http(req);
    }

    function getLiftNotifications(startDate, endDate, isNotification){
        var params = {
            startdate: startDate,
            enddate: endDate,
            is_notification: isNotification
        };
        if (!startDate && !endDate) {
            params.limit = 10;
        }
        var req = {
            url: SETTINGS.BASE_URL + '/error_details/',
            method: "POST",
            data : $.param(params)
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        delete req.params;
        return $http(req);
    }

    function get_sldfordmrc(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/get_sldfordmrc/',
            params: params
        };

        return $http(req);
    }

    function gis_widget_dmrc(startDate, endDate, locationid) {
        var startdate = moment(startDate).format("YYYY-MM-DD");
        var enddate = moment(endDate).format("YYYY-MM-DD");
        var req = {
            url: SETTINGS.BASE_URL + '/get_gislocation_summary/',
            params: {
                locationid: locationid,
                startdate: startdate,
                enddate: enddate
            }
        };

        return $http(req);
    }

    function get_location_with_geo() {

        var req = {
            url: SETTINGS.BASE_URL + '/get_location_with_geo/',
            method: 'GET'
        };

        return $http(req);
    }

    function gis_widget(params) {
        var daterange = setFromAndToDate(params.startdate,params.enddate);
        var req = {
            url: SETTINGS.BASE_URL + '/get_gislocation_summary/',
            method: 'GET',
            params: {
                enddate: daterange.todate,
                startdate: daterange.fromdate,
                readingtypeid: params.readingtypeid,
                grain: params.grain,
                locationid: params.locationid
            }
        };

        return $http(req);
    }

    /*Transformer Insights API*/
    function transformer_get_recent_event_date() {
        return transformer_get_issue_summary();
    }

    function transformer_get_issue_summary(startdate, enddate) {
        var params = {};
        if (startdate || enddate) {
            params = {
                startdate: startdate,
                enddate: enddate
            };
        }
        var req = {
            url: SETTINGS.BASE_URL + '/txeventscount/',
            params: params
        };
        return $http(req);
    }

    function transformer_get_details(type, issue, startdate, enddate, otherdata, side) {
        // eventdate, txid, readingtypeid, eid, startdate: start, enddate: end, sensorid:
        // issue.SensorsIds.join(), readingtypeid: issue.ReadingTypeId, eventid:
        // issue.EventId, eventdate: issue.EventDate
        // console.log(issue);
        var params = {
            startdate: startdate,
            enddate: enddate,
            eventdate: issue.EventDate,
            txid: issue.txId,
            readingtypeid: issue.ReadingTypeId,
            eid: issue.evtId
        };
        if (type)
            params.widget = type;
        if (otherdata) {
            params.otherdata = otherdata;
            params.side = side;
        }
        var req = {
            url: SETTINGS.BASE_URL + '/txeventdetails/',
            params: params
        };
        return $http(req);
    }

    function transformer_submit_activity_log(eid, eventdate, txid, eventstatus, eventcomment, eventuserresponse, eventuseractiondate) {
        var params = {
            eid: eid,
            eventdate: eventdate,
            txid: txid,
            eventstatus: eventstatus,
            eventcomment: eventcomment,
            eventuserresponse: eventuserresponse,
            eventuseractiondate: eventuseractiondate
        };
        var req = {
            url: SETTINGS.BASE_URL + '/txeventsummary/',
            method: "POST",
            data: $.param(params)
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function transformer_get_action_items() {
        var req = {
            url: SETTINGS.BASE_URL + '/txactionList/'
        };
        return $http(req);
    }

    /* Transformer Insights New */
    function transformer_get_event_date() {
        return transformer_get_summary();
    }

    function transformer_get_summary(startdate, enddate) {
        var params = {};
        if (startdate || enddate) {
            params = {
                startdate: startdate,
                enddate: enddate
            };
        }
        var req = {
            url: SETTINGS.BASE_URL + '/txeventscountnew/',
            params: params
        };
        // console.log(req);
        return $http(req);
    }

    function transformer_get_graph_details(type, issue, otherdata, side) {
        var params = {
            startdate: issue.startdate,
            enddate: issue.enddate,
            eventdate: issue.eventdate,
            txid: issue.txid,
            readingtypeid: issue.readingtypeid,
            eid: issue.eid
        };
        if (type)
            params.widget = type;
        if (otherdata) {
            params.otherdata = otherdata;
            params.side = side;
        }
        var req = {
            url: SETTINGS.BASE_URL + '/txeventdetails/',
            params: params
        };
        return $http(req);
    }

    function transformer_get_monitoring_graph(type, txid, startdate, enddate, otherdata, side) {
        var params = {
            startdate: startdate,
            enddate: enddate,
            txid: txid
        };
        if (type)
            params.widget = type;
        if (otherdata) {
            params.otherdata = otherdata;
            params.side = side;
        }
        var req = {
            url: SETTINGS.BASE_URL + '/txeventdetails/',
            params: params
        };
        return $http(req);
    }

    function tx_insights_summary() {
        var req = {
            url: SETTINGS.BASE_URL + '/tx_insights/assets/',
            method: 'GET'
        };
        return $http(req);
    }

    function tx_insights_activity_log(tx_id) {
        var req = {
            url: SETTINGS.BASE_URL + '/tx_insights/activity_log/',
            method: 'GET',
            params: {
                tx_id: tx_id
            }
        };
        return $http(req);
    }

    function get_sensor_list() {
        var req = {
            url: SETTINGS.BASE_URL + '/sensor_list/',
            method: 'GET'
        };
        return $http(req);
    }

    function get_appliance_type() {
        var req = {
            url: SETTINGS.BASE_URL + '/get_appliance_type/',
            method: 'GET'
        };
        return $http(req);
    }

    function download_template() {
        var req = {
            url: SETTINGS.BASE_URL + '/bulk_sensor_template/',
            method: 'GET',
            responseType: 'arraybuffer',
            /*headers: {
                           'Content-type': 'application/json',
                           'Accept': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                            'Accept' : 'application/vnd.ms-excel'
                        }*/

        };
        return $http(req);

    }

    function get_meter_list() {
        var req = {
            url: SETTINGS.BASE_URL + '/meter_list/',
            method: 'GET'
        };
        return $http(req);
    }

    function get_reading_type_list() {
        var req = {
            url: SETTINGS.BASE_URL + '/get_reading_type_list/',
            method: 'GET'
        };
        return $http(req);
    }



    function create_sensor(sensor) {
        var req = {
            url: SETTINGS.BASE_URL + '/sensor_list/',
            method: 'POST',
            data: sensor
        };
        return $http(req);
    }

    function update_sensor(sensor) {
        var req = {
            url: SETTINGS.BASE_URL + '/sensor_details/' + sensor.sensorid + '/',
            method: 'PUT',
            data: sensor
        };
        return $http(req);
    }

    function create_or_update_motor_meta(motorMetaDetails) {
        var req = {
            url: SETTINGS.BASE_URL + '/motor_meta/' + motorMetaDetails.sensorid + '/',
            method: 'PUT',
            data: motorMetaDetails
        };
        return $http(req);
    }

    function create_or_update_tx_meta(txMetaDetails) {
        var req = {
            url: SETTINGS.BASE_URL + '/tx_meta/' + txMetaDetails.htsensorid + '/',
            method: 'PUT',
            data: txMetaDetails
        };
        return $http(req);
    }

    function get_motor_meta(sensorid) {
        var req = {
            url: SETTINGS.BASE_URL + '/motor_meta/' + sensorid + '/',
            method: 'GET',
        };
        return $http(req);
    }

    function get_tx_meta(sensorid) {
        var req = {
            url: SETTINGS.BASE_URL + '/tx_meta/' + sensorid + '/',
            method: 'GET',
        };
        return $http(req);
    }
    function send_command(){
        var req = {
            url: SETTINGS.BASE_URL + '/activate_sensors/',
            method: 'POST',
        };
        return $http(req);
    }


    function generate_excel_for_manual_sensor(generateObj) {
        var req = {
            url: SETTINGS.BASE_URL + '/generate_excel_for_manual_sensor/',
            method: 'POST',
            data: generateObj,
            responseType: 'arraybuffer',
            headers: {
                'Content-Type': 'application/json; charset=utf-8',
            }
        };
        return $http(req);
    }

    function upload_excel_for_manual_sensor(data) {
        return $http({
            method: 'POST',
            url: SETTINGS.BASE_URL + '/upload_excel_for_manual_sensor/',
            headers: {
                'Content-Type': undefined
            },
            data: data,
        });

    }

    function cycle_get_distribution(params) {

        var fromdate = moment(params.fromdate)
            .set({ second: 0, millisecond: 0 })
            .format(reading_date_format);
        var todate = moment(params.todate)
            .set({ second: 0, millisecond: 0 })
            .format(reading_date_format);

        if (!params.grain) {
            params.grain = getDefaultGrain(fromdate, todate);
        }

        var req = {
            url: SETTINGS.BASE_URL + '/get_cycle_distribution/',
            method: 'GET',
            params: {
                fromdate: fromdate,
                todate: todate,
                grain: params.grain,
                readingtypeid: params.readingtypeid
            }
        };

        if (params.sensorid) {
            req.params.sensorid = params.sensorid;
        } else if (params.locationid) {
            req.params.locationid = params.locationid;
        }

        if (params.sensortypeid) {
            req.params.sensortypeid = params.sensortypeid;
        }
        return $http(req);
    }

    // Activity Log For Tx and Motor
    function get_insights_activity_log(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/get_insights_activity_log/',
            params: params
        };

        return $http(req);
    }

    function insights_activity_type() {
        var req = {
            url: SETTINGS.BASE_URL + '/insights_activity_type/'
        };

        return $http(req);
    }

    function add_manual_insights_log(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/add_manual_insights_log/',
            method: "POST",
            data: $.param(params)
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);

    }

    function activityLog_download(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/download_email_insights_activity_log/',
            params: params,
            responseType: 'arraybuffer',
        };

        return $http(req);
    }

    function activityLog_email(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/download_email_insights_activity_log/',
            params: params
        };

        return $http(req);
    }

    //Report New
    function report_list() {
        var req = {
            url: SETTINGS.BASE_URL + '/reporting/'
        };

        return $http(req);
    }

    function report_config(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/reporting/',
            method: "POST",
            data: $.param(params),
            responseType: 'arraybuffer'
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function report_config_download(params) {
        var allow_futuredate = true;
        var daterange = setFromAndToDate(params.dateRange.startDate, params.dateRange.endDate, null, allow_futuredate);
        var url = 'http://reporting.smartsen.se:8080/reporting';
        var req = {
            url: SETTINGS.BASE_URL + '/download_report/',
            method: "GET",
            params: {
                spreadsheet_id: params.SpreadSheetId,
                fromdate: daterange.fromdate,
                todate: daterange.todate,
                report_format: params.ReportFormat
            },
            responseType: 'arraybuffer',
            headers: {
                'Content-type': 'application/json'
            }
        };
        return $http(req);
    }

    function report_delete(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/reporting/',
            method: "DELETE",
            data: $.param(params),
            headers: {
                "Content-Type": "application/x-www-form-urlencoded"
            }
        };
        return $http(req);
    }

    //Eaton Utilization Dashboard
    function eaton_utilization_categories() {
        var req = {
            url: SETTINGS.BASE_URL + '/custom/eaton_utilization_categories/'
        };

        return $http(req);
    }

    function eaton_utilization_timeseries(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/custom/eaton_utilization_timeseries/',
            params: params
        };

        return $http(req);
    }

    function chiller_list(sensorids) {
        var req = {
            url: SETTINGS.BASE_URL + '/chiller_list/',
            method: "POST",
            data: {
                sensorids: sensorids
            }
        };
        $http.defaults.headers.post["Content-Type"] = "application/json;charset=UTF-8";
        return $http(req);
    }

    function chiller_uiconfigs() {
        var req = {
            url: SETTINGS.BASE_URL + '/chiller_uiconfigs/',
            method: "GET"
        };
        return $http(req);
    }

    //Tree Builder
    function create_tree(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/list_member_tree/',
            method: "POST",
            data: $.param(params)
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);
    }

    function retrieve_tree() {
        var req = {
            url: SETTINGS.BASE_URL + '/list_member_tree/'
        };
        return $http(req);
    }

    function create_node(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/member_tree_mapping/',
            method: "POST",
            data: $.param(params)
        };
        $http.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";
        return $http(req);

    }

    function get_tree_nodes(treeid) {
        var req = {
            url: SETTINGS.BASE_URL + '/get_tree_mapping/' + treeid + '/'
        };
        return $http(req);
    }

    function edit_node(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/member_tree_mapping/' + params.id + '/',
            method: "PUT",
            data: params
        };
        return $http(req);

    }

    function delete_node(id) {
        var req = {
            url: SETTINGS.BASE_URL + '/member_tree_mapping/' + id + '/',
            method: "DELETE"
        };
        return $http(req);
    }

    function get_single_node(id) {
        var req = {
            url: SETTINGS.BASE_URL + '/member_tree_mapping/' + id + '/',
            method: "GET"
        };
        return $http(req);
    }

    //Image Upload
    function media_handler(myFormData) {
        var req = {
            url: SETTINGS.BASE_URL + '/media_handler/',
            method: "POST",
            data: myFormData,
            transformRequest: angular.identity,
            headers: {
                'Content-Type': undefined
            }
        };

        return $http(req);
    }

    function media_handler_img(params) {
        var req = {
            url: SETTINGS.BASE_URL + '/media_handler/',
            method: "GET",
            params: params
        };

        return $http(req);
    }

    function jsondata(slug) {
        var req = {
            url: SETTINGS.BASE_URL + '/jsondata/',
            method: "GET",
            params: {
                "slug":slug
            }
        };

        return $http(req);
    }

    ////////////
    return service;

}

smartsenseApp.factory('config', ['local','SETTINGS', function(local, SETTINGS) {
    var _this = this;
    _this.localData = local.data;
    if (!_this.localData) {
        _this.localData = {
            dashboardDateRange: {
                startDate: moment().startOf('day'),
                endDate: moment()
            }
        };
    } else if (!_this.localData.dashboardDateRange) {
        _this.localData.dashboardDateRange = {
            startDate: moment().startOf('day'),
            endDate: moment()
        };
    }
    this.settings = {
        APIUrl: SETTINGS.BASE_URL+'/', // URL to all API Calls
        authTokenPollTime: SETTINGS.authTokenPollTime, //Token validate poll interval in milliseconds
        dashboardRefreshTime: SETTINGS.dashboardRefreshTime,
        //List of items to use to prepare a data repo and store locally
        preloadItems: [
      ]
    };
    return {
        get: function() {
            return _this;
        }
    };
}]);

smartsenseApp.factory('local', ['$rootScope', 'Session', function($rootScope, Session) {

    var _this = this;
    // Load all the data in local.data when service is injected first
    _this.data = Session.getAll();

    _this.readingtypesByMessageVerions = function(messageversions) {
        /**
        messageversions = {'M21':occurence_count,'M23':occurence_count,...}
        */
        var readingtypes = [];
        var version_readingtype_mapping = _this.data.version_readingtype_mapping;
        var readingtypeids = {};
        var keys = Object.keys(messageversions);
        for (var i=0, len=keys.length; i<len; i++) {
            if(messageversions[keys[i]]>0) {
                message_version = keys[i];
                for(var j=0; j<version_readingtype_mapping[message_version].length; j++) {
                    var readingtypeid = version_readingtype_mapping[message_version][j];
                    if(!readingtypeids.hasOwnProperty(readingtypeid)) {
                        readingtypes.push(_this.data.readingtypes[readingtypeid]);
                    }
                    readingtypeids[readingtypeid] = true;
                }
            }
        }
        return readingtypes;
    }

    $rootScope.$on('dataRefrehed', function() {
        _this.data = Session.getAll();
    });

    // On login success, load all data in local.data
    $rootScope.$on("loginSuccess", function() {
        _this.data = Session.getAll();
    });

    // Wipe out all the data in local.data on logout event
    $rootScope.$on("logoutSuccess", function() {
        _this.data = {};
    });

    return _this;

}]);

/*To keep track of all requests made in the app and are pending*/
smartsenseApp.service('pendingRequests', function() {
    var pending = [];
    this.get = function() {
        return pending;
    };
    this.add = function(request) {
        pending.push(request);
    };
    this.remove = function(request) {
        pending = pending.filter(function(p) {
            return p.url !== request;
        });
    };
    this.cancelAll = function() {
        angular.forEach(pending, function(p) {
            p.canceled = true;
            p.canceller.resolve();
        });
        pending.length = 0;
    };
});

smartsenseApp.factory('data', [ function() {
        return {};
    }
]);
smartsenseApp.factory('timeseriesService', timeseriesService);

timeseriesService.$inject = ['$http', 'grainService', 'SETTINGS'];

function timeseriesService($http, grainService, SETTINGS) {

    var maximumParameter = 8;
    var service = {
        get: get,
        getSensorTimeseries: get,
        maximumParameter: maximumParameter
    };

    return service;

    ////////////

    function get(parameters, options) {


        /* If fromdate is not defined set it to one month back */
        if (typeof parameters.fromdate == 'undefined') {
            parameters.fromdate = moment().subtract(1, "month").format('YYYY-MM-DD HH:mm:ss');
        }

        /* If todate is not defined set it to today */
        if (typeof parameters.todate == 'undefined') {
            parameters.todate = moment().format('YYYY-MM-DD HH:mm:ss');
        }

        if (typeof parameters.grain == 'undefined') {
            parameters.grain = grainService.getFirst(moment(parameters.fromdate), moment(parameters.todate));
        }

        var params = {
            fromdate: parameters.fromdate,
            todate: parameters.todate,
            readingtypeid: parameters.readingtypeid,
            grain: parameters.grain.value
        };

        if (typeof parameters.sensorid != 'undefined') {
            params.sensorid = parameters.sensorid;
        } else if (typeof parameters.locationid != 'undefined' && utils.isNumeric(parameters.locationid)) {
            params.locationid = parameters.locationid;
        }

        if (typeof parameters.sensortypeid != 'undefined') {
            params.sensortypeid = parameters.sensortypeid;
        }

        var defaultOptions = {
            url: SETTINGS.BASE_URL + '/timeseries/',
            method: 'GET',
            params: params
        };

        var req = utils.MergeRecursive(defaultOptions, options)
        return $http(req);

    }
}

smartsenseApp.factory('grainService', grainService);

grainService.$inject = [];

function grainService() {

    var grainList = [{
        label: '1 min',
        value: 1
    }, {
        label: '15 min',
        value: 15
    }, {
        label: '30 min',
        value: 30
    }, {
        label: '60 min',
        value: 60
    }, {
        label: '1 day',
        value: 1440
    }];


    var service = {
        get: get,
        getFirst: getFirst,
        getLast: getLast
    };

    return service;

    ////////////

    function get(startDate, endDate) {


        if (!startDate || !endDate) {
            return grainList;
        }

        var result = [];

        var difference = moment.duration(endDate.diff(startDate));
        difference = Math.round(difference.asMinutes());

        if (difference >= 0 && difference <= 1440) {

            result = [{
                label: '1 min',
                value: 1
            }, {
                label: '15 min',
                value: 15
            }, {
                label: '30 min',
                value: 30
            }, {
                label: '60 min',
                value: 60
            }];

        } else if (difference > 1440 && difference <= 2 * 1440) {

            result = grainList;

        } else if (difference > 2 * 1440 && difference <= 1440 * 7) {

            result = [{
                label: '30 min',
                value: 30
            }, {
                label: '60 min',
                value: 60
            }, {
                label: '1 day',
                value: 1440
            }];

        } else if (difference > 1440 * 7 && difference <= 1440 * 28) {

            result = [{
                label: '60 min',
                value: 60
            }, {
                label: '1 day',
                value: 1440
            }];

        } else {

            result = [{
                label: '1 day',
                value: 1440
            }];

        }

        return result;

    }

    function getFirst(startDate, endDate) {
        var grainList = get(startDate, endDate);
        return grainList[0];
    }

    function getLast(startDate, endDate) {
        var grainList = get(startDate, endDate);
        return grainList[grainList.length - 1];
    }



}

smartsenseApp.factory('readingTypeService', readingTypeService);

readingTypeService.$inject = ['$http', 'SETTINGS'];

function readingTypeService($http, SETTINGS) {

    var service = {
        getAll: getAll,
        getBySensorId: getBySensorId,
        getByLocationId: getByLocationId
    };

    return service;

    function getAll() {

        return $http.get(SETTINGS.BASE_URL + '/reading_type/');

    }

    function getBySensorId(sensorId) {

        var req = {
            url: SETTINGS.BASE_URL + '/reading_type/',
            method: 'GET',
            params: {
                'sensorid': sensorId
            }
        };
        return $http(req);
    }

    function getByLocationId(locationId) {

        var req = {
            url: SETTINGS.BASE_URL + '/reading_type/',
            method: 'GET',
            params: {
                'locationid': locationId
            }
        };
        return $http(req);
    }
}

var colorSchemes = {
    base: ['#dd7722', '#2288cc', '#dd3322', '#22aa99', '#bb4488', '#ddaa00', '#6655cc', '#99aa00'],
    pastel: ['#E6645C', '#55A9DC', '#886DB3', '#6CC080'],
    steel: ['#484D59', '#aaaaaa', '#4295F3'],
    future: ['#E6645C', '#55A9DC', '#886DB3', '#6CC080'],
    mark3: ['#058DC7', '#DDDF00', '#ED561B', '#50B432', '#24CBE5', '#64E572',
        '#FF9655', '#FFF263', '#6AF9C4'
    ],
    mark1: ["#f45b5b", "#8085e9", "#8d4654", "#7798BF", "#aaeeee", "#ff0066", "#eeaaee",
        "#55BF3B", "#DF5353", "#7798BF", "#aaeeee"
    ]
};

// Apply the theme
Highcharts.theme = {
    global: {
        useUTC: false,
    },
    colors: colorSchemes.base,
    chart: {
        backgroundColor: null,
        style: {
            fontFamily: "Lato"
        },
        defaultSeriesType: 'area',
        alignTicks: false
    },
    title: {
        text: ''
    },
    yAxis: {
        gridLineWidth: 0.5,
        gridLineDashStyle: 'longdash'
    },
    navigation: {
        buttonOptions: {
            verticalAlign: 'bottom',
            y: 7,
            x: 5,
            theme: {
                r: 10,
            }
        }
    },
    exporting: {
        enabled: true,
        filename: 'smartsense-graph'
    },
    credits: {
        enabled: false
    },
    tooltip: {
        valueDecimals: 2,
        shared: true
    },
    plotOptions: {
        series: {
            gapSize: 0,
            gapUnit: 'value',
            turboThreshold: 16416000,
            borderRadius: 0,
            borderWidth: 0,
            fillOpacity: 0.1,
            marker: {
                enabled: true,
                radius: 2
            }
        }
    }
};

// Add custom date format support
// @reference http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/global/dateformats/
Highcharts.dateFormats = {
    // %u will return day of the week (1-7)
    u: function(timestamp) {
        var date = new Date(timestamp);
        return date.getDay() + 1;
    }
}


// Apply the theme
Highcharts.setOptions(Highcharts.theme);

smartsenseApp.factory('highchartService', highchartService);

highchartService.$inject = [];

function highchartService() {

    var service = {
        GeneralConfig: GeneralConfig,
        OnOffConfig: OnOffConfig,
        TimevsTimeConfig: TimevsTimeConfig,
        XvsYConfig: XvsYConfig,
        gaugeConfig: gaugeConfig,
        heatmapConfig: heatmapConfig,
        pieChartConfig: pieChartConfig,
        // OEE Specific graphs
        OEETimeDistributionConfig: OEETimeDistributionConfig,
        OEEMetricsConfig: OEEMetricsConfig,
        // Create yAxis per ReadingType
        setYAxisesByReadings: setYAxisesByReadings,
        solidgaugeConfig: solidgaugeConfig,
        speedometerConfig: speedometerConfig
    };

    return service;

    ////////////

    function GeneralConfig() {
        var config = {
            options: {
                chart: {
                    zoomType: 'x',
                    defaultSeriesType: 'area'
                },
                xAxis: {
                    type: 'datetime'
                },
                yAxis: []
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        }
        return config;
    }

    function OEEMetricsConfig() {
        var config = {
            options: {
                chart: {
                    zoomType: 'x',
                    defaultSeriesType: 'area'
                },
                xAxis: {
                    type: 'datetime'
                },
                yAxis: {
                    title: {
                        text: 'Percentage'
                    },
                    min: 0,
                    max: 100
                },
                plotOptions: {
                    line: {
                        marker: {
                            enabled: true
                        },
                        dataLabels: {
                            enabled: true,
                            format: '{point.y:.0f} %',
                        }
                    },
                    bar: {
                        dataLabels: {
                            enabled: true,
                            format: '{point.y:.0f} %'
                        }
                    }
                },
                tooltip: {
                    shared: true,
                    headerFormat: '{point.key}<br/>',
                    pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:0.0f}%</b><br/>'
                }
            },
            series: [],
            title: {
                text: 'OEE Metrics'
            },
            loading: false
        }
        return config;

    }

    function OnOffConfig() {
        var config = {
            options: {
                chart: {
                    type: 'area',
                    zoomType: 'x'
                },
                xAxis: {
                    type: 'datetime'
                },
                yAxis: {
                    title: {
                        text: 'No of On Assets'
                    },
                    allowDecimals: false
                },
                tooltip: {
                    pointFormatter: function() {
                        var name = this.series.name || "";
                        var value = '';
                        if (this.y > 0 && this.y < 1) {
                            value = this.y.toFixed(2) * 100 + '% Up'
                        } else if (this.y == 1) {
                            value = 'On';
                        } else {
                            value = 'Off';
                        }
                        var color = this.color;
                        return '<span style="color:' + color + '">\u25CF</span> ' + name + ': <b>' + value + '</b> <br/>';
                    },
                    shared: true
                },
                plotOptions: {
                    series: {
                        stacking: 'normal',
                        marker: {
                            enabled: false
                        },
                        step: 'center'
                    }
                },
                legend: {
                    labelFormatter: function() {
                        return this.name + ' - ' + this.options.suffix;
                    }
                }
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        }
        return config
    }

    // graph of single Parameter's value against multiple time
    function TimevsTimeConfig() {
        var config = {
            options: {
                chart: {
                    height: 400,
                    type: 'scatter',
                    zoomType: 'xy'
                },
                plotOptions: {
                    series: {
                        // Maximus threshold point = 190 day's 1 minute data = 1440*60*190
                        turboThreshold: 16416000
                    },
                    scatter: {
                        marker: {
                            radius: 2
                        }
                    }
                },
                tooltip: {
                    shared: true,
                    headerFormat: '{point.key}<br/>',
                    pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:0.2f}</b><br/>'
                },
                xAxis: {
                    type: 'datetime',
                    startOnTick: false,
                    endOnTick: false
                }
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        }
        return config;
    }

    // graph of comparing two parameter's value on time intersection
    function XvsYConfig() {
        var config = {
            options: {
                chart: {
                    height: 400,
                    type: 'scatter',
                    zoomType: 'xy'
                },
                plotOptions: {
                    series: {
                        // Maximus threshold point = 190 day's 1 minute data = 1440*60*190
                        turboThreshold: 16416000
                    },
                    scatter: {
                        marker: {
                            radius: 2
                        }
                    }
                },
                tooltip: {
                    headerFormat: '<small><b>{series.name}</b></small><br>',
                    pointFormat: '{series.xAxis.options.title.text}: <b>{point.x:0.2f}</b><br/>{series.yAxis.options.title.text}: <b>{point.y:0.2f}</b>'
                }
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        }
        return config;
    }

    function gaugeConfig() {
        var config = {
            options: {
                chart: {
                    type: 'solidgauge',
                    height: 200
                },
                title: {
                    text: ''
                },
                pane: {
                    size: '100%',
                    startAngle: -90,
                    endAngle: 90,
                    background: {
                        backgroundColor: (Highcharts.theme && Highcharts.theme.background2) || '#EEE',
                        innerRadius: '60%',
                        outerRadius: '100%',
                        shape: 'arc'
                    }
                },
                tooltip: {
                    enabled: false,
                    valueSuffix: ' %'
                },
                exporting: {
                    enabled: false
                },
                // the value axis
                yAxis: {
                    stops: [
                        [0.1, '#DF5353'],
                        [0.5, '#DDDF0D'],
                        [0.9, '#55BF3B']
                    ],
                    lineWidth: 0,
                    minorTickInterval: null,
                    tickAmount: 2,
                    title: {
                        y: -70
                    },
                    min: 0,
                    max: 100,
                    tickPositions: [90],
                    tickColor: '#FF0000',
                    tickWidth: 2,
                    labels: {
                        formatter: function() {
                            return 'Target: ' +
                                this.value + '%';
                        }
                    }
                },
                plotOptions: {
                    solidgauge: {
                        dataLabels: {
                            borderWidth: 0,
                            useHTML: true,
                            format: '<div style="text-align:center"><span style="font-size:18px;color:' +
                                ((Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black') + '">{y:.0f} %</span><br/>' +
                                '</div>'
                        }
                    }
                },
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        }
        return config;
    }

    function solidgaugeConfig() {
        var config = {
            options: {
                chart: {
                    type: 'solidgauge',
                    height: 210
                },
                pane: {
                    center: ['50%', '60%'],
                    size: '100%',
                    startAngle: -90,
                    endAngle: 90,
                    background: {
                        backgroundColor: (Highcharts.theme && Highcharts.theme.background2) || '#EEE',
                        innerRadius: '60%',
                        outerRadius: '100%',
                        shape: 'arc'
                    }
                },
                yAxis: {
                    stops: [
                        [0.1, '#55BF3B'],
                        [0.5, '#DDDF0D'],
                        [0.9, '#DF5353']
                    ],
                    lineWidth: 0,
                    minorTickInterval: null,
                    minColor: '#55BF3B',
                    maxColor: '#DF5353',
                    lineWidth: 0,
                    title: {
                        y: -70
                    },
                    labels: {
                        y: 16,
                        style : {
                            color: '#000000',
                            fontWeight: '700'
                        }
                    },
                    min: '',
                    max: '',
                    tickPositions: [],
                    tickWidth: 2,
                    tickAmount: 2
                },
                plotOptions: {
                    solidgauge: {
                        dataLabels: {
                            y: 15,
                            borderWidth: 0,
                            useHTML: true
                        }
                    }
                },
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        }
        return config;
    }

    function speedometerConfig(){
        var config = {
            options: {
                chart: {
                    type: 'gauge',
                    height: 210
                },
                pane: {
                    startAngle: -150,
                    endAngle: 150,
                    center: ['50%', '50%'],
                    size: '100%',
                },
                yAxis: {
                    min: '',
                    max: '',
                    minorTickInterval: 'auto',
                    minorTickWidth: 1,
                    minorTickLength: 10,
                    minorTickPosition: 'inside',
                    minorTickColor: '#666',
                    tickPixelInterval: 30,
                    tickWidth: 2,
                    tickPosition: 'inside',
                    tickLength: 10,
                    tickColor: '#666',
                    labels: {
                        step: 2,
                        rotation: 'auto'
                    },
                    title: {
                        text: '',
                        y: 16,
                        style: {
                            fontWeight: 'bold',
                            fontSize: '16px',
                            color: '#000'
                        }
                    },
                    plotBands: []
                },
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        }
        return config;
    }

    function heatmapConfig() {
        var config = {
            options: {
                chart: {
                    type: 'heatmap',
                    zoomType: 'x',
                    inverted: true
                },
                // boost: {
                //     useGPUTranslations: true
                // },
                xAxis: {
                    type: 'datetime',
                    lineColor: 'transparent'
                },
                yAxis: {
                    title: {
                        text: null
                    },
                    // labels: {
                    //     formatter: function() {
                    //         var minutes = (this.value) * 15;
                    //         var realmin = minutes % 60;
                    //         var hours = Math.floor(minutes / 60);
                    //         if (hours < 10) {
                    //             hours = "0" + hours;
                    //         }
                    //         if (realmin < 10) {
                    //             realmin = "0" + realmin;
                    //         }
                    //         return hours + ':' + realmin;
                    //     }
                    // },
                    // minPadding: 0,
                    // maxPadding: 0,
                    // startOnTick: false,
                    // endOnTick: false,
                    // tickWidth: 1,
                    // min: 0,
                    // max: 95
                },
                colorAxis: {
                    stops: [
                        [0, '#1a9850'],
                        [0.5, '#fffbbc'],
                        [0.9, '#f6200b'],
                        [1, '#c4463a']
                    ],
                    startOnTick: false,
                    endOnTick: false
                },
            },
            series: [],
            loading: false
        }

        return config;
    }

    function OEETimeDistributionConfig() {
        var config = {
            options: {
                chart: {
                    zoomType: 'x',
                    type: 'column'
                },
                xAxis: {
                    categories: [''],
                    title: {
                        text: null
                    },
                    labels: {
                        enabled: false,
                        y: 20,
                        rotation: -45,
                        align: 'right'
                    }
                },
                yAxis: {
                    title: {
                        text: 'Minutes'
                    },

                },
                tooltip: {
                    shared: false,
                    headerFormat: '',
                    pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:0.0f} minutes</b><br/>'
                },
                plotOptions: {
                    series: {
                        dataLabels: {
                            enabled: true,
                            align: 'center',
                            format: '{point.y:.0f} minutes'
                        }
                    }
                }
            },
            series: [],
            title: {
                text: 'Time Distribution'
            },
            loading: false
        }
        return config;
    }

    // This function will return yAxises list
    function setYAxisesByReadings(readingtypes) {
        var yAxises = [];
        var yAxisMapping = {};
        var yAxisCount = 0;
        readingtypes.forEach(function(readingtype) {
            if (typeof yAxisMapping[readingtype.readingtypeid] == 'undefined') {
                var yAxis = {
                    isX: false,
                    title: {
                        text: readingtype.readingtypename
                    },
                    opposite: yAxisCount % 2 == 0 ? false : true
                }
                yAxises.push(yAxis);
                yAxisMapping[readingtype.readingtypeid] = yAxisCount;
                yAxisCount++;
            }
        });
        return { yAxises: yAxises, yAxisMapping: yAxisMapping };
    }

    function pieChartConfig() {
        var config = {
            options: {
                chart: {
                    type: 'pie'
                },
                title: {
                    text: ''
                },
                plotOptions: {
                    series: {
                        dataLabels: {
                            enabled: false,
                            format: '{point.name}: {point.y:.1f}%'
                        }
                    }
                },
                exporting:{
                    enabled:false
                },
                tooltip: {
                    headerFormat: '{point.key}<br/>',
                    pointFormat: '<span style="color:{point.color}">\u25CF</span><b> {point.y:0.2f}% </b>of total<br/>'
                }
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        }
        return config;
    }

}
smartsenseApp.controller("PageController", [function() {
}]);

smartsenseApp.controller("HomeController", ['$rootScope', '$scope', '$uibModal', 'local', 'authService',function($rootScope, $scope, $uibModal, local, authService) {

    $scope.localData = local.data;

    authService.refreshData();

    $rootScope.isPageSideBarClosed = false;
    $rootScope.isQuickSideBarClosed = false;

    $rootScope.toggleSideBar = function() {
        $rootScope.isPageSideBarClosed = !$rootScope.isPageSideBarClosed;
    };

    $rootScope.toggleQuickSideBar = function() {
        $rootScope.isQuickSideBarClosed = !$rootScope.isQuickSideBarClosed;
    };

    $scope.backToTop = function(){
        $('html, body').animate({
            scrollTop: 0
        }, 100);
    }

    $scope.toggleAnalyse = function() {
        var modalInstance = $uibModal.open({
            ariaLabelledBy: 'modal-title',
            ariaDescribedBy: 'modal-body',
            templateUrl: 'components/analyse/analyseModalView.html',
            controller: 'AnalyseController',
            windowClass:'modal-analyse'
        });
    }

    $rootScope.termsModal = function() {
        $rootScope.modalInstance = $uibModal.open({
            ariaLabelledBy: 'modal-title',
            ariaDescribedBy: 'modal-body',
            templateUrl: 'components/terms/termsModalView.html',
            controller: 'TermsModalController',
            windowClass:'modal-terms',
            backdrop: true,
            size: 'lg'
        });
    }

    if($scope.localData.member.isTcAccepted != true) {
        $rootScope.termsModal();
    }

    

}]);
smartsenseApp.controller("BreadcrumbsController", ['$scope', '$translate', '$state', '$stateParams','local',function($scope, $translate, $state, $stateParams, local) {

    var _this = this;
    _this.localData = local.data;
    $scope.localData = local.data;
    $scope.locations = $.map($scope.localData.locations, function(value, index) {
        if(index>0) {
            return [value];
        }
    });

    var selectedLoc = $stateParams["locID"];
    $scope.selectedLocation = selectedLoc;

    $scope.$on("locationSelected", function(evt, value) {
        locID = 'overview';
        if (value && value != $stateParams["locID"]) {
            locID = value.locationid;
        }
        $state.go($state.current.name, {
            locID: locID
        });
    });

    // $scope.model = {};
    // var locationid = utils.isInt($stateParams.locID)?$stateParams.locID:0;
    // $scope.model = {
    //     '$selected':$scope.localData.locations[locationid]
    // }
    // $scope.$watch("model.$selected.locationid",function(newVal,oldVal) {
    //     if(newVal!=oldVal) {
    //         var locID = newVal || 'overview';
    //         $state.go($state.current.name,{
    //             locID:locID
    //         }); 
    //     }
    // },true);
}]);

smartsenseApp.controller("HeaderController", ['$scope', '$rootScope', 'apiService', '$state','$stateParams','local', '$timeout', 'loading','Analytics','menuService','authService',
    function ($scope, $rootScope, apiService, $state, $stateParams, local, $timeout, loading, Analytics, menuService, authService) {

        $scope.URLMapping = menuService.URLMapping;
        $scope.localData = local.data;
        $scope.menuItems = $scope.localData.member_services;
        $scope.homePage = $scope.URLMapping[$scope.menuItems[0].url];
        $scope.activeMenu = "mydashboard";
        $scope.dmrcAlertCount = "";
        var menuTitles = {
            dashboard : 'Overview',
            sensordata:'Sensor Data',
            dmrcdashboard : 'Equipment Error Management',
            mydashboard : 'My Dashboard',
            networkInsights : 'Network Insights',
            motorInsights : 'Motor Insights',
            transformerInsights : 'Transformer Insights',
            billingInsights : 'Billing Insights',
            chillerInsights : 'Chiller Insights',
            alert : 'Alert',
            analyse : 'Analyse',
            reports : 'Reports',
            profile : 'Profile',
            widgetBuilder:'Widget Builder',
            dmrcalert: 'Alert-DMRC',
            dmrcreport: 'Report-DMRC',
            configuration: 'Configuration',
            utilization: 'Utilization'
        };

        
        $scope.activateMenu = function(activeMenu) {
            $state.go("home." + activeMenu);
            $scope.localData.activeMenu = activeMenu;
        }
        
        $scope.customLogo = false;
        if($scope.localData.member.weblogo != undefined) {
            if ($scope.localData.member.weblogo != null && $scope.localData.member.weblogo != '') {
                $scope.customLogo = $scope.localData.member.weblogo;
            };
        }

        $scope.regex = '^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,}$';

        $scope.currentPageTitle = function(){
            var str = $state.current.name;
            str = str.toString().replace("home.",'')
            return menuTitles[str] || $scope.localData.activeMenu;
        }
        
      
        $scope.redirectToDefaultPage = function () {
            if ($scope.menuItems && $scope.menuItems.length > 0) {
                var defaultPage = $scope.menuItems[0].url;
                var sref = $scope.URLMapping[defaultPage].sref;
                $state.go(sref);
            }
            return false;
        }

        $scope.logout = function(ask) {
            if (ask) {
                bootbox.confirm("Are you sure you wish to logout?", function(result) {
                    if (result){
                        $scope.logout();
                    }
                });
                return false;
            }
            authService.logout();
            var token = $stateParams["token"] || "SmartSense";
                $state.go("page.login", {
                    token: token
            });
        };

        $rootScope.$on('doLogout',function(){
            $scope.logout();
        });

        $scope.profilenameRefreshInProgress = true;

        $scope.initProfile = function() {
            var member = $scope.localData.member;
            $scope.modelUserNameLbl = member.displayname
            $scope.profilenameRefreshInProgress = false;

            $scope.modelUserName = member.displayname;
            $scope.modelCompanyName = member.clientid.clientname;
            try{
                Analytics.set('dimension1', member.username);
                Analytics.set('dimension2', member.clientid.clientname);
            }catch(ex){}
            $('#pageNavDropdown').unbind().bind("shown.bs.dropdown", function(){
                Analytics.trackEvent('Navigation', 'Dashboard-Menu', 'Opened');
            });
            $('#profileDropdown').unbind().bind("shown.bs.dropdown", function(){
                Analytics.trackEvent('Navigation', 'Profile-Menu', 'Opened');
            });

        }

        $scope.initProfile();

        $scope.changePassword = {};

        $scope.changeMyPassword = function() {
            $scope.changePassword.current = $.trim($scope.changePassword.current);
            $scope.changePassword.new = $.trim($scope.changePassword.new);
            $scope.changePassword.confirm = $.trim($scope.changePassword.confirm);
            if (!$scope.changePassword.current) {
                bootbox.alert("Please enter your current password");
                return false;
            }
            if (!$scope.changePassword.new) {
                bootbox.alert("Please enter new password");
                return false;
            }
            if ($scope.changePassword.new != $scope.changePassword.confirm) {
                bootbox.alert("Passwords do not match");
                return false;
            }
            loading(true);
            var params = {
                currentpassword: $scope.changePassword.current,
                newpassword1: $scope.changePassword.new,
                newpassword2: $scope.changePassword.confirm
            }
            apiService.auth_password_change(params).then(function(response) {
                loading(false);
                var msg = "Password successfully changed";
                if (response && response.data && response.data.message)
                    msg = response.data.message;
                $scope.changePassword = {};
                $('#closeProfilePopup').click();
                $timeout(function () {
                    bootbox.alert(msg, function() {
                        $scope.logout();
                    });
                }, 200);
            }, function(response) {
                loading(false);
                $scope.changePassword = {};
                $('#closeProfilePopup').click();
                $timeout(function () {
                    bootbox.alert(response.data.message);
                }, 200);
            });
        };

        $scope.$watch('localData.dmrcAlertCount', function(newVal) {
            $scope.dmrcAlertCount = newVal;
        });

        $scope.dmrcErrorWidget = [{
            type:"errorAlertPanel",
            size:"small",
            title:"Equipment Errors :",
            widgetPath : "dmrc",
            prefix : "dmrcWidget"
        }];

        $scope.refreshPage = function(){
            window.location.reload();
        }
    }
]);

smartsenseApp.directive('headerpanel', ['data', 'local', function(data, local) {Â Â Â  //define the directive object
    Â Â Â 
    var directive = {};Â Â Â  //restrict = E, signifies that directive is Element directive
    directive.restrict = 'E';Â Â Â 
    directive.controller = 'HeaderController';Â Â Â  //template replaces the complete element with its text.
    directive.templateUrl = "shared/header/directive/headerView.html";Â Â Â 

    return directive;

}]);

smartsenseApp.controller("FooterController", ['$scope', function($scope) {

    /*$scope.isPageSideBarClosed = true;*/

}]);
smartsenseApp.directive('footerpanel', function() {
    //define the directive object
    var directive = {};
    //restrict = E, signifies that directive is Element directive
    directive.restrict = 'E';
    directive.controller = 'FooterController';
    //template replaces the complete element with its text.
    directive.templateUrl = "shared/footer/directive/footerView.html";
    return directive;
});

smartsenseApp.controller("SidebarController", ['$scope', '$state', 'local', function($scope, $state, local) {
    $scope.activeMenu = "dashboard";
    $scope.localData = local.data;
    $scope.activateMenu = function(selectedMenu) {
        $state.go("home." + selectedMenu);
        $scope.localData.activeMenu = selectedMenu;
    }
}]);

smartsenseApp.directive('sidebar', [function() {
  //define the directive object
  var directive = {};
  //restrict = E, signifies that directive is Element directive
  directive.restrict = 'E';
  directive.controller = 'SidebarController';
  //template replaces the complete element with its text.
  directive.templateUrl = "shared/sidebar/sidebarView.html";
  return directive;
}]);

smartsenseApp.controller("QuicksidebarController", ['$rootScope', function($rootScope) {
}]);
smartsenseApp.directive('quicksidebar', [function() {
  //define the directive object
  var directive = {};
  //restrict = E, signifies that directive is Element directive
  directive.restrict = 'E';
  directive.controller = 'QuicksidebarController';
  //template replaces the complete element with its text.
  directive.templateUrl = "shared/quicksidebar/quicksidebarView.html";
  return directive;
}]);

smartsenseApp.directive('dmrcWidget', [function() {
    //define the directive object
    var directive = {};
    //restrict = E, signifies that directive is Element directive
    directive.restrict = 'E';
    directive.scope = {
        options: '=',
        class: '='
    };
    directive.replace = true;
    directive.link = function(scope, element, attrs) {
        scope.getContentUrl = function() {
            var options = scope.options;
            var url = 'shared/widget/dmrc/' + options.type + '/dmrcWidget.' + options.type + 'View.html';
            return url;
        };
    };
    directive.template = '<div ng-include="getContentUrl()"></div>';
    return directive;
}]);

smartsenseApp.directive('billingWidget', [function() {
    //define the directive object
    var directive = {};
    //restrict = E, signifies that directive is Element directive
    directive.restrict = 'E';
    directive.scope = {
        options: '='
    };
    directive.link = function(scope, element, attrs) {
        scope.getContentUrl = function() {
            var options = scope.options ? scope.options[0] : {};
            var url = (angular.isDefined(options.type)) ? 'shared/widget/billingWidgets/' + options.type + '/billingWidget.' + options.type + 'View.html' : 'shared/widget/billingWidgets/bill/billingWidget.billView.html';
            return url;
        };
    };
    directive.template = '<div ng-include="getContentUrl()"></div>';
    return directive;
}]);


smartsenseApp.directive('dashboardWidget', [function() {
    //define the directive object
    var directive = {};
    //restrict = E, signifies that directive is Element directive
    directive.restrict = 'E';
    directive.scope = {
        options: '=',
        class: '='
    };
    directive.replace = true;
    directive.link = function(scope, element, attrs) {
        scope.getContentUrl = function() {
            var options = scope.options;
            var url = 'shared/widget/dashboardWidgets/' + options.type + '/dashboardWidget.' + options.type + 'View.html';
            return url;
        };
    };
    directive.template = '<div ng-include="getContentUrl()" include-replace></div>';
    return directive;
}]);


smartsenseApp.directive('widgetDaterangepicker', ['$interval', function($interval) {
    return {
        restrict: 'AE',
        scope: {
            dateRange: '=',
            dateRangeOpts: '=',
            refreshTime: '=',
            onApply: '&'
        },
        templateUrl: 'shared/widget/widgetDaterangepicker.tpl.html',
        replace: true,
        link: function(scope, element, attrs) {
            var defaultDateRangeOpts = {
                locale: {
                    applyClass: 'btn-primary',
                    applyLabel: "Apply",
                    fromLabel: "From",
                    format: 'Do MMM, h:mm a',
                    toLabel: "To",
                    cancelLabel: 'Cancel',
                    customRangeLabel: 'Custom Range'
                },
                opens: "up",
                timePicker: true,
                autoApply: true,
                maxDate: moment().add(1, 'days').endOf('day'),
                ranges: {
                    'Today': [moment().startOf('day'), moment()],
                    'Yesterday': [moment().subtract(1, "days").startOf('day'), moment().subtract(1, "days").endOf('day')],
                    'Last 7 Days': [moment().subtract(6, 'days'), moment()],
                    'Last 30 Days': [moment().subtract(29, 'days'), moment()],
                    'Last 3 months': [moment().subtract(2, 'months').startOf('month'), moment()]
                },
                eventHandlers: {
                    'apply.daterangepicker': function(ev, picker) {
                        scope.onApply();
                        scope.cancelRefresh();
                    }
                }
            };
            scope.dateRangeOpts = scope.dateRangeOpts || defaultDateRangeOpts;

            var refreshtime = utils.getWidgetRefreshTime(scope.refreshTime);
            var timer = null;

            if (scope.dateRange.endDate > moment()) {
                timer = $interval(function() {
                    scope.onApply();
                }, refreshtime);
            }

            scope.cancelRefresh = function() {
                if (timer) {
                    $interval.cancel(timer);
                }
            }

            scope.$on('$destroy', function() {
                scope.cancelRefresh();
            });

        }
    };
}]);
(function() {


    /* jshint camelcase:false, unused:false */
    'use strict';

    /**
     * Create a constructor for sparklines that takes some sensible defaults and merges in the individual
     * chart options. This function is also available from the jQuery plugin as $(element).highcharts('SparkLine').
     */
    Highcharts.SparkLine = function(a, b, c) {
        var hasRenderToArg = typeof a === 'string' || a.nodeName,
            options = arguments[hasRenderToArg ? 1 : 0],
            defaultOptions = {
                chart: {
                    renderTo: (options.chart && options.chart.renderTo) || this,
                    backgroundColor: null,
                    borderWidth: 0,
                    type: 'area',
                    margin: [2, 2, 2, 2],
                    width: 120,
                    height: 25,
                    style: {
                        overflow: 'visible'
                    },
                    skipClone: true
                },
                title: {
                    text: ''
                },
                credits: {
                    enabled: false
                },
                xAxis: {
                    type: 'datetime',
                    labels: {
                        enabled: false
                    },
                    title: {
                        text: null
                    },
                    startOnTick: false,
                    endOnTick: false,
                    tickPositions: [],
                    lineColor: 'rgba(255,255,255,0)',
                },
                yAxis: {
                    endOnTick: false,
                    startOnTick: false,
                    labels: {
                        enabled: false
                    },
                    title: {
                        text: null
                    },
                    tickPositions: [0]
                },
                legend: {
                    enabled: false
                },
                tooltip: {
                    positioner: function(w, h, point) {
                        return {
                            x: point.plotX - w / 2,
                            y: point.plotY - h
                        };
                    }
                },
                exporting: {
                    enabled: false
                },
                plotOptions: {
                    series: {
                        animation: false,
                        lineWidth: 2,
                        shadow: false,
                        marker: {
                            radius: 1,
                        },
                        fillOpacity: 0.25
                    },
                    column: {
                        negativeColor: '#910000',
                        borderColor: 'silver'
                    }
                }
            };

        options = Highcharts.merge(defaultOptions, options);

        return hasRenderToArg ?
            new Highcharts.Chart(a, options, c) :
            new Highcharts.Chart(options, b);
    };

    /**
     * AngularJs directive for highcharts' highstock multi graph
     * @see http://jsfiddle.net/hardiksondagar/2BGSK/176/
     *
     * @param {Array} data Chart data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     **/
    smartsenseApp.directive('highchartGraph', ['highchartService', function(highchartService) {
        return {
            restrict: 'E',
            scope: {
                data: '=',
                options: '=',
                control: '='
            },
            link: function(scope, element) {

                scope.internalControl = scope.control || {};

                var Chart;
                // default options
                var options = {};

                scope.setOptions = function() {
                    var elementWidth = element.parent().width();
                    var options = {
                        chart: {
                            renderTo: element[0],
                            zoomType: 'x',
                            shadow: false,
                            defaultSeriesType: 'area',
                            width: elementWidth,
                            alignTicks: false,
                        },
                        xAxis: {
                            type: 'datetime',
                            startOnTick: false,
                            tickmarkPlacement: 'on',
                            minRange: 3600000,
                            title: {
                                text: null
                            },
                            minorGridLineWidth: 0
                        },
                        series: [],
                        yAxis: [],
                        plotOptions: {
                            column: {
                                allowPointSelect: true
                            },
                            series: {
                                allowPointSelect: true,
                                marker: {
                                    enabled: false,
                                    states: {
                                        hover: {
                                            enabled: true,
                                            radius: 5,
                                        }
                                    }
                                },
                                shadow: false,
                                borderRadius: 0,
                                borderColor: 'rgba(255, 255, 255, 0.1)',
                                borderWidth: 0
                            }
                        },
                        tooltip: {
                            valueDecimals: 2,
                            shared: true,
                            headerFormat: '{point.key}<br/>',
                            pointFormatter: function() {
                                var name = this.series.name || "";
                                var value = parseFloat(this.y).toFixed(2);
                                //To avoid -0.00 scenario
                                if (value == 0)
                                    value = 0.00;
                                var unit = this.series.options.unit || "";
                                var color = this.series.options.color;
                                return '<span style="color:' + color + '">\u25CF</span> ' + name + ': <b>' + value + '</b> ' + unit + '<br/>';
                            },
                        },
                        shadow: false,
                        borderRadius: 0,
                        borderColor: 'rgba(255, 255, 255, 0.1)',
                        borderWidth: 0,
                        sameyAxis: false
                    };
                    return options;
                }

                options = scope.setOptions();
                Chart = new Highcharts.Chart(options);

                // create the chart
                scope.$watch('data', function(newVals, oldVals) {
                    options = scope.setOptions();
                    // override default options with values from the scope
                    if (scope.options) {
                        options = utils.MergeRecursive(options, scope.options);
                    }
                    scope.render(newVals);
                }, true);

                var delay = (function() {
                    var timer = 0;
                    return function(callback, ms) {
                        clearTimeout(timer);
                        timer = setTimeout(callback, ms);
                    };
                })();

                scope.render = function(chartDataModel) {
                    if (Chart !== undefined) {
                        Chart.destroy();
                    }
                    var n_series = chartDataModel instanceof Array ? chartDataModel.length : 0;
                    options.series = [];
                    Chart = new Highcharts.Chart(options);
                    var yAxisMapping = {};
                    var yAxisCount = 0;
                    for (var i = 0; i < n_series; i++) {
                        if (!chartDataModel[i]) {
                            continue;
                        }
                        var timeSeries = chartDataModel[i].timeSeries || chartDataModel[i].timeseries;
                        var yAxisId = null;
                        var readingtype = chartDataModel[i].readingtype;
                        var id = i;
                        var type = '';
                        var title = '';
                        if (chartDataModel[i].type) {
                            type = chartDataModel[i].type;
                        }
                        if (readingtype) {
                            title = readingtype.readingtypename;
                            if (!type) {
                                type = readingtype.timebased ? 'column' : 'area';
                            }
                        } else {
                            title = chartDataModel[i].name;
                        }
                        var newYAxis = !readingtype || typeof yAxisMapping[readingtype.readingtypeid] == 'undefined';
                        if (newYAxis) {
                            var yAxis = {
                                isX: false,
                                redraw: true,
                                title: {
                                    text: title,
                                    style: {
                                        color: Highcharts.getOptions().colors[i]
                                    }
                                },
                                gridLineColor: 'transparent',
                                opposite: yAxisCount % 2 == 0 ? false : true,
                                plotLines: chartDataModel[i].plotLines
                            }
                            yAxis = utils.MergeRecursive(yAxis, options['yAxisOptions']);
                            Chart.addAxis(yAxis);
                            yAxisId = yAxisCount;
                            if (readingtype) {
                                yAxisMapping[readingtype.readingtypeid] = yAxisCount;
                            }
                            yAxisCount++;
                        } else {
                            yAxisId = yAxisMapping[readingtype.readingtypeid];
                        }
                        var chartData = [];
                        var index = Object();
                        for (index in timeSeries) {
                            if (timeSeries.hasOwnProperty(index)) {
                                chartData.push([timeSeries[index].timeStamp * 1000, timeSeries[index].value]);
                            }
                        }
                        var series = {
                            color: Highcharts.getOptions().colors[i],
                            data: chartData,
                            redraw: false,
                            type: type,
                            fillOpacity: 0.2,
                            lineWidth: 2,
                            yAxis: yAxisId,
                        }

                        series = utils.MergeRecursive(chartDataModel[i], series);
                        Chart.addSeries(series);
                        Chart.redraw();
                    }
                };
            }
        };
    }]);

    /**
     * Wrapper directive of highcharts-ng for multi parameters vs time graphs.
     * 
     * @param {Array} data timeseries data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     **/
    smartsenseApp.directive('highchartMultiAxis', ['highchartService', function(highchartService) {
        return {
            restrict: 'E',
            scope: {
                data: '=',
                options: '='
            },
            template: '<div class="row"><highchart config="graphConfig" class="col-md-12"></highchart></div>',
            link: function(scope, element) {
                scope.graphConfig = {
                    options: {
                        chart: {
                            zoomType: 'x',
                            defaultSeriesType: 'area'
                        },
                        xAxis: {
                            type: 'datetime',
                            minorGridLineWidth: 0
                        },
                        yAxis: []
                    },
                    series: []
                }
                scope.$watch('data', function(newVals, oldVals) {
                    // override default options with values from the scope
                    if (scope.options) {
                        scope.graphConfig.options = utils.MergeRecursive(scope.graphConfig.options, scope.options);
                    }
                    scope.render(newVals);
                }, true);

                scope.render = function(serieses) {
                    scope.graphConfig.options.yAxis = [];
                    scope.graphConfig.series = [];
                    // Readingtypeid to yAxis's index mapping
                    var yAxisMapping = {};
                    // yAxisCount to set opposite on odd/even value
                    var yAxisCount = 0;
                    var yAxisId = 0;
                    // Create yAxises 
                    angular.forEach(serieses, function(series, index) {
                        // Create dummy readingtype for graphs with no readingtype like computed
                        series.readingtype = series.readingtype || {
                            readingtypeid: index,
                            timebased: false,
                            readingtypename: series.name,
                            unit: series.unit || ''
                        }
                        // Create axis per readingtype
                        if (!(series.readingtype.unit in yAxisMapping)) {
                            var yAxis = {
                                isX: false,
                                redraw: true,
                                title: {
                                    text: series.unit || series.readingtype.unit || series.readingtype.readingtypename
                                },
                                gridLineWidth:0,
                                // Set even number of yAxis to right side
                                opposite: yAxisCount % 2 == 0 ? false : true,
                                plotLines: []
                            };
                            var yAxisKey = scope.graphConfig.options.yAxis.push(yAxis) - 1;
                            // Map yAxis index to readingtypeid
                            yAxisMapping[series.readingtype.unit] = yAxisKey;
                            yAxisCount++;
                        };

                        // Get yAxis index based on the readingtypeid
                        var yAxisId = yAxisMapping[series.readingtype.unit];

                        // Convert data to x,y cordinate format
                        var data = [];
                        series.timeSeries.forEach(function(value) {
                            data.push({ x: value.timeStamp * 1000, y: value.value });
                        });
                        series.data = data;
                        series.yAxis = yAxisId;
                        series.type = series.type || (series.readingtype.timebased ? 'column' : 'area');

                        series.tooltip = {
                            valueSuffix: ' ' + series.readingtype.unit
                        }

                        // Check for plotlines
                        if (series.plotLines && series.plotLines.length) {
                            scope.graphConfig.options.yAxis[yAxisId].plotLines = scope.graphConfig.options.yAxis[yAxisId].plotLines.concat(series.plotLines);
                            // When maximux of data is lower than the plotline value, plotline will not be visible. To prevent this add one hidden scatter point to extend yAxis's range.
                            // Refer @https://stackoverflow.com/questions/13084849
                            angular.forEach(series.plotLines, function(plotline) {
                                scope.graphConfig.series.push({
                                    name: plotline.label.text,
                                    type: 'scatter',
                                    marker: {
                                        enabled: false
                                    },
                                    yAxis: yAxisId,
                                    showInLegend: false,
                                    data: [{ y: plotline.value, x: series.timeSeries[0].timeStamp * 1000 }]
                                });
                            });
                        }
                        scope.graphConfig.series.push(series);
                    });
                };
            }
        };
    }]);



    /**
     * AngularJs directive for highcharts' highstock multi axis chart (column and line) with flags
     * @see http://jsfiddle.net/hardiksondagar/2BGSK/176/
     *
     * @param {Array} data Chart data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     **/
    smartsenseApp.directive('highchartAnalyse', function() {
        return {
            link: function(scope, element) {
                var Chart;
                // default options
                var dateTimeLabelFormats = {
                    millisecond: '%H:%M:%S.%L',
                    second: '%H:%M:%S',
                    minute: '%H:%M',
                    hour: '%H:%M',
                    day: '%e. %b',
                    week: '%e. %b',
                    month: '%b \'%y',
                    year: '%Y'
                };

                var options = {};

                scope.setOptions = function() {
                    var elementWidth = element.parent().width();
                    var options = {
                        chart: {
                            renderTo: element[0],
                            zoomType: 'x',
                            shadow: false,
                            defaultSeriesType: 'area',
                            width: elementWidth,
                            alignTicks: false,
                        },
                        credits: {
                            enabled: false
                        },
                        title: {
                            align: 'center',
                            text: '',
                        },
                        legend: {
                            enabled: true,
                            layout: 'horizontal',
                            align: 'center',
                            verticalAlign: 'bottom',
                            itemStyle: {
                                "color": "#333333",
                                "cursor": "pointer",
                                "fontSize": "12px",
                                "fontWeight": "normal",
                                "fontFamily": "Lato",
                                "textTransform": "capitalize"
                            }
                            // borderWidth: 0
                        },
                        xAxis: {
                            type: 'datetime',
                            startOnTick: false,
                            tickmarkPlacement: 'on',
                            minRange: 3600000,
                            title: {
                                text: null
                            },
                            minorGridLineWidth: 0,
                        },
                        yAxis: {
                            gridLineColor: 'transparent',
                            title: {
                                text: null
                            }
                        },
                        series: [],
                        plotOptions: {
                            column: {
                                // stacking: 'normal',
                                allowPointSelect: true
                            },
                            series: {
                                allowPointSelect: true,
                                marker: {
                                    enabled: false,
                                    states: {
                                        hover: {
                                            enabled: true,
                                            radius: 5,
                                        }
                                    }
                                },
                                shadow: false,
                                borderRadius: 0,
                                borderColor: 'rgba(255, 255, 255, 0.1)',
                                borderWidth: 0
                            }
                        },

                        // Time: {point.timestamp:%e %b, %Y %H:%M}<br>Value: <b>{point.original:0.2f}
                        tooltip: {
                            valueDecimals: 2,
                            shared: true,
                            headerFormat: '{point.key}<br/>',
                            pointFormatter: function() {
                                var name = this.series.name || "";
                                var value = parseFloat(this.y).toFixed(2);
                                //To avoid -0.00 scenario
                                if (value == 0)
                                    value = 0.00;
                                var unit = this.series.options.unit || "";
                                var color = this.series.options.color;
                                return '<span style="color:' + color + '">\u25CF</span> ' + name + ': <b>' + value + '</b> ' + unit + '<br/>';
                            }
                        },
                        exporting: {
                            buttons: {
                                contextButton: {
                                    menuItems: [{
                                        text: '<span style="font-size:12px;">Export to PDF</span>',
                                        onclick: function() {
                                            this.exportChart({
                                                type: 'application/pdf',
                                                width: elementWidth
                                            });
                                            if (options.onExport)
                                                options.onExport("pdf");
                                        }
                                    }, {
                                        text: '<span style="font-size:12px;">Export to JPEG</span>',
                                        onclick: function() {
                                            this.exportChart({
                                                type: 'image/jpeg',
                                                width: elementWidth
                                            });
                                            if (options.onExport)
                                                options.onExport("jpg");
                                        }
                                    }, {
                                        text: '<span style="font-size:12px;">Export to PNG</span>',
                                        onclick: function() {
                                            this.exportChart({
                                                width: elementWidth
                                            });
                                            if (options.onExport)
                                                options.onExport("png");
                                        },
                                        separator: false
                                    }]
                                }
                            },
                            // sourceHeight: 500,
                            sourceWidth: elementWidth,
                            filename: 'anaylseChart'
                        },
                        navigation: {
                            buttonOptions: {
                                verticalAlign: 'bottom',
                                y: 7,
                                x: 5,
                                theme: {
                                    r: 10,
                                }
                            }
                        },
                        shadow: false,
                        borderRadius: 0,
                        borderColor: 'rgba(255, 255, 255, 0.1)',
                        borderWidth: 0,
                        sameyAxis: false
                    };
                    return options;
                }

                options = scope.setOptions();
                Chart = new Highcharts.Chart(options);

                // create the chart
                scope.$watch('data', function(newVals, oldVals) {
                    options = scope.setOptions();
                    // override default options with values from the scope
                    if (scope.options) {
                        options = utils.MergeRecursive(options, scope.options);
                    }
                    scope.render(newVals);
                }, true);

                //Handle change of plotLinesFilter
                scope.$watch('plotLinesFilter', function(newVals, oldVals) {
                    scope.render(scope.data);
                }, true);

                scope.render = function(chartDataModel) {
                    if (Chart !== undefined) {
                        Chart.destroy();
                    }
                    if (!chartDataModel instanceof Array)
                        chartDataModel = [chartDataModel];
                    var yaxisNumber = chartDataModel instanceof Array ? chartDataModel.length : 0;

                    var index = new Object();
                    // options.yAxis = [];
                    options.series = [];
                    Chart = new Highcharts.Chart(options);
                    var sensorSet = [];
                    var plotLinesFilter = scope.plotLinesFilter || "Daywise";
                    var sensorId;
                    for (var i = 0; i < yaxisNumber; i++) {
                        if (!chartDataModel[i]) {
                            continue;
                        }
                        chartDataModel[i].readingtype = chartDataModel[i].readingtype || chartDataModel[i].readingType;
                        var hideYAxis = false;
                        var commonLabel = false;
                        var color = chartDataModel[i].color;
                        var dashStyle = chartDataModel[i].dashStyle || "Solid";
                        var lineWidth = chartDataModel[i].lineWidth;
                        var chartType = chartDataModel[i].chartType || "area";
                        if (hideYAxis) {
                            Chart.yAxis[i].update({
                                labels: {
                                    enabled: false
                                }
                            })
                        }
                        if (typeof chartDataModel[i].yaxis != "undefined") {
                            Chart.yAxis[0].update({
                                min: chartDataModel[i].yaxis.min,
                                max: chartDataModel[i].yaxis.max,
                                labels: {
                                    style: {
                                        color: color || Highcharts.getOptions().colors[i]
                                    }
                                }
                            });
                        }
                        if (options.chartTypeBasedOnScalar) {
                            chartType = chartDataModel[i].readingtype && chartDataModel[i].readingtype.scalar ? "line" : "area";
                        }
                        var visible = typeof chartDataModel[i].visible != "undefined" ? chartDataModel[i].visible : true;
                        var sensorAlert = [];
                        var userEvents = [];
                        var flags = [];
                        var plotLines = {};
                        var plotBands = [];
                        var chartData = [],
                            timeSeries = new Object(),
                            type = (chartDataModel[i].readingtype && chartDataModel[i].readingtype.timebased) ? 'column' : chartType;
                        if (chartDataModel[i].sensorAlert !== undefined && chartDataModel[i].sensorAlert.length != 0 &&
                            sensorAlert.length == 0) {
                            for (index in chartDataModel[i].sensorAlert) {
                                sensorId = chartDataModel[i].sensorAlert[index].sensorId;
                                if (sensorSet.indexOf(chartDataModel[i].sensorAlert[index].sensorId) == -1) {
                                    var val = chartDataModel[i].sensorAlert[index].thresholdValue.toPrecision(2);
                                    sensorAlert.push({
                                        x: new Date(chartDataModel[i].sensorAlert[index].endTime).getTime(),
                                        title: "!",
                                        text: "<b>" + chartDataModel[i].sensorAlert[index].sensorName + "</b>:" +
                                            chartDataModel[i].sensorAlert[index].readingtypename + " " + chartDataModel[i].sensorAlert[index].condition +
                                            " " + val
                                    });
                                }
                            }
                            sensorSet.push(sensorId);
                        }
                        if (chartDataModel[i].userEvents != null && userEvents.length == 0) {
                            for (index in chartDataModel[i].userEvents) {
                                sensorId = chartDataModel[i].userEvents[index].sensorId;
                                if (sensorSet.indexOf(chartDataModel[i].userEvents[index].sensorId) == -1) {
                                    userEvents.push({
                                        x: new Date(chartDataModel[i].userEvents[index].dateOfEvent).getTime(),
                                        title: "!",
                                        text: chartDataModel[i].userEvents[index].sensorName + " : " +
                                            "<b>" + chartDataModel[i].userEvents[index].eventName + "</b>" + " "
                                    });
                                }
                            }
                            sensorSet.push(sensorId);
                        }
                        if (chartDataModel[i].flags != null && flags.length == 0) {
                            flags = chartDataModel[i].flags;
                        }
                        if (chartDataModel[i].plotLines != null && ((chartDataModel[i].plotLines.Daywise && chartDataModel[i].plotLines.Daywise.length > 0) || (chartDataModel[i].plotLines.Shiftwise && chartDataModel[i].plotLines.Shiftwise.length > 0))) {
                            plotLines = chartDataModel[i].plotLines;
                        }
                        if (chartDataModel[i].plotBands != null && plotBands.length == 0) {
                            plotBands = chartDataModel[i].plotBands;
                        }
                        if (chartDataModel[i].timeSeries !== undefined) {
                            timeSeries = chartDataModel[i].timeSeries;
                        }
                        if (chartDataModel[i].timeseries !== undefined) {
                            timeSeries = chartDataModel[i].timeseries;
                        }
                        var timestampMultiplier = 1000;
                        if (options.realTimestamp) {
                            timestampMultiplier = 1;
                        }
                        for (index in timeSeries) {
                            if (timeSeries.hasOwnProperty(index)) {
                                chartData.push([new Date(timeSeries[index].timeStamp * timestampMultiplier).getTime(), timeSeries[index].value]);
                            }
                        }
                        var isOpposite = false;
                        if ([1, 3, 5, 7].indexOf(i) > -1) {
                            isOpposite = true;
                        }
                        var title = chartDataModel[i].readingtype.readingtypename != chartDataModel[i].name ? chartDataModel[i].readingtype.readingtypename + ' - (' + chartDataModel[i].name + ')' : chartDataModel[i].name;
                        if (!chartDataModel[i].name)
                            title = chartDataModel[i].readingtype.readingtypename;
                        if (options.onlyDataName)
                            title = chartDataModel[i].name;
                        var truncatedTitle = title;
                        var TRUNCATE_LENGTH = 30;
                        //truncating long-title names
                        if (title.length > TRUNCATE_LENGTH) {
                            truncatedTitle = title.substring(0, TRUNCATE_LENGTH - 1) + '...';
                        }
                        if (options.hideYAxisLabels) {
                            Chart.yAxis[0].update({
                                title: {
                                    text: null
                                },
                                labels: {
                                    style: {
                                        color: color || Highcharts.getOptions().colors[i]
                                    }
                                }
                            });
                        } else {
                            var axisLabel = commonLabel || '<div title="' + title + '" class="truncate-text">' + truncatedTitle + '</div>';
                            Chart.addAxis({
                                isX: false,
                                redraw: true,
                                title: {
                                    text: axisLabel,
                                    style: {
                                        color: color || Highcharts.getOptions().colors[i]
                                    },
                                    useHTML: true,
                                    enabled: !hideYAxis,
                                    reserveSpace: false
                                },
                                labels: {
                                    style: {
                                        color: color || Highcharts.getOptions().colors[i]
                                    }
                                },
                                opposite: isOpposite,
                                gridLineColor: 'transparent'
                            });
                        }
                        var addGraph = true;
                        if (typeof chartDataModel[i].showOnlyIfDataExists != "undefined" && chartDataModel[i].showOnlyIfDataExists) {
                            addGraph = chartData.length > 0;
                        }
                        if (addGraph) {
                            Chart.addSeries({
                                name: title,
                                color: color || Highcharts.getOptions().colors[i],
                                dashStyle: dashStyle,
                                data: chartData,
                                // zIndex: 2,
                                redraw: false,
                                visible: visible,
                                type: type,
                                fillOpacity: 0.2,
                                lineWidth: lineWidth || 2,
                                yAxis: Number.isInteger(options.sameyAxis) ? options.sameyAxis : i,
                                id: 'dataseries' + i,
                                unit: chartDataModel[i].unit,
                                marker: chartDataModel[i].markerOptions || {
                                    enabled: false,
                                    states: {
                                        hover: {
                                            enabled: true,
                                            radius: 5,
                                        }
                                    }
                                }
                            });
                        }
                        if (sensorAlert.length != 0) {
                            Chart.addSeries({
                                name: "Alerts for " + chartDataModel[i].name,
                                color: 'red',
                                data: sensorAlert,
                                type: 'flags',
                                onSeries: 'dataseries' + i,
                                shape: 'circlepin',
                                width: 16,
                                fillOpacity: 0.4,
                                y: 0,
                            });
                        }
                        if (userEvents.length != 0) {
                            Chart.addSeries({
                                name: "Events for " + chartDataModel[i].name,
                                color: '#ffa700',
                                data: userEvents,
                                type: 'flags',
                                onSeries: 'dataseries' + i,
                                shape: 'circlepin',
                                width: 16,
                                fillOpacity: 0.4,
                                y: 0,
                            });
                        }
                        if (flags.length != 0) {
                            Chart.addSeries({
                                name: "Deviation",
                                color: '#ffa700',
                                data: flags,
                                type: 'flags',
                                onSeries: 'dataseries' + i,
                                shape: 'circlepin',
                                fillOpacity: 1,
                                style: {
                                    "fontSize": "4px",
                                    "fontWeight": "bold",
                                    "padding": 0
                                }
                            });
                        }
                        if (plotLines && plotLines[plotLinesFilter] && plotLines[plotLinesFilter].length != 0) {
                            //var axis = Chart.xAxis[0];
                            var curPlotLines = plotLines[plotLinesFilter];
                            var markers = [];
                            curPlotLines.forEach(function(line) {
                                //axis.addPlotLine(line);
                                markers.push([new Date(line.value).getTime(), line.pointValue]);
                            });
                            Chart.addSeries({
                                enableMouseTracking: false,
                                showInLegend: false,
                                name: 'Markers',
                                data: markers,
                                type: 'scatter',
                                zIndex: 1,
                                marker: {
                                    enabled: true,
                                    symbol: 'circle',
                                    radius: 5,
                                    fillColor: 'red'
                                }
                            });
                        }
                        if (plotBands.length != 0) {
                            var axis = Chart.xAxis[0];
                            plotBands.forEach(function(line) {
                                axis.addPlotBand(line);
                                if (line.legend) {
                                    Chart.addSeries({
                                        enableMouseTracking: false,
                                        showInLegend: true,
                                        name: line.legend.label,
                                        data: [],
                                        type: 'area',
                                        zIndex: 1,
                                        color: line.legend.color,
                                        events: {
                                            legendItemClick: function(e) {
                                                e.preventDefault();
                                            }
                                        },
                                        legendIndex: 10
                                    });
                                }
                            });
                        }
                    }
                    if (options.constantLines) {
                        var axis = Chart.yAxis[0];
                        options.constantLines.forEach(function(line) {
                            axis.addPlotLine(line);
                        });
                    }
                    Chart.redraw();
                    var delay = (function() {
                        var timer = 0;
                        return function(callback, ms) {
                            clearTimeout(timer);
                            timer = setTimeout(callback, ms);
                        };
                    })();
                    $(window).unbind("resize.chart").bind("resize.chart", function() {
                        delay(function() {
                            var height = Chart.height
                            var width = element.parent().width();
                            Chart.setSize(width, height);
                        }, 300);
                    });
                }
            },
            restrict: 'E',
            scope: {
                data: '=',
                options: '=',
                render: '=',
                plotLinesFilter: '='
            }
        };
    });


    /**
     * AngularJs directive for highcharts' donut chart
     * @see http://jsfiddle.net/gh/get/jquery/1.9.1/highslide-software/highcharts.com/tree/master/samples/highcharts/demo/pie-basic/
     *
     * @param {Array} data Chart data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     */
    smartsenseApp.directive('highchartDonut', function() {
        return {
            link: function(scope, element) {

                var Chart;

                var options = {};

                scope.setOptions = function() {
                    var elementWidth = element.parent().width();
                    var elementHeight = element.parent().height() || elementWidth;
                    var options = {
                        chart: {
                            renderTo: element[0],
                            width: elementWidth,
                            plotBackgroundColor: null,
                            plotBorderWidth: 0,
                            // plotShadow: false,
                            type: 'pie',
                            spacingTop: 0,
                            // spacingLeft: 0,
                            // spacingRight: 0,
                            height: elementHeight
                        },
                        title: {
                            text: null,
                        },
                        label: {
                            enabled: false,
                        },
                        credits: {
                            enabled: false
                        },
                        tooltip: {
                            pointFormat: '<b>{point.value:.2f} {point.unit}</b><br><b> {point.percentage:.1f}% of Total</b>'
                        },
                        exporting: {
                            enabled: false
                        },
                        plotOptions: {
                            pie: {
                                allowPointSelect: true,
                                cursor: 'pointer',
                                dataLabels: {
                                    enabled: false,
                                },
                                showInLegend: true
                            }
                        },
                        series: []
                    };
                    return options;
                }


                options = scope.setOptions();
                Chart = new Highcharts.Chart(options);

                // create the chart
                scope.$watch('data', function(newVals, oldVals) {

                    options = scope.setOptions();

                    // override default options with values from the scope
                    if (scope.options) {
                        options = utils.MergeRecursive(options, scope.options);
                    }

                    scope.render(newVals);

                }, true);

                scope.render = function(chartDataModel) {

                    if (!chartDataModel || typeof chartDataModel != "object" || !chartDataModel.hasOwnProperty("data")) {
                        return;
                    }

                    if (Chart !== undefined) {
                        Chart.destroy();
                    }

                    options.series = [chartDataModel];
                    Chart = new Highcharts.Chart(options);
                    Chart.redraw();

                }
            },
            restrict: 'E',
            scope: {
                data: '=',
                options: '=',
                render: '='
            }
        };
    });

    /**
     * AngularJs directive for highcharts' donut chart
     * @see http://jsfiddle.net/gh/get/jquery/1.9.1/highslide-software/highcharts.com/tree/master/samples/highcharts/demo/pie-basic/
     *
     * @param {Array} data Chart data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     */
    smartsenseApp.directive('highchartDonutCircle', function() {
        return {
            link: function(scope, element) {

                var Chart;

                var options = {};

                scope.setOptions = function() {
                    var elementWidth = element.parent().width();
                    var elementHeight = element.parent().height() || elementWidth;
                    var options = {
                        chart: {
                            renderTo: element[0],
                            type: 'pie',
                            width: elementWidth,
                            height: elementHeight
                        },
                        tooltip: {
                            enabled: true,
                        },
                        exporting: {
                            enabled: false
                        },
                        credits: {
                            enabled: false
                        },
                        responsive: {
                            rules: [{
                                condition: {
                                    maxWidth: 200
                                },
                                chartOptions: {
                                    legend: {
                                        enabled: false
                                    }
                                }
                            }]
                        },
                        title: {
                            text: '',
                            useHTML: true,
                            align: 'center',
                            verticalAlign: 'middle',
                            style: {
                                fontSize: '14px',
                                top: '-20px'
                            }
                        },
                        plotOptions: {
                            series: {
                                showInLegend: true,
                                animation: false,
                                innerSize: '70%',
                                dataLabels: {
                                    enabled: false
                                },
                                allowPointSelect: true,
                                slicedOffset: 5,
                                cursor: 'pointer',
                                states: {
                                    hover: {
                                        enabled: true
                                    }
                                },
                                point: {
                                    events: {
                                        legendItemClick: function(e) {
                                            var select = e.target.name;
                                            var series = Chart.series[0];
                                            series.points.forEach(function(curPoint) {
                                                if (curPoint.name == select) {
                                                    curPoint.select();
                                                }
                                            });
                                            e.preventDefault();
                                        },
                                        click: function(evt) {
                                            if (options.forNI) {
                                                try {
                                                    if (!evt.point.selected)
                                                        evt.point.select();
                                                    else
                                                        return false;
                                                } catch (ex) {
                                                    console.log(ex);
                                                }
                                            }
                                        },
                                        select: function(evt) {
                                            if (options.forNI) {
                                                if (this.selected)
                                                    return true;
                                                var points = Chart.getSelectedPoints();
                                                this.update({
                                                    color: '#ff6666'
                                                });
                                                if (options.onSelect)
                                                    options.onSelect(evt, this);
                                                return true;
                                            } else {
                                                if (options.onSelect) {
                                                    options.onSelect(evt, this);
                                                }
                                            }
                                        },
                                        unselect: function(evt) {
                                            if (this.selected)
                                                return false;
                                            if (options.forNI)
                                                this.update({
                                                    color: '#e6e6e6'
                                                });
                                            return true;
                                        }
                                    }
                                }
                            }
                        },
                        series: []
                    };
                    return options;
                }

                options = scope.setOptions();
                Chart = new Highcharts.Chart(options);

                // create the chart
                scope.$watch('data', function(newVals, oldVals) {
                    options = scope.setOptions();
                    // override default options with values from the scope
                    if (scope.options) {
                        options = utils.MergeRecursive(options, scope.options);
                    }
                    scope.render(newVals);
                }, true);

                scope.render = function(chartDataModel) {
                    if (Chart !== undefined) {
                        Chart.destroy();
                    }
                    options.series = chartDataModel;
                    Chart = new Highcharts.Chart(options);
                    Chart.redraw();
                }
            },
            restrict: 'E',
            scope: {
                data: '=',
                options: '=',
                render: '='
            }
        };
    });

    /**
     * AngularJs directive for highcharts' donut chart
     * @see http://jsfiddle.net/gh/get/jquery/1.9.1/highslide-software/highcharts.com/tree/master/samples/highcharts/demo/pie-basic/
     *
     * @param {Array} data Chart data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     */
    smartsenseApp.directive('highchartBarGraphs', function() {
        return {
            link: function(scope, element) {

                var Chart;

                var options = {};

                scope.setOptions = function() {
                    var elementWidth = element.parent().width();
                    var elementHeight = element.parent().height() || elementWidth;
                    var options = {
                        chart: {
                            renderTo: element[0],
                            type: 'column',
                            width: elementWidth,
                            height: 250
                        },
                        title: {
                            text: false
                        },
                        legends: {
                            enabdle: false
                        },
                        credits: {
                            enabled: false
                        },
                        xAxis: {
                            //categories: ['Current Month', 'Previous Month', 'Current Week', 'Previous Week', 'Selected Period'],
                            labels: {
                                autoRotation: false
                            }
                        },
                        yAxis: {
                            visible: false
                        },
                        tooltip: {
                            headerFormat: '<b>{point.x}</b><br/>',
                            pointFormat: '{series.name}: {point.y}<br/>Total: {point.stackTotal}'
                        },
                        plotOptions: {
                            column: {
                                stacking: 'normal',
                                dataLabels: {
                                    enabled: false,
                                    color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white'
                                }
                            }
                        },
                        exporting: {
                            enabled: false
                        }
                    };
                    return options;
                }

                options = scope.setOptions();
                Chart = new Highcharts.Chart(options);

                // create the chart
                scope.$watch('options', function(newVals, oldVals) {
                    options = scope.setOptions();
                    // override default options with values from the scope
                    if (scope.options) {
                        options = utils.MergeRecursive(options, scope.options);
                    }
                    scope.render(newVals);
                    var delay = (function() {
                        var timer = 0;
                        return function(callback, ms) {
                            clearTimeout(timer);
                            timer = setTimeout(callback, ms);
                        };
                    })();
                    if (options.responsive) {
                        $(window).unbind("resize.barchart").bind("resize.barchart", function() {
                            delay(function() {
                                var height = Chart.height
                                var width = element.parent().width();
                                Chart.setSize(width, height);
                            }, 300);
                        });
                    }
                }, true);

                scope.render = function(chartDataModel) {
                    if (Chart !== undefined) {
                        Chart.destroy();
                    }
                    //options.series = chartDataModel;
                    Chart = new Highcharts.Chart(options);
                    Chart.redraw();
                }
            },
            restrict: 'E',
            scope: {
                data: '=',
                options: '=',
                render: '='
            }
        };
    });

    /**
     * AngularJs directive for highcharts' sparkline (small area chart to show trendline )
     * @see http://jsfiddle.net/gh/get/jquery/1.9.1/highslide-software/highcharts.com/tree/master/samples/highcharts/demo/sparkline/
     *
     * @param {Array} data Chart data
     * @author Master Wayne (hardiksondagar)
     */
    smartsenseApp.directive('highchartSparkline', function() {
        return {
            link: function(scope, element) {

                // create the chart
                scope.$watch('data', function(newVals, oldVals) {
                    scope.render(newVals);
                }, true);

                scope.render = function(chartDataModel) {

                    var elementWidth = element.parent().width();
                    var chart = {
                        width: elementWidth,
                        height: 30
                    };

                    $(element[0]).highcharts('SparkLine', {
                        series: [{
                            data: chartDataModel,
                            pointStart: 1
                        }],
                        tooltip: {
                            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
                            pointFormat: '<div style="font-weight:bold;padding:2px;border:1px dotted #ccc;">{point.value} {point.suffix}</div>',
                        },
                        chart: chart,
                        colors: scope.colors || Highcharts.getOptions().colors[0]
                    });

                }
            },
            restrict: 'E',
            scope: {
                data: '=',
                colors: '='
            }
        };
    });


    /**
     * AngularJs directive for highcharts' stacked bar chart
     * @see http://jsfiddle.net/gh/get/jquery/1.9.1/highslide-software/highcharts.com/tree/master/samples/highcharts/demo/column-stacked/
     *
     * @param {Array} data Chart data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     */
    smartsenseApp.directive('highchartStackBar', function() {
        return {
            link: function(scope, element) {

                var Chart;

                var options = {};

                scope.setOptions = function() {
                    var elementWidth = element.parent().width();
                    var elementHeight = element.parent().height() || elementWidth;
                    // default options
                    var dateTimeLabelFormats = {
                        millisecond: '%H:%M:%S.%L',
                        second: '%H:%M:%S',
                        minute: '%H:%M',
                        hour: '%H:%M',
                        day: '%e. %b',
                        week: '%e. %b',
                        month: '%b \'%y',
                        year: '%Y'
                    };

                    var options = {
                        chart: {
                            type: 'column',
                            renderTo: element[0],
                            width: elementWidth,
                            height: elementHeight,
                            zoomType: 'x',
                            shadow: false
                        },
                        title: {
                            text: null
                        },
                        xAxis: {
                            type: 'datetime',
                            // minPadding: 0.25,
                            // maxPadding: 0.25,
                            tickmarkPlacement: 'between',
                            tickInterval: 3600 * 1000 * 24,
                            title: {
                                text: null
                            },
                            dateTimeLabelFormats: dateTimeLabelFormats
                        },
                        yAxis: {
                            min: 0,
                            gridLineWidth: 0,
                            minorGridLineWidth: 0,
                            title: {
                                text: null
                            },
                            stackLabels: {
                                enabled: true,
                                verticalAlign: 'top', // Position them vertically in the middle
                                align: 'center',
                                style: {
                                    fontWeight: 'bold',
                                    color: (Highcharts.theme && Highcharts.theme.textColor) || 'gray'
                                },
                                formatter: function() {
                                    return Highcharts.numberFormat(this.total, 2, ',');
                                }
                            }
                        },
                        legend: {
                            enabled: true,
                            layout: 'horizontal',
                            align: 'center',
                            verticalAlign: 'bottom',
                        },
                        credits: {
                            enabled: false
                        },
                        tooltip: {
                            xDateFormat: '%d-%m-%Y %H:%M',
                            valueDecimals: 2,
                            shared: true,
                            headerFormat: '<b>{point.x:%d %b\'%y %H:%M}</b><br/>',
                            pointFormat: '{series.name}: {point.y:.2f}<br/>',
                            footerFormat: '<br/><b>Total: {point.stackTotal:.2f}</b><br/>'
                        },
                        plotOptions: {
                            column: {
                                stacking: 'normal',
                                dataLabels: {
                                    verticalAlign: 'middle', // Position them vertically in the middle
                                    align: 'center',
                                    enabled: true,
                                    formatter: function() {
                                        return this.y.toFixed(2).toString()
                                    },
                                }
                            }
                        },
                        series: [],
                        navigation: {
                            buttonOptions: {
                                verticalAlign: 'bottom',
                                // y: 7,
                                // x: 5,
                                // theme: {
                                //     r: 10,
                                // }
                            }

                        },
                        exporting: {
                            enabled: true
                        }
                    };
                    return options;
                }


                options = scope.setOptions();
                Chart = new Highcharts.Chart(options);

                // create the chart
                scope.$watch('data', function(newVals, oldVals) {

                    options = scope.setOptions();

                    // override default options with values from the scope
                    if (scope.options) {
                        options = utils.MergeRecursive(options, scope.options);
                    }
                    scope.render(newVals);

                }, true);

                scope.render = function(chartDataModel) {

                    if (Chart !== undefined) {
                        Chart.destroy();
                    }

                    options.series = chartDataModel;
                    Chart = new Highcharts.Chart(options);
                    Chart.redraw();

                }
            },
            restrict: 'E',
            scope: {
                data: '=',
                options: '=',
                render: '='
            }
        };
    });

    /**
     * AngularJs directive for highcharts' scattered chart
     * @see http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/demo/scatter/
     *
     * @param {Array} data Chart data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     */
    smartsenseApp.directive('highchartScatteredGraph', function() {
        return {
            link: function(scope, element) {

                var Chart;

                var options = {};

                scope.setOptions = function() {
                    var elementWidth = element.parent().width();
                    var elementHeight = element.parent().height() || elementWidth;
                    // default options
                    var dateTimeLabelFormats = {
                        millisecond: '%H:%M:%S.%L',
                        second: '%H:%M:%S',
                        minute: '%H:%M',
                        hour: '%H:%M',
                        day: '%e. %b',
                        week: '%e. %b',
                        month: '%b \'%y',
                        year: '%Y'
                    };

                    var options = {
                        chart: {
                            type: 'scatter',
                            renderTo: element[0],
                            width: elementWidth,
                            height: elementHeight,
                            zoomType: 'xy',
                            shadow: false
                        },
                        title: {
                            text: null
                        },
                        xAxis: {
                            title: {
                                text: null
                            }
                        },
                        yAxis: {
                            title: {
                                text: null
                            },
                            gridLineWidth: 0.5,
                            gridLineDashStyle: 'longdash'
                        },
                        legend: {
                            enabled: true,
                            layout: 'horizontal',
                            align: 'center',
                            verticalAlign: 'bottom'
                        },
                        credits: {
                            enabled: false
                        },
                        tooltip: {
                            valueDecimals: 2,
                            shared: true
                        },
                        plotOptions: {
                            scatter: {
                                marker: {
                                    radius: 5,
                                    states: {
                                        hover: {
                                            enabled: true,
                                            lineColor: 'rgb(100,100,100)'
                                        }
                                    }
                                },
                                states: {
                                    hover: {
                                        marker: {
                                            enabled: false
                                        }
                                    }
                                }
                            }
                        },
                        series: [],
                        exporting: {
                            sourceWidth: elementWidth,
                            filename: 'smartsense-graph'
                        },
                        navigation: {
                            buttonOptions: {
                                verticalAlign: 'bottom',
                                y: 7,
                                x: 5,
                                theme: {
                                    r: 10,
                                }
                            }
                        },
                    };
                    return options;
                }


                options = scope.setOptions();
                Chart = new Highcharts.Chart(options);

                // create the chart
                scope.$watch('data', function(newVals, oldVals) {

                    options = scope.setOptions();

                    // override default options with values from the scope
                    if (scope.options) {
                        options = utils.MergeRecursive(options, scope.options);
                    }
                    scope.render(newVals);

                }, true);

                scope.render = function(chartDataModel) {

                    if (Chart !== undefined) {
                        Chart.destroy();
                    }

                    options.series = chartDataModel;
                    Chart = new Highcharts.Chart(options);
                    Chart.redraw();

                }
            },
            restrict: 'E',
            scope: {
                data: '=',
                options: '=',
                render: '='
            }
        };
    });


    /**
     * AngularJs directive for highcharts' custom chart
     * @param {Array} data Chart data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     */
    smartsenseApp.directive('highchartVanilla', function() {
        return {
            link: function(scope, element) {

                var Chart;

                var options = {};

                scope.setOptions = function() {
                    var elementWidth = element.parent().width();
                    var elementHeight = element.parent().height() || elementWidth;
                    // default options
                    var dateTimeLabelFormats = {
                        millisecond: '%H:%M:%S.%L',
                        second: '%H:%M:%S',
                        minute: '%H:%M',
                        hour: '%H:%M',
                        day: '%e. %b',
                        week: '%e. %b',
                        month: '%b \'%y',
                        year: '%Y'
                    };

                    var options = {
                        chart: {
                            type: 'area',
                            renderTo: element[0],
                            width: elementWidth,
                            height: elementHeight,
                            zoomType: 'xy',
                            shadow: false
                        },
                        title: {
                            text: null
                        },
                        xAxis: {
                            title: {
                                text: null
                            }
                        },
                        yAxis: {
                            title: {
                                text: null
                            },
                            gridLineWidth: 0.5,
                            gridLineDashStyle: 'longdash'
                        },
                        legend: {
                            enabled: true,
                            layout: 'horizontal',
                            align: 'center',
                            verticalAlign: 'bottom'
                        },
                        credits: {
                            enabled: false
                        },
                        tooltip: {
                            valueDecimals: 2,
                            shared: true
                        },
                        plotOptions: {
                            scatter: {
                                marker: {
                                    radius: 5,
                                    states: {
                                        hover: {
                                            enabled: true,
                                            lineColor: 'rgb(100,100,100)'
                                        }
                                    }
                                },
                                states: {
                                    hover: {
                                        marker: {
                                            enabled: false
                                        }
                                    }
                                }
                            }
                        },
                        series: [],
                        exporting: {
                            sourceWidth: elementWidth,
                            filename: 'smartsense-graph'
                        },
                        navigation: {
                            buttonOptions: {
                                verticalAlign: 'bottom',
                                y: 7,
                                x: 5,
                                theme: {
                                    r: 10,
                                }
                            }
                        },
                    };
                    return options;
                }


                options = scope.setOptions();
                Chart = new Highcharts.Chart(options);

                // create the chart
                scope.$watch('data', function(newVals, oldVals) {

                    options = scope.setOptions();

                    // override default options with values from the scope
                    if (scope.options) {
                        options = utils.MergeRecursive(options, scope.options);
                    }
                    scope.render(newVals);

                }, true);

                scope.render = function(chartDataModel) {

                    if (Chart !== undefined) {
                        Chart.destroy();
                    }

                    options.series = chartDataModel;
                    Chart = new Highcharts.Chart(options);
                    Chart.redraw();

                }
            },
            restrict: 'E',
            scope: {
                data: '=',
                options: '=',
                render: '='
            }
        };
    });


    /**
     * AngularJs directive for highcharts' on off chart
     * @param {Array} data Chart data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     */
    smartsenseApp.directive('highchartOnoff', function() {
        return {
            link: function(scope, element) {

                var Chart;

                var options = {};

                scope.setOptions = function() {
                    var elementWidth = element.parent().width();
                    var options = {
                        chart: {
                            type: 'area',
                            renderTo: element[0],
                            width: elementWidth,
                            zoomType: 'x',
                        },
                        title: '',
                        xAxis: {
                            type: 'datetime'
                        },
                        yAxis: {
                            title: {
                                text: 'No of On Assets'
                            },
                            allowDecimals: false,
                            gridLineWidth: 0.5,
                            gridLineDashStyle: 'longdash'
                        },
                        tooltip: {
                            pointFormatter: function() {
                                var name = this.series.name || "";
                                var value = parseInt(this.y) ? 'On' : 'Off';
                                var color = this.color;
                                return '<span style="color:' + color + '">\u25CF</span> ' + name + ': <b>' + value + '</b> <br/>';
                            },
                            shared: true
                        },
                        plotOptions: {
                            series: {
                                stacking: 'normal',
                                marker: {
                                    enabled: false
                                },
                                step: 'center'
                            }
                        }
                    };
                    return options;
                }

                options = scope.setOptions();
                Chart = new Highcharts.Chart(options);

                // create the chart
                scope.$watch('data', function(newVals, oldVals) {
                    options = scope.setOptions();
                    // override default options with values from the scope
                    if (scope.options) {
                        options = utils.MergeRecursive(options, scope.options);
                    }
                    scope.render(newVals);
                }, true);

                scope.render = function(chartDataModel) {
                    if (Chart !== undefined) {
                        Chart.destroy();
                    }
                    options.series = chartDataModel;
                    Chart = new Highcharts.Chart(options);
                    Chart.redraw();
                }
            },
            restrict: 'E',
            scope: {
                data: '=',
                options: '='
            }
        };
    });


    /**
     * AngularJs directive for highcharts' heatmap chart
     * @see http://jsfiddle.net/gh/get/jquery/3.1.1/highslide-software/highcharts.com/tree/master/samples/highcharts/demo/heatmap-canvas/
     *
     * @param {Array} data Chart data
     * @param {Object} options Chart configuration
     * @author Master Wayne (hardiksondagar)
     */
    smartsenseApp.directive('highchartHeatmap', function() {
        return {
            link: function(scope, element) {

                var Chart;

                var options = {};

                scope.setOptions = function() {

                    var elementWidth = element.parent().width();

                    var options = {
                        chart: {
                            type: 'heatmap',
                            renderTo: element[0],
                            width: elementWidth,
                            zoomType: 'x',
                            shadow: false,
                            inverted: true
                        },
                        xAxis: {
                            type: 'datetime',
                            tickPixelInterval: 1,
                            lineWidth: 0,
                            minorGridLineWidth: 0,
                            lineColor: 'transparent',
                            minorTickLength: 0,
                            tickLength: 0
                        },
                        credits: {
                            enabled: false
                        },
                        title: {
                            text: null
                        },
                        legend: {
                            title: {
                                text: null
                            }
                        },
                        yAxis: {
                            title: {
                                text: null
                            },
                            labels: {
                                formatter: function() {
                                    var minutes = (this.value) * 15;
                                    var realmin = minutes % 60;
                                    var hours = Math.floor(minutes / 60);
                                    if (hours < 10) {
                                        hours = "0" + hours;
                                    }
                                    if (realmin < 10) {
                                        realmin = "0" + realmin;
                                    }
                                    return hours + ':' + realmin;
                                }
                            },
                            minPadding: 0,
                            maxPadding: 0,
                            startOnTick: false,
                            endOnTick: false,
                            tickWidth: 1,
                            min: 0,
                            max: 95,
                            gridLineColor: 'transparent'
                        },
                        colorAxis: {
                            stops: [
                                [0, '#1a9850'],
                                [0.5, '#fffbbc'],
                                [0.9, '#f6200b']
                            ],
                            gridLineWidth: 1,
                            gridLineColor: 'white',
                            minorTickInterval: 0.1,
                            minorGridLineColor: 'white',
                            tickLength: 0,
                            borderRadius: 1
                        },
                        navigation: {
                            buttonOptions: {
                                verticalAlign: 'bottom',
                                y: -20
                            }
                        },
                        tooltip: {
                            valueDecimals: 2,
                            headerFormat: '',
                            pointFormat: '<small>{point.timestamp:%A, %b %e, %H:%M}</small><br>Value: <b>{point.original:0.2f} {point.suffix}</b>'
                        },
                        series: [{
                            borderWidth: 0.1,
                            borderColor: '#fff',
                            turboThreshold: 10000,
                            nullColor: '#eef1f5',
                            colsize: 24 * 36e5, // one day

                        }]
                    };
                    return options;
                }


                options = scope.setOptions();
                Chart = new Highcharts.Chart(options);

                // create the chart
                scope.$watch('data', function(newVals, oldVals) {

                    if (newVals) {
                        options = scope.setOptions();

                        // override default options with values from the scope
                        if (scope.options) {
                            options = utils.MergeRecursive(options, scope.options);
                        }
                        scope.render(newVals);
                    }

                }, true);

                // create the chart
                scope.$watch('options', function(newVals, oldVals) {

                    if (newVals) {
                        options = scope.setOptions();

                        // override default options with values from the scope
                        options = utils.MergeRecursive(options, newVals);
                        scope.render(scope.data);
                    }

                }, true);

                scope.render = function(chartDataModel) {

                    if (Chart !== undefined) {
                        Chart.destroy();
                    }

                    options.series[0].data = chartDataModel;
                    Chart = new Highcharts.Chart(options);
                    Chart.redraw();

                }
            },
            restrict: 'EA',
            scope: {
                data: '=',
                options: '='
            }
        };
    });




}());
smartsenseApp.controller("LoginController", ['$rootScope' ,'$scope', '$location', '$state', 'Session' ,'local', 'focus', '$rootScope', 'loading', '$timeout', '$stateParams', 'authService', 'apiService', 'menuService', function ($rootScope, $scope, $location, $state, Session, local, focus, $rootScope, loading, $timeout, $stateParams, authService, apiService, menuService) {

    $scope.login = {
        username:null,
        password:null,
        remember:false,
        loginPage:true,
        isValidated:true,
        requireMessage:''
    };

    $scope.forgotPassword = {
        email:'',
        isValidated:true,
        requireMessage:''
    };

    $scope.resetPassword = {};
    
    if ($stateParams["token"].indexOf("token=") == 0) {
        $scope.login.loginPage = false;
        $scope.resetPassword.show = true;
        authService.logout();
    }

    local.data = local.data || {};

    $scope.isLoggedIn = function() {
        if(authService.isAuthenticated()){
            defaultPage = Session.get('member_services')[0].url;
            $state.go(menuService.URLMapping[defaultPage].sref);
        }
    }

    $scope.isLoggedIn();

    $scope.doLogin = function() {
        $scope.isLogging = true;
        $scope.login.isValidated = true;
        authService.login({
            username: $scope.login.username,
            password: $scope.login.password
        }).then(function(data) {
            $scope.isLogging = false;
            var defaultLandingPage = Session.get('member_services')[0].url;
            $state.go(menuService.URLMapping[defaultLandingPage].sref);
        }, function(response) {
            $scope.isLogging = false;
            $scope.login.isValidated = false;
            if (response.data) {
                $scope.login.requireMessage = response.data.message || "Wrong UserName or Password Entered.";
            } else {
                $scope.login.requireMessage = "Problem while connecting to the server, please try again.";
            }
        });
    };

    $scope.logout = function() {
        authService.logout();
        var token = $stateParams["token"] || "SmartSense";
            $state.go("page.login", {
                token: token
        });
    }


    $scope.openForgotPasswordPopup = function() {
        $scope.login.loginPage = false;
        $scope.forgotPassword.show = true;
        $scope.resetPassword.show = false;
    };

    $scope.showLoginPanel = function(reload) {
        $scope.login.loginPage = true;
        $scope.forgotPassword.show = false;
        $scope.forgotPassword.multipleSelectOptionToSendLink = false;
        $scope.forgotPassword.selectToSendEmail = false;
        $scope.forgotPassword.selectToSendMobile = false;
        $scope.forgotPassword.username = "";
        $scope.resetPassword.show = false;
        if (reload) {
            $state.go("page.login", {
                token: "SmartSense"
            });
        }
    };

    $scope.submitSetPassword = function() {
        var pass1 = $.trim($scope.resetPassword.pass1);
        var pass2 = $.trim($scope.resetPassword.pass2);
        if (!pass1 || !pass2) {
            $scope.resetPassword.requireMessage = "Please enter password to reset";
        } else if (pass1 != pass2) {
            $scope.resetPassword.requireMessage = "Passwords does not match";
        } else {
            $scope.resetPassword.requireMessage = "";
            loading(true);
            var params = {
                token:$stateParams["token"],
                newpassword1: pass1,
                newpassword2: pass2
            }
            apiService.auth_password_reset(params).then(function(response) {
                loading(false);
                var msg = response.data.Sucess || response.data.message || "Password updated";
                setTimeout(function() {
                    bootbox.alert(msg);
                }, 100);
                $scope.showLoginPanel();
                $state.go("page.login", {
                    token: "SmartSense"
                });
            }, function(response) {
                loading(false);
                var msg = response.data.message || "There is some problem while updating password, please try again";
                setTimeout(function() {
                    bootbox.alert(msg);
                }, 200);
            });
        }
    }

    $scope.submitResetPassword = function(selection) {
        if (selection) {
            if (!$scope.forgotPassword.selectMobile && !$scope.forgotPassword.selectEmail) {
                setTimeout(function() {
                    bootbox.alert("Please select option to send reset password instructions to");
                }, 100);
                return false;
            } else {
                loading(true);
                var params = {
                    mobilenumber:$scope.forgotPassword.selectToSendMobile,
                    emailid:$scope.forgotPassword.selectToSendEmail
                }
                apiService.auth_password_reset_request(params).then(function(response) {
                    loading(false);
                    var msg = response.data.Sucess;
                    setTimeout(function() {
                        bootbox.alert(msg, function() {});
                    }, 100);
                    $scope.showLoginPanel();
                }, function() {
                    loading(false);
                    setTimeout(function() {
                        bootbox.alert("There is some problem while sending instructions, please try again");
                    }, 100);
                });
            }
        } else {
            if (!$scope.forgotPassword.username || $scope.forgotPassword.username.trim() == '') {
                $scope.forgotPassword.isValidated = false;
                $scope.login.isValidated = true;
                $scope.login.requireMessage = "";
                $scope.forgotPassword.requireMessage = "Username is required."
            } else {
                $scope.forgotPassword.isValidated = true;
                loading(true);
                var params = {
                    username: $scope.forgotPassword.username
                }
                apiService.auth_password_reset_request(params).then(function(response) {
                    $scope.forgotPassword.isValidated = true;
                    if (response.data.emailid && response.data.mobilenumber) {
                        $scope.forgotPassword.multipleSelectOptionToSendLink = true;
                        $scope.forgotPassword.selectToSendEmail = response.data.emailid;
                        $scope.forgotPassword.selectToSendMobile = response.data.mobilenumber;
                        $scope.forgotPassword.selectMobile = $scope.forgotPassword.selectEmail = false;
                        loading(false);
                    } else if (response.data.emailid) {
                        var params = {
                            emailid:response.data.emailid
                        }
                        apiService.auth_password_reset_request(params).then(function(response) {
                            loading(false);
                            var msg = response.data.Sucess;
                            setTimeout(function() {
                                bootbox.alert(msg);
                            }, 100);
                            $scope.showLoginPanel();
                        }, function() {
                            loading(false);
                            setTimeout(function() {
                                bootbox.alert("There is some problem while sending email, please try again");
                            }, 100);
                        });
                    } else if (response.data.mobilenumber) {
                     var params = {
                        mobilenumber:response.data.mobilenumber
                    }
                    apiService.auth_password_reset_request(params).then(function(response) {
                        loading(false);
                        var msg = response.data.Sucess;
                        setTimeout(function() {
                            bootbox.alert(msg);
                        }, 100);
                        $scope.showLoginPanel();
                    }, function() {
                        loading(false);
                        setTimeout(function() {
                            bootbox.alert("There is some problem while sending sms, please try again");
                        }, 100);
                    });
                } else {
                    loading(false);
                    $scope.forgotPassword.isValidated = false;
                    $scope.forgotPassword.requireMessage = "User " + $scope.forgotPassword.username + " does not exist.";
                }
            }, function() {
                loading(false);
                $scope.forgotPassword.isValidated = false;
                $scope.forgotPassword.requireMessage = "User " + $scope.forgotPassword.username + " does not exist.";
            });
            }
        }
    };

    $scope.closeErrorPopup = function(popup) {
        if (popup == "login") {
            $scope.login.isValidated = true;
        } else if (popup == "forgotPassword") {
            $scope.forgotPassword.isValidated = true;
        }
    };
    $('.messagebox').hide();

}]);

smartsenseApp.controller("MyDashboardController", ['$scope', '$timeout', 'local', 'apiService', 'widget_list', function($scope, $timeout, local, apiService, widget_list) {
    $scope.localData = local.data;
    $scope.widgetlist = widget_list.data;
    angular.forEach($scope.widgetlist, function(value, key) {
        $scope.widgetlist[key].size = value.config.size;
        $scope.widgetlist[key].title = value.config.meta.name;
        $scope.widgetlist[key].tooltip = value.config.meta.description;
    });
}]);
smartsenseApp.controller('ReportsController', ReportsController);

ReportsController.$inject = ['$scope', 'loading', '$timeout', '$state', '$uibModal', 'NgTableParams', 'apiService', 'local', 'reportsService', 'Analytics'];

function ReportsController($scope, loading, $timeout, $state, $uibModal, NgTableParams, apiService, local, reportsService, Analytics) {

    $scope.localData = local.data;
    $scope.isLoading = {
        configs: false
    }

    // Report Configuration

    var initialParams = {
        count: 10, // initial page size,
        sorting: { ModifiedTimestamp: "desc" }
    };
    var initialSettings = {
        // page size buttons (right set of buttons in demo)
        counts: [],
        // determines the pager buttons (left set of buttons in demo)
        paginationMaxBlocks: 4,
        paginationMinBlocks: 2,
        dataset: []
    };

    $scope.getReportConfigs = function() {
        $scope.isLoading.configs = true;
        apiService.report_list().success(function(data) {
            initialSettings.dataset = data;
            $scope.reportConfigsTableParams = new NgTableParams(initialParams, initialSettings);
        }).catch(function(error) {}).finally(function() {
            $scope.isLoading.configs = false;
        })
    }

    $scope.deleteReport = function(SpreadSheetId) {

        bootbox.confirm("Are you sure you want to delete report?", function(result) {
            if (result) {
                var params = {
                    SpreadSheetId: SpreadSheetId
                };
                loading(true)
                apiService.report_delete(params).then(function(response) {
                    $scope.getReportConfigs();
                    loading(false);
                }, function(error) {
                    console.error(error);
                    loading(false);
                })
            }
        });
    };

    $scope.showConfigReportModal = function(config) {
        var modalInstance = $uibModal.open({
            templateUrl: 'components/reports/reportsConfigModal.tpl.html',
            controller: 'ReportConfigModalController',
            backdrop: true,
            size: 'lg',
            resolve: {
                reportConfig: function() {
                    return config;
                }
            }
        });
        modalInstance.result.then(function() {
            $scope.getReportConfigs();
        }, function() {});
    };


    $scope.downloadConfigReport = function(config) {
        var modalInstance = $uibModal.open({
            templateUrl: 'components/reports/reportsConfigDownloadModal.tpl.html',
            controller: 'ReportConfigDownloadModalController',
            backdrop: true,
            size: 'md',
            resolve: {
                reportConfig: function() {
                    return config;
                }
            }
        });
        modalInstance.result.then(function() {
            console.log('downloaded');
        }, function() {});
    };

    // Report Download

    $scope.disableDownload = false;
    $scope.groupparameters = reportsService.getGroupParameter();
    $scope.allowedLocations = reportsService.allowedLocations;
    $scope.allowedParameters = angular.copy(reportsService.allowedParameters);
    $scope.allowedFormats = reportsService.allowedFormats;
    $scope.allowedIntervals = reportsService.allowedIntervals;
    $scope.allowedParameterType = reportsService.allowedParameterType;
    $scope.allowedDaysforDownload = reportsService.allowedDaysforDownload;

    $scope.report = new reportsService.Report();
    $scope.report.email = $scope.localData.member.email;

    $scope.locations = [];

    angular.forEach($scope.localData.locationlist, function(location) {
        if (location.virtual) {
            location.type = 'L';
            location.name = location.name + '*';
            $scope.locations.push(location);
        }
    });

    // Add assets to location list
    angular.forEach($scope.localData.sensors, function(sensor) {
        sensor.type = 'S';
        sensor.parentlocationid = $scope.localData.locations[sensor.mappedlocationid].parentlocationid;
        sensor.messageversions = [sensor.messageversion];
        $scope.locations.push(sensor);
    });

    $scope.getOccurent = function(string) {
        if (!string || typeof string == 'undefined' || string == '') {
            return -1;
        }
        return string.split(',').length;
    }

    $scope.groupLocation = function(item) {
        if (item.parentlocationid && $scope.localData.locations[item.parentlocationid]) {
            return $scope.localData.locations[item.parentlocationid].name;
        } else {
            return 'Main Locations';
        }
    };

    $scope.groupParameter = function(item) {
        if (item.parentreadingtypeid && $scope.localData.readingtypes[item.parentreadingtypeid]) {
            return $scope.localData.readingtypes[item.parentreadingtypeid].readingtypename;
        } else {
            return undefined;
        }
    };

    /* This function will be called on date range value change */
    /* 1. If Date difference is more than 10 days, disable the download button */
    /* 2. If Date difference is more than 90 days, down the allowed parameter to 5 instead of 30 */
    $scope.onTimeSet = function() {
        if ($scope.report.fromDate && $scope.report.toDate) {
            var fromDate = new moment($scope.report.fromDate);
            var toDate = new moment($scope.report.toDate);
            var duration = moment.duration(toDate.diff(fromDate));
            var days = duration.asDays();
            if (days > 90 && days < 365) {
                bootbox.alert('For more than 90 days selection maximum no. of parameters allowed is 5.');
                if ($scope.report.IndividualParameters.length > 5) {
                    $scope.report.IndividualParameters = [];
                }
                if ($scope.report.GroupParameters.length > 5) {
                    $scope.report.GroupParameters = [];
                }
                $scope.allowedParameters = 5;
            } else {
                $scope.allowedParameters = angular.copy(reportsService.allowedParameters);
            }

            // to show message when date range exceeded more than 365 days by nirali.patel
            if (days > 365) {
                bootbox.alert('Date range should not be more than a year. Please select date range for less than 365 days.');
            }
            if (days > $scope.allowedDaysforDownload) {

                $scope.disableDownload = true;
            } else {
                $scope.disableDownload = false;
            }
            Analytics.trackEvent('Report', 'Date Range Updated : ' + fromDate.format("DD/MM/YYYY hh:mm:ss a") + ' - ' + toDate.format("DD/MM/YYYY hh:mm:ss a"), $state.current.name);
        }
    }

    $scope.$watch('report.parameterType', function(newVal, oldVal) {
        if (newVal != oldVal) {
            if (newVal == 'Individual') {
                $scope.report.GroupParameters = [];
            } else if (newVal == 'Group') {
                $scope.report.IndividualParameters = [];
            }
        }
    }, true);

    /* On reportFormat 'CSV' reset the aggregation option */
    $scope.$watch('report.reportFormat', function(newVal, oldVal) {
        if (newVal == 'CSV') {
            $scope.report.aggregation = false;
        }
    }, true);


    $scope.SendReport = function() {
        loading(true);
        apiService.report_send($scope.report).then(function(response) {
            loading(false);
            $timeout(function() {
                bootbox.alert("Thank you for using Smartsense Insights. Your report with request id " + response.data.requestid + " will be delivered to your given email id within 4 hours.");
            }, 2000);
        }, function() {
            loading(false);
            bootbox.alert("Some error occured, Please try again");
        });
    }


    $scope.submit = function(reportParamter, form) {
        if (reportParamter.isDownload) {
            $scope.DownloadReport();
            Analytics.trackEvent('Report', 'Report Downloaded : ' + JSON.stringify(reportParamter), $state.current.name);
        } else {
            bootbox.confirm("Are you sure you want to send specified report to :<br>" + $scope.report.email.split(",").join("<br>") + "", function(result) {
                if (result) {
                    $scope.SendReport();
                    Analytics.trackEvent('Report', 'Report requested via email : ' + JSON.stringify(reportParamter), $state.current.name);
                }
            });
        }
    }


    $scope.DownloadReport = function() {
        loading(true);
        var reportFormat = $scope.report.reportFormat;
        apiService.report_download($scope.report).then(function(response) {
            loading(false);
            var exts = $scope.report.reportFormat == "Excel" ? 'xls' : 'csv';
            var reportName = "report_" + moment().valueOf();
            utils.saveAs(response.data, exts, reportName);
            $timeout(function() {
                bootbox.alert("Thank you for using Smartsense Insights. Your report has been downloaded.");
            }, 2000);
        }, function() {
            loading(false);
        });
    }

    /* Following functions binds with the date change. Responsible for enabling/disabling dates according to selected startDate/endDate of report */

    $scope.endDateBeforeRender = endDateBeforeRender
    $scope.endDateOnSetTime = endDateOnSetTime
    $scope.startDateBeforeRender = startDateBeforeRender
    $scope.startDateOnSetTime = startDateOnSetTime

    function startDateOnSetTime() {
        $scope.onTimeSet();
        $scope.$broadcast('start-date-changed');
    }

    function endDateOnSetTime() {
        $scope.onTimeSet();
        $scope.$broadcast('end-date-changed');
    }

    function startDateBeforeRender($dates) {
        var activeDate = null;
        var currentDate = new moment();
        if ($scope.report.toDate) {
            activeDate = moment($scope.report.toDate);
        }
        $dates.filter(function(date) {
            /* date.localDateValue() >= currentDate.valueOf() thing disables the future dates */
            return date.localDateValue() >= currentDate.valueOf() || (activeDate && date.localDateValue() >= activeDate.valueOf())
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    function endDateBeforeRender($view, $dates) {
        var activeDate = null;
        var currentDate = new moment();
        if ($scope.report.fromDate) {
            activeDate = moment($scope.report.fromDate);
        }
        $dates.filter(function(date) {
            /* date.localDateValue() >= currentDate.valueOf() thing disables the future dates */
            if ($view == 'minute') {
                return date.localDateValue() >= currentDate.valueOf() || (activeDate && date.localDateValue() <= activeDate.valueOf())
            } else {
                return date.localDateValue() >= currentDate.valueOf() || (activeDate && activeDate.clone().subtract(1, $view).valueOf() >= date.localDateValue())
            }
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    $scope.reload = function() {
        $state.reload();
    }

}

smartsenseApp.controller('ReportConfigModalController', ReportConfigModalController);
ReportConfigModalController.$inject = ['$scope', '$uibModalInstance', 'apiService', 'local', 'grainService', 'loading', 'reportsService', 'reportConfig'];

function ReportConfigModalController($scope, $uibModalInstance, apiService, local, grainService, loading, reportsService, reportConfig) {

    $scope.localData = local.data;
    $scope.options = reportsService.ReportConfigOptions;
    $scope.isSubmitting = false;

    if (reportConfig) {
        reportConfig.SensorIdList = reportConfig.SensorIds.split(',').map(Number);
        $scope.reportConfig = angular.copy(reportConfig);
    } else {
        $scope.reportConfig = new reportsService.ReportConfig();
        $scope.reportConfig.MailTo = $scope.localData.member.email;
    }

    $scope.isEdit = !!$scope.reportConfig.SpreadSheetId;

    $scope.configReport = function(reportConfig) {
        $scope.isSubmitting = true;
        reportConfig.SensorIds = reportConfig.SensorIdList.toString();
        if (reportConfig.ReportFrequency == "Daily") {
            reportConfig.ReportFireOn = reportConfig.StartTime + 1;
            reportConfig.ReportFireOn = reportConfig.ReportFireOn % 24;
        } else if (reportConfig.ReportFireOn === null) {
            reportConfig.ReportFireOn = $scope.options.ReportFireOn[reportConfig.ReportFrequency][0].value;
        }
        apiService.report_config(reportConfig).then(function(response) {}).catch(function(e) {
            console.error(e);
        }).finally(function() {
            $scope.isSubmitting = false;
            $uibModalInstance.close();
        });
    };

    $scope.cancel = function() {
        $uibModalInstance.dismiss('cancel');
    };

}

smartsenseApp.controller('ReportConfigDownloadModalController', ReportConfigDownloadModalController);
ReportConfigDownloadModalController.$inject = ['$scope', '$uibModalInstance', 'apiService', 'local', 'loading', 'reportsService', 'reportConfig'];

function ReportConfigDownloadModalController($scope, $uibModalInstance, apiService, local, loading, reportsService, reportConfig) {

    $scope.localData = local.data;
    $scope.reportConfig = angular.copy(reportConfig);

    var frequencies = { "Daily": 'days', "Weekly": 'weeks', "Monthly": 'months' };
    var frequency = $scope.reportConfig.ReportFrequency;
    var unitOfTime = frequency in frequencies ? frequencies[frequency] : 'days';

    $scope.reportConfig.dateRange = {
        startDate: moment().subtract(1, unitOfTime).add(1, 'days'),
        endDate: moment()
    };

    $scope.reportConfig.SensorIdList = reportConfig.SensorIds.split(',').map(Number);
    $scope.sensorsDisplayLimit = 5;
    $scope.dateRangeOpts = {
        parentEl: ".modal",
        locale: {
            format: 'DD/MM/YYYY'
        },
        opens: "up",
        autoApply: true,
        singleDatePicker: true,
        maxDate: moment(),
        eventHandlers: {
            'apply.daterangepicker': function(ev, picker) {
                $scope.reportConfig.dateRange.endDate = $scope.reportConfig.dateRange.startDate.clone().add(1, unitOfTime).subtract(1, 'days');
            }
        }
    };

    $scope.downloadConfigReport = function(reportConfig) {
        $scope.isSubmitting = true;
        reportConfig = angular.copy(reportConfig);
        reportConfig.dateRange.startDate.startOf('day').hours(reportConfig.StartTime);
        reportConfig.dateRange.endDate.startOf('day').add(1, 'days').hours(reportConfig.StartTime);
        apiService.report_config_download(reportConfig)
            .success(function(data) {
                var exts = reportConfig.ReportFormat;
                var reportName = "report_" + reportConfig.ReportName + '_' + reportConfig.ReportFrequency + '_' + moment().valueOf();
                utils.saveAs(data, exts, reportName);
            })
            .error(function(error) {
                console.error(error);
            })
            .finally(function() {
                $scope.isSubmitting = false;
                $uibModalInstance.close();
            });
    };

    $scope.cancel = function() {
        $uibModalInstance.dismiss('cancel');
    };

}
smartsenseApp.factory('reportsService', reportsService);

reportsService.$inject = [];

function reportsService() {

    var allowedLocations = 20;
    var allowedParameters = 30;
    var allowedDaysforDownload = 10;
    var allLocations;
    var mainlocations = [];
    var alldata = [];
    var allowedFormats = ['Excel', 'CSV'];
    var allowedIntervals = [{
        label: '15 min',
        value: 15
    }, {
        label: '30 min',
        value: 30
    }, {
        label: '60 min',
        value: 60
    }, {
        label: '1 day',
        value: 1440
    }];

    var allowedParameterType = ['Individual', 'Group'];

    var _hours = [];
    for (var i = 0; i < 24; i++) {
        _hours.push({
            value: i,
            label: i + ':00'
        });
    };


    moment()._locale._week.dow = 0;

    var _weekDays = [];
    ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"].forEach(function(day, index) {
        _weekDays.push({
            label: day,
            value: index
        });
    });

    var _monthDays = [];
    for (var i = 1; i < 32; i++) {
        _monthDays.push({
            label: i,
            value: i
        });
    };

    var _days = moment.weekdays();

    var ReportConfigOptions = {
        'ReportFormats': ["xlsx", "xls"],
        'Grains': [15, 30, 60, 1440],
        'ReportFrequencies': ["Daily", "Weekly", "Monthly"],
        'Hours': _hours,
        'ReportFireOn': {
            'Weekly': _weekDays,
            'Monthly': _monthDays
        }
    };

    var service = {
        allowedLocations: allowedLocations,
        allowedParameters: allowedParameters,
        allowedDaysforDownload: allowedDaysforDownload,
        allowedFormats: allowedFormats,
        allowedIntervals: allowedIntervals,
        allowedParameterType: allowedParameterType,
        getGroupParameter: getGroupParameter,
        Report: Report,
        ReportConfig: ReportConfig,
        ReportConfigOptions: ReportConfigOptions
    }

    return service;

    ////////////////////////////


    function getGroupParameter() {
        var groupParameters = [{
            reportgroupid: 101,
            reportgroupname: "kWh",
            defaultvalue: 't'
        }, {
            reportgroupid: 105,
            reportgroupname: "kWh & kVAh",
            defaultvalue: 't'
        }, {
            reportgroupid: 102,
            reportgroupname: "Power Parameters",
            defaultvalue: 't'
        }, {
            reportgroupid: 104,
            reportgroupname: "Phase Wise",
            defaultvalue: 't'
        }, {
            reportgroupid: 117,
            reportgroupname: "Counter kWH & kVAh",
            defaultvalue: 't'
        }, {
            reportgroupid: 118,
            reportgroupname: "PLC Report",
            defaultvalue: 't'
        }];
        return groupParameters;
    }


    function Report() {
        this.locations = [];
        this.fromDate = moment().startOf('day');
        this.toDate = moment().hour(23).minute(45).second(0).millisecond(0);
        this.IndividualParameters = [];
        this.GroupParameters = [];
        this.aggregation = false;
        this.reportFormat = allowedFormats[0];
        this.grain = allowedIntervals[0].value;
        this.parameterType = allowedParameterType[0];
    }

    function ReportConfig() {
        this.ReportName = "";
        this.SensorIds = "";
        this.SensorIdList = [];
        this.Grain = 15;
        this.ReportFormat = "xlsx";
        this.StartTime = 0;
        this.ReportFireOn = null;
        this.ReportFrequency = "Daily";
        this.Delivery = "Email";
        this.MailTo = "";
        this.Enabled = false;
    }

}
smartsenseApp.controller('AlertController', AlertController);

AlertController.$inject = ['$scope', '$filter', '$q', '$state', '$stateParams', 'apiService' ,'alertService', 'sensors', 'loading', '$state', 'Analytics'];

function AlertController($scope, $filter, $q, $state, $stateParams, apiService, alertService, sensors, loading, $state, Analytics) {

    $scope.daysOption = alertService.daysOption;
    $scope.durationOption = alertService.durationOption;
    $scope.repeatOption = alertService.repeatOption;

    $scope.allowedMobiles = alertService.allowedMobiles;
    $scope.allowedEmails = alertService.allowedEmails;

    $scope.getOccurent = function(string) {
        if (!string || typeof string == 'undefined' || string == '') {
            return -1;
        }
        return string.split(',').length;
    }

    $scope.getCommaSeparated = function(str) {
        if(!str)
            return [];
        return str.split(',');
    }

    /* Variable declaration and method initialization */

    /* Raw sensor and readingtype list */
    $scope.sensors = sensors.data;
    $scope.readingTypeList = [];

    /* In simple alert, default standard readingtype list */
    $scope.readingTypeDefaultList = [];

    $scope.sensorReadingTypes = {};

    /* In simple alert, $scope.singleSensorReadingTypeList will contain readingtype list based on current selected sensor ( on sensor value change, readingtype list will change ) */
    $scope.singleSensorReadingTypeList = [];


    /* In simple alert this variable will keep track of which condition is currently selected, standard or custom */
    $scope.defaultReadingTypeListLength = 0;

    /* In complex alert, maximum number of condition and maximum number of sensor / condition value */
    $scope.allowedSensors = alertService.allowedSensors;
    $scope.allowedConditions = alertService.allowedConditions;

    /* In complex alert, this variable will contain readingtype list based on current selected sensors in particular condition */
    $scope.multipleSensorReadingTypeList = {};

    $scope.allowedHours = alertService.getHours();
    $scope.allowedMinutes = alertService.getMinutes();

    // Filter to get object using Id

    $scope.getAlertFromId = function(alertid) {
        return $filter('filter')($scope.alerts, function(alert) {
            return alert.alertid === alertid;
        })[0];
    };

    $scope.getEventFromId = function(eventid) {
        return $filter('filter')($scope.events, function(event) {
            return event.eventid === eventid;
        })[0];
    };

    $scope.getSensorNameFromId = function(sensorid) {
        return $filter('filter')($scope.sensors, function(sensor) {
            return sensor.sensorid === sensorid;
        })[0];
    };

    $scope.getReadingTypeFromId = function(readingtypeid) {
        return $filter('filter')($scope.readingTypeList, function(readingType) {
            return readingType.readingtypeid === readingtypeid;
        })[0];
    };

    /* Set default readingtype list for simple alert */
    $scope.initReadingTypeDefaultList = function() {

        var MDBreach = {
            readingtypeid: 2002,
            readingtypename: 'M.D. Breach (kW)',
            options: [{
                label: '>',
                value: 1
            }]
        };

        var PFPenalty = {
            readingtypeid: 2006,
            readingtypename: 'P.F. Penalty',
            options: [{
                label: '<',
                value: 2
            }]
        };

        $scope.readingTypeDefaultList = [MDBreach, PFPenalty];
        $scope.defaultReadingTypeListLength = $scope.readingTypeDefaultList.length;

    };

    /* Sensor and ReadingTypes operations */

    $scope.fetchSensorReadingTypes = function(sensorId) {

        var deferred = $q.defer();


        if (typeof $scope.sensorReadingTypes[sensorId] == 'undefined') {
            apiService.readingtype({sensorid:sensorId}).then(function(data) {
                if (data && typeof data.data != "undefined") {
                    $scope.addReadingTypes(data.data);
                    $scope.addReadingTypesToSensor(sensorId, data.data);
                    deferred.resolve();
                } else {
                    deferred.reject();
                }
            });
        } else {
            deferred.resolve();
        }

        return deferred.promise;

    };


    $scope.addReadingTypes = function(readingTypeList) {
        angular.forEach(readingTypeList, function(readingType, key) {
            if (!$scope.getReadingTypeFromId(readingType.readingtypeid)) {
                $scope.readingTypeList.push(readingType);
            }
        });

    };

    $scope.addReadingTypesToSensor = function(sensorid, readingTypeList) {
        $scope.sensorReadingTypes[sensorid] = [];
        angular.forEach(readingTypeList, function(readingType, key) {
            $scope.sensorReadingTypes[sensorid].push(readingType.readingtypeid);
        });
    };

    $scope.getSensorReadingTypes = function(sensorid) {
        var list = [];
        angular.forEach($scope.sensorReadingTypes[sensorid], function(readingType) {
            list.push($scope.getReadingTypeFromId(readingType));
        });
        return list;
    };



    $scope.init = function() {
        $scope.initAddOrEdit();
        loading(false);
    };

    $scope.isEditAlert = false;

    $scope.initAddOrEdit = function() {
        if ($stateParams.alertId) {
            $scope.initEditAlert();
        } else {
            $scope.initAddAlert();
        }
    }

    $scope.initAddAlert = function() {
        $scope.isEditAlert = false;
        $scope.alert = new alertService.Alert();
    };

    /* Get set time for current date from colon seperated time ( 12:00 HH:mm format )*/
    $scope.setTime = function(time) {

        var day = moment();

        time = time.split(':');
        day.set({
            hours: time[0],
            minutes: time[1]
        });

        return day;

    }

    $scope.initEditAlert = function() {

        $scope.isEditAlert = true;
        loading(true);
        apiService.alert_get($stateParams.alertId).then(function(data) {
            var data = data.data;
            data.alertId = data.alertid;
            data.alertCategory = data.alertcategory;
            data.readingType = data.readingtypeid;
            data.thresholdValue = data.thresholdvalue;
            data.thresholdDuration = data.thresholdduration;
            data.mobileNum = data.mobilenum;
            data.startTime = data.starttime;
            data.endTime = data.endtime;
            data.expression = data.expression ? data.expression : '';
            if (data.alertCategory == 'complex') {
                data.thresholdValue = 0;
                data.readingType = null;
                data.sensor = null;
            }
            $scope.alert = new alertService.Alert();
            angular.forEach($scope.alert, function(alertProperty, key) {
                if (typeof data[key] != 'undefined') {
                    $scope.alert[key] = data[key] ? data[key] : '';
                }
            });

            var startTime = alertService.timeToLocal(data.startTime);
            $scope.alert.startHour = startTime.HH;
            $scope.alert.startMin = startTime.mm;

            var endTime = alertService.timeToLocal(data.endTime);
            $scope.alert.endHour = endTime.HH;
            $scope.alert.endMin = endTime.mm;

            $scope.alert.sensor = data.sensorid;
            loading(false);
        }, function(error) {
            loading(false);
            $state.transitionTo('home.alert');
        });
    }

    $scope.initEvent = function() {

        $scope.isEditEvent = false;

        if ($stateParams.eventId) {
            $scope.initEditEvent($stateParams.eventId);

        } else {
            $scope.initAddEvent();
        }
    };

    $scope.initAddEvent = function() {
        $scope.event = new alertService.Event();
        $scope.event.sensorId = $scope.sensors[0].sensorid;
    }

    $scope.initEditEvent = function(eventid) {

        loading(true);
        apiService.event_get(eventid).then(function(data) {
            $scope.event = data.data;
            $scope.event.eventId = $scope.event.eventid;
            $scope.event.eventName = $scope.event.eventname;
            $scope.event.eventDetails = $scope.event.eventdetails;
            $scope.event.sensorId = $scope.event.sensorid;
            $scope.event.dateOfEvent = moment($scope.event.timestamp);
            loading(false);
            $scope.isEditEvent = true;
        }, function() {
            loading(false);
            $scope.isEditEvent = false;
            $state.transitionTo('home.alert');
        });

    }

    $scope.deleteComplexCondition = function(conditionIndex) {
        if (typeof $scope.alert.complexConditions[conditionIndex] != "undefined") {
            $scope.alert.complexConditions.splice(conditionIndex, 1);
        }
    }

    $scope.deleteSensorFromComplexCondition = function(conditionIndex, sensorIndex) {
        if (typeof $scope.alert.complexConditions[conditionIndex] != "undefined" && typeof $scope.alert.complexConditions[conditionIndex].sensors[sensorIndex] != "undefined" ) {
            $scope.alert.complexConditions[conditionIndex].sensors.splice(sensorIndex, 1);
        }
    }

    $scope.resetAlert = function() {
        $scope.alert = new alertService.Alert();
    };

    $scope.resetEvent = function() {
        $scope.event = new alertService.Event();
    };

    $scope.loadAlerts = function() {
        loading(true);
        apiService.alert_list().then(function(data) {
            $scope.alerts = data.data.system_alerts;
            $scope.events = data.data.user_defined_alerts;
            setTimeout(function() {
                $('[data-toggle="tooltip"]').tooltip({
                    trigger : 'hover'
                }).on('click', function () {
                    $(this).tooltip('hide')
                });
                loading(false);
            }, 1000);
        });
    };

    /**
     * This function will be called on duration value change and it'll update thresholdDuration's value because we * have validation repeat option cannot be less than the duration value
     */
     $scope.$watch('alert.duration', function(newValue, oldValue) {
        if (newValue) {
            if ($scope.alert.thresholdDuration <= newValue) {
                for (var i = 0; i < $scope.repeatOption.length; i++) {
                    if ($scope.repeatOption[i].value > newValue) {
                        $scope.alert.thresholdDuration = $scope.repeatOption[i].value;
                        return;
                    }
                }
            }
        }
    });

     /* Initialize condition array for simple alert */
     $scope.initSimpleCondition = function() {

        $scope.initReadingTypeDefaultList();

        if (typeof $scope.alert.simpleConditions != 'undefined' && $scope.alert.simpleConditions.length > 0) {
            return;
        }
        if (!$scope.alert.sensor) {
            $scope.alert.sensor = $scope.sensors[0].sensorid;
        }

        if (!$scope.alert.readingType) {
            $scope.alert.readingType = alertService.defaultReadingTypeId;
        }

        $scope.alert.selectedEvent = 0;

        angular.forEach($scope.readingTypeDefaultList, function(defaultReadingType, index) {
            if (typeof $scope.alert.simpleConditions[index] == 'undefined') {
                $scope.alert.simpleConditions[index] = {};
            }
            $scope.alert.simpleConditions[index].condition = defaultReadingType.options[0].value;
        });

        $scope.alert.simpleConditions[$scope.readingTypeDefaultList.length] = {
            readingType: alertService.defaultReadingTypeId
        };

        /* If it's edit alert then set simpleConditions */
        if ($scope.alert.alertId > 0) {

            var isDefaultCondition = false;
            angular.forEach($scope.readingTypeDefaultList, function(defaultReadingType, index) {
                if (defaultReadingType.readingtypeid == $scope.alert.readingType && defaultReadingType.options[0].value == $scope.alert.condition) {
                    $scope.alert.selectedEvent = index;
                    $scope.alert.simpleConditions[index].thresholdValue = $scope.alert.thresholdValue;
                    isDefaultCondition = true;
                    $scope.alert.simpleConditions[$scope.defaultReadingTypeListLength].condition = '1';
                }
            });

            if (!isDefaultCondition) {
                $scope.alert.selectedEvent = 2;
                $scope.alert.simpleConditions[$scope.alert.selectedEvent] = {
                    readingType: $scope.alert.readingType,
                    condition: $scope.alert.condition.toString(),
                    thresholdValue: $scope.alert.thresholdValue || 0
                };
            }

        } else {
            $scope.alert.simpleConditions[$scope.defaultReadingTypeListLength].condition = '1';
        }

    };

    /* Initialize condition array for complex alert */
    $scope.initComplexCondition = function() {

        if ($scope.alert.alertId > 0 && $scope.alert.expression) {
            $scope.alert.complexConditions = alertService.generateComplexConditions($scope.alert.expression);
            return;
        }
        /* Initialize only if not already exist */
        if (typeof $scope.alert.complexConditions === 'undefined' || !$scope.alert.complexConditions || $scope.alert.complexConditions.length === 0) {
            $scope.alert.complexConditions = [];
            $scope.addCondition();
        }
    };

    /* Add new complex condition */
    $scope.addCondition = function() {

        /* Check for complex condition limit , only $scop.allowedConditions number of conditions are allowed */
        if ($scope.alert.complexConditions.length >= $scope.allowedConditions) {
            return false;
        }

        /* Initialize new condition with default parameter and get index of pushed element */
        var conditionIndex = $scope.alert.complexConditions.push({
            sensors: [],
            readingType: alertService.defaultReadingTypeId,
            condition: 1,
            thresholdValue: null
        }) - 1;

        /* Set default selected sensor in new condition */
        var defaultSelectedSensor = $scope.getFistAllowed(conditionIndex);
        $scope.alert.complexConditions[conditionIndex].sensors.push(defaultSelectedSensor);

    };

    /* ToggelSign to change '+' ( value:1) and '-' (value:0) sign in complex condition */
    $scope.toggleSign = function(conditionIndex, sensorIndex) {
        $scope.alert.complexConditions[conditionIndex].sensors[sensorIndex].type = -1 * ($scope.alert.complexConditions[conditionIndex].sensors[sensorIndex].type);
    };

    /* Only one sensor per condition allowed, following function will disable already added sensor in select list of sensor selection for current condition */
    $scope.isSensorExist = function(conditionIndex, sensorIndex, sensorToCheck) {
        var isFound = false;
        angular.forEach($scope.alert.complexConditions[conditionIndex].sensors, function(sensor, key) {
            if (sensor.data.sensorid == sensorToCheck.sensorid && sensorIndex != key) {
                isFound = true;
            }
        });
        return isFound;
    };


    /* On sensor add, set default sensor value. Only one sensor per condition allowed, so following function will lookup for first available sensor value which are not in current condition */
    $scope.getFistAllowed = function(conditionIndex) {
        var AllowedSensor = {
            data: {},
            type: 1
        };
        for (var sensorIndex = 0; sensorIndex < $scope.sensors.length; sensorIndex++) {
            var isFound = false;
            for (var i = 0; i < $scope.alert.complexConditions[conditionIndex].sensors.length; i++) {
                if (!isFound && angular.equals($scope.sensors[sensorIndex].sensorid, $scope.alert.complexConditions[conditionIndex].sensors[i].data.sensorid)) {
                    isFound = true;
                }
            }
            if (!isFound) {
                AllowedSensor.data.sensorid = $scope.sensors[sensorIndex].sensorid;
                /* Set default '+' sign */
                AllowedSensor.type = 1;
                return AllowedSensor;
            }
        }
        return AllowedSensor;
    };


    /* Add new sensor for complex condition */
    $scope.addSensor = function(conditionIndex, location) {

        /* Check for sensor limit per complex condition , only $scop.allowedSensors number of sensors are allowed per condition */
        if ($scope.alert.complexConditions[conditionIndex].sensors.length >= $scope.allowedSensors) {
            return false;
        }

        var defaultSelectedSensor = $scope.getFistAllowed(conditionIndex);
        $scope.alert.complexConditions[conditionIndex].sensors.push(defaultSelectedSensor);

    };


    $scope.$watch('alert.alertCategory', function(newValue, oldValue) {
        if (newValue == 'complex') {
            /* Initialize complex condition structure */
            $scope.initComplexCondition();
            /* Update complexReadingTypeList based on selected sensors */
            // Code to generate complexReadingTypeList based on selected sensors
        } else if (newValue == 'simple') {
            $scope.initSimpleCondition();
        }
    });


    /* In simple alert on sensor value change, update the simpleSensorReadingTypeList */
    $scope.$watch('alert.sensor', function(newValue, oldValue) {
        if (newValue) {
            $scope.fetchSensorReadingTypes(newValue).then(function() {
                $scope.buildSingleSensorReadingTypeList(newValue);
            });
        }
    });


    $scope.updateSensorReadingTypes = function(sensorid, complexConditionKey, sensorKey) {
        $scope.fetchSensorReadingTypes(sensorid).then(function() {
            $scope.buildComplexSensorReadingTypeList(complexConditionKey, sensorid);
        });
    };

    $scope.buildSingleSensorReadingTypeList = function(sensorId) {
        $scope.singleSensorReadingTypeList = $scope.getSensorReadingTypes(sensorId);
        /* by default select first value */
        if ($scope.alert.simpleConditions.length>0 && !$scope.alert.simpleConditions[$scope.defaultReadingTypeListLength].readingType) {
            $scope.alert.simpleConditions[$scope.defaultReadingTypeListLength].readingType = $scope.singleSensorReadingTypeList[0].readingtypeid;
        }
    };

    function substract(a, b) {

        var onlyInA = a.filter(function(current) {
            return b.filter(function(current_b) {
                return current_b.readingtypeid == current.readingtypeid;
            }).length === 0;
        });

        var substract = a.filter(function(current) {
            return onlyInA.filter(function(current_onlyInA) {
                return current_onlyInA.readingtypeid == current.readingtypeid;
            }).length === 0;
        });
        return substract;
    }


    $scope.buildComplexSensorReadingTypeList = function(conditionKey, sensorId) {

        /* Code for sensor intersaction of complex sensor readingtype list */
        // $scope.multipleSensorReadingTypeList[conditionKey] = $scope.readingTypeList;
        $scope.multipleSensorReadingTypeList[conditionKey] = [];
        angular.forEach($scope.alert.complexConditions[conditionKey].sensors, function(sensor, key) {
            if (key) {
                $scope.multipleSensorReadingTypeList[conditionKey] = substract($scope.multipleSensorReadingTypeList[conditionKey], $scope.getSensorReadingTypes(sensor.data.sensorid));
            } else {
                $scope.multipleSensorReadingTypeList[conditionKey] = $scope.getSensorReadingTypes(sensor.data.sensorid);
            }
        });

        if (!$scope.alert.complexConditions[conditionKey].readingType && $scope.multipleSensorReadingTypeList[conditionKey][0]) {
            $scope.alert.complexConditions[conditionKey].readingType = $scope.multipleSensorReadingTypeList[conditionKey][0].readingtypeid;
        }

    };

    /* Save alert */
    $scope.addAlert = function(alert) {
        $scope.isSubmitting = true;
        alert = $scope.buildPayload(angular.copy(alert));
        apiService.alert_save(alert).then(function(response) {
            if(!alert.eventId)
                Analytics.trackEvent('Alerts', 'Alert Added', $state.current.name);
            else
                Analytics.trackEvent('Alerts', 'Alert Updated', $state.current.name);
            $scope.alert = new alertService.Alert();
            $scope.isSubmitting = false;
            $state.go('home.alert');
        }, function() {
            if(!alert.eventId)
                Analytics.trackEvent('Alerts', 'Alert adding failed', $state.current.name);
            else
                Analytics.trackEvent('Alerts', 'Alert updating failed', $state.current.name);
            bootbox.alert('Some error occured while processing. Please try again after some time');
            $scope.isSubmitting = false;
        });
    };

    $scope.updateStatus = function(alert) {
        if (alert.enabled) {
            bootbox.confirm("Are you sure you want to Disable selected alert?", function(result) {
                if (result) {
                    alert.enabled = false;
                    continueUpdate(alert);
                    Analytics.trackEvent('Alerts', 'Alert Disabled', $state.current.name);
                }
            });
        } else {
            alert.enabled = true;
            continueUpdate(alert);
            Analytics.trackEvent('Alerts', 'Alert Enabled', $state.current.name);
        }

        function continueUpdate(alert) {
            var enableAlerts = $filter('filter')($scope.alerts, function(alert) {
                return alert.enabled == true;
            });
            var alertlist = '';
            for (var i = 0; i < $scope.alerts.length; i++) {
                if ($scope.alerts[i].enabled) {
                    if (alertlist != '') {
                        alertlist += ",";
                    }
                    alertlist += $scope.alerts[i].alertid;
                }
            }
            loading(true);
            apiService.alert_update_status(alertlist).then(function(data) {
                loading(false);
            }, function() {
                var index = $scope.alerts.indexOf(alert);
                $scope.alerts[index].enabled = !alert.enabled;
                loading(false);
            });
        }
    };

    $scope.deleteAlert = function(alertId) {

        loading(true);
        var isListPage = $state.current.name == 'home.alert';
        apiService.alert_delete(alertId).then(function(data) {
            Analytics.trackEvent('Alerts', 'Alert deleted', $state.current.name);
            loading(false);
            if (isListPage) {
                var alert = $scope.getAlertFromId(alertId);
                var index = $scope.alerts.indexOf(alert);
                $scope.alerts.splice(index, 1);
            } else {
                $state.transitionTo('home.alert', null, {
                    reload: true
                });
            }
        }, function(data) {
            Analytics.trackEvent('Alerts', 'Alert deleting failed', $state.current.name);
            loading(false);
            $state.transitionTo('home.alert', null, {
                reload: true
            });
        });
    }

    $scope.update_events = function(event) {
        event = angular.copy(event);
        event.dateOfEvent = moment(event.dateOfEvent).format('YYYY/MM/DD hh:mm:ss');
        loading(true);
        apiService.event_save(event).then(function(data) {
            loading(false);
            $state.transitionTo('home.alert');
            Analytics.trackEvent('Alerts', 'Event Updated', $state.current.name);
        }, function(data) {
            loading(false);
            Analytics.trackEvent('Alerts', 'Event updating failed', $state.current.name);
        });
    }

    $scope.deleteEvent = function(eventid) {
        loading(true);
        var isListPage = $state.current.name == 'home.alert';
        apiService.event_delete(eventid).then(function(data) {
            loading(false);
            if (isListPage) {
                var event = $scope.getEventFromId(eventid);
                var index = $scope.events.indexOf(event);
                $scope.events.splice(index, 1);
                Analytics.trackEvent('Alerts', 'Event Deleted', $state.current.name);
            } else {
                $state.transitionTo('home.alert', null, {
                    reload: true
                });
            }
        }, function() {
            loading(false);
            $state.transitionTo('home.alert', null, {
                reload: true
            });
            Analytics.trackEvent('Alerts', 'Event delete failed', $state.current.name);
        });
    }

    $scope.buildPayload = function(alert) {

        if (alert.alertCategory == 'simple') {
            alert.thresholdValue = alert.simpleConditions[alert.selectedEvent].thresholdValue;
            alert.readingType = alert.simpleConditions[alert.selectedEvent].readingType;
            alert.condition = alert.simpleConditions[alert.selectedEvent].condition;
            this.expression = '';
        }
        if (alert.alertCategory == 'complex') {
            alert.thresholdValue = alert.complexConditions[0].thresholdValue;
            alert.readingType = alert.complexConditions[0].readingType;
            alert.sensor = alert.complexConditions[0].sensors[0].data.sensorid;
            alert.expression = alertService.generateExpression(alert.complexConditions);
            alert.condition = 1;
        }

        var startTime = alertService.timeToServer(alert.startHour, alert.startMin);
        alert.startHour = startTime.HH;
        alert.startMin = startTime.mm;

        var endTime = alertService.timeToServer(alert.endHour, alert.endMin);
        alert.endHour = endTime.HH;
        alert.endMin = endTime.mm;

        delete alert.simpleConditions;
        delete alert.complexConditions;

        return alert;

    };

}

smartsenseApp.factory('alertService', alertService);

alertService.$inject = ['SETTINGS'];

function alertService(SETTINGS) {

    var allowedSensors = 5;
    var allowedConditions = 3;

    /* For alert add */
    var allowedMobiles = 3;
    var allowedEmails = 10;

    var daysOption = [{
        label: 'All',
        value: -1
    }, {
        label: 'Mon',
        value: 2
    }, {
        label: 'Tue',
        value: 3
    }, {
        label: 'Wed',
        value: 4
    }, {
        label: 'Thu',
        value: 5
    }, {
        label: 'Fri',
        value: 6
    }, {
        label: 'Sat',
        value: 7
    }, {
        label: 'Sun',
        value: 1
    }];

    var durationOption = [{
        label: '2 mins',
        value: 2
    }, {
        label: '5 mins',
        value: 5
    }, {
        label: '15 mins',
        value: 15
    }, {
        label: '30 mins',
        value: 30
    }];

    var repeatOption = [{
        label: '15 mins',
        value: 15
    }, {
        label: '30 mins',
        value: 30
    }, {
        label: '1 hour',
        value: 60
    }, {
        label: '6 hours',
        value: 360
    }, {
        label: '1 day',
        value: 1440
    }];

    var defaultReadingTypeId = 2002;

    var service = {
        Alert: Alert,
        Event: Event,
        allowedSensors: allowedSensors,
        allowedConditions: allowedConditions,

        /* Allowed values for radio and select inputs */
        daysOption: daysOption,
        durationOption: durationOption,
        repeatOption: repeatOption,

        allowedMobiles: allowedMobiles,
        allowedEmails: allowedEmails,
        generateExpression: generateExpression,
        generateComplexConditions: generateComplexConditions,

        // Add, edit & detele events
        mapping: mapping,
        defaultReadingTypeId: defaultReadingTypeId,
        getHours: getHours,
        getMinutes: getMinutes,
        timeToLocal: timeToLocal,
        timeToServer:timeToServer
    };

    return service;

    ////////////

    function Event() {
        this.eventName = '';
        this.sensorId = null;
        this.eventDetails = '';
        this.dateOfEvent = '';
    }

    function Alert() {

        this.alertId = -1;
        this.alertCategory = 'simple';
        this.label = '';
        this.sensor = null;
        this.duration = 5;
        this.day = daysOption[0].value;

        this.startHour = 00;
        this.startMin = 00;
        this.endHour = 00;
        this.endMin = 00;

        this.thresholdDuration = 15;
        this.mobileNum = '';
        this.email = '';

        /* Condition to trigger alert, this will change in case of advance alertCategory */
        this.readingType = defaultReadingTypeId;
        this.condition = 1;
        this.thresholdValue = 0;
        this.expression = '';

        /* Events for simple and complex category */
        this.complexConditions = [];
        this.simpleConditions = [];


        /* Sample edit complex alert data */
        // this.expression = "1173_2001 + 1175_2001 + 1174_2001 > 44444 AND 1173_2006 + 1176_2006 + 1178_2006 + 1179_2006 + 1171_2006 > 444444 AND 1171_2005 + 1172_2005 + 1173_2005 + 1174_2005 + 1175_2005 < 55555 ";
        // this.complexConditions = generateComplexConditions(this.expression);
    }


    /* Return expression based on value. Used in creating expression for complex condition */
    function getConditionRepresentation(val) {
        if (val == 1) {
            return ">";
        } else if (val == 2) {
            return "<";
        } else if (val === 0) {
            return "=";
        }
        return null;
    }

    function findInstances(inputStr, regex) {
        var result, indices = [];
        var str = inputStr;
        while ((result = regex.exec(str))) {
            indices.push(result.index);
        }
        return indices;
    }

    /*
      @abstract
      Create expression from complex conditions

      @example

      input : [{"sensors":[{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1175},"type":1},{"data":{"sensorid":1174},"type":1}],"readingType":2001,"condition":1,"thresholdValue":44444},{"sensors":[{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1176},"type":1},{"data":{"sensorid":1178},"type":1},{"data":{"sensorid":1179},"type":1},{"data":{"sensorid":1171},"type":1}],"readingType":2006,"condition":1,"thresholdValue":444444},{"sensors":[{"data":{"sensorid":1171},"type":1},{"data":{"sensorid":1172},"type":1},{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1174},"type":1},{"data":{"sensorid":1175},"type":1}],"readingType":2005,"condition":2,"thresholdValue":55555}]

      output:
      1173_2001 + 1175_2001 + 1174_2001 > 44444 AND 1173_2006 + 1176_2006 + 1178_2006 + 1179_2006 + 1171_2006 > 444444 AND 1171_2005 + 1172_2005 + 1173_2005 + 1174_2005 + 1175_2005 < 55555

     */
    function generateExpression(complexConditions) {
        for (var i = 0; i < complexConditions.length; i++) {
            if (isNaN(complexConditions[i].thresholdValue)) {
                bootbox.alert("Please enter a valid number for threshold value of the Condition " + (i + 1));
                return "";
            }
        }
        var expression = "";
        for (i = 0; i < complexConditions.length; i++) {
            if (i !== 0) {
                expression = expression + " AND ";
            }
            for (var j = 0; j < complexConditions[i].sensors.length; j++) {

                if (j) {
                    expression = expression + " " + (complexConditions[i].sensors[j].type == 1 ? "+" : "-") + " ";
                }

                expression = expression + complexConditions[i].sensors[j].data.sensorid + "_" + complexConditions[i].readingType;

            }
            expression = expression + " " + getConditionRepresentation(complexConditions[i].condition) + " " + complexConditions[i].thresholdValue + " ";
        }
        return expression;
    }

    /*

    @abstract
    Generate complexConditions from the given expression. Reverse function of generateExpression().
    Will be in use while editing complex alert

    @example

    input:
    1173_2001 + 1175_2001 + 1174_2001 > 44444 AND 1173_2006 + 1176_2006 + 1178_2006 + 1179_2006 + 1171_2006 > 444444 AND 1171_2005 + 1172_2005 + 1173_2005 + 1174_2005 + 1175_2005 < 55555

    output : [{"sensors":[{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1175},"type":1},{"data":{"sensorid":1174},"type":1}],"readingType":2001,"condition":1,"thresholdValue":44444},{"sensors":[{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1176},"type":1},{"data":{"sensorid":1178},"type":1},{"data":{"sensorid":1179},"type":1},{"data":{"sensorid":1171},"type":1}],"readingType":2006,"condition":1,"thresholdValue":444444},{"sensors":[{"data":{"sensorid":1171},"type":1},{"data":{"sensorid":1172},"type":1},{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1174},"type":1},{"data":{"sensorid":1175},"type":1}],"readingType":2005,"condition":2,"thresholdValue":55555}]

    */
    function generateComplexConditions(expression) {
        var complexConditions = [];
        // part 1 split by and
        var subExps = expression.split("AND");
        for (var i = 0; i < subExps.length; i++) {

            /* init complex condition */
            var complexCondition = {
                sensors: [],
                readingType: null,
                condition: 1,
                thresholdValue: 0
            };

            // set condition assignment
            if (subExps[i].indexOf(">") > 0) {
                complexCondition.condition = 1;
            } else if (subExps[i].indexOf("<") > 0) {
                complexCondition.condition = 2;
            } else if (subExps[i].indexOf("=") > 0) {
                complexCondition.condition = 0;
            }

            /* split sub expression by '<' or '>' */
            var parts = subExps[i].split(/[\>\<=]/);

            // set threshold value
            complexCondition.thresholdValue = Number(parts[1].trim());


            var SensorReadingTypeList = parts[0].split(/[+-]/);

            // set readingType
            complexCondition.readingType = Number(SensorReadingTypeList[0].trim().split("_")[1]);

            // set sensorids
            for (var j = 0; j < SensorReadingTypeList.length; j++) {
                var sid = SensorReadingTypeList[j].trim().split("_")[0];
                complexCondition.sensors[j] = {
                    data: {},
                    type: 1
                };
                complexCondition.sensors[j].data.sensorid = Number(sid);
            }
            //For sensorSigns '+' or '-'
            expSigns = findInstances(parts[0], /[+-]/gi);
            for (j = 0; j < expSigns.length; j++) {
                if (parts[0][expSigns[j]] == "+") {
                    complexCondition.sensors[j].type = 1;
                } else {
                    complexCondition.sensors[j].type = -1;
                }
            }
            complexConditions.push(complexCondition);
        }
        return complexConditions;
    }


    function mapping(reverse) {
        var map = {
            alertid: "alertId",
            alertId: "alertid",
            alertCategory: "alertcategory",
            readingType: "readingtypeid",
            thresholdValue: "thresholdvalue",
            thresholdDuration: "thresholdduration",
            mobileNum: "mobilenum",
            startTime: "starttime",
            endTime: "endtime"
        }
    }

    function getHours() {
        var hours = [];
        for (var i = 0; i < 24; i++) {
            var label = i < 10 ? '0' + i : i + '';
            hours.push({
                label: label,
                value: i
            });
        }
        return hours
    }

    function getMinutes() {
        var minutes = [{
            label: '00',
            value: 0
        }, {
            label: '30',
            value: 30
        }];
        return minutes;
    }

    function timeToLocal(HH_mm) {
        // Get local timezone using moment
        var local_tz = moment.tz.guess();
        // Convert from server's timezone to localtimezone
        var d = moment.tz(HH_mm, 'HH:mm', SETTINGS.SERVER_TIMEZONE).tz(local_tz);
        return {
            HH: d.hours(),
            mm: d.minutes()
        }
    }

    function timeToServer(HH, mm) {
        // Get local timezone using moment
        var local_tz = moment.tz.guess();
        // Convert from server's timezone to localtimezone
        var d = moment.tz(HH+':'+mm, 'HH:mm', local_tz).tz(SETTINGS.SERVER_TIMEZONE);
        return {
            HH: d.hours(),
            mm: d.minutes()
        }
    }

}
smartsenseApp.controller('NetworkInsightsController', NetworkInsightsController);

NetworkInsightsController.$inject = ['$scope', '$state', '$filter', 'timeseriesService', 'grainService', 'readingTypeService', 'data', 'loading', 'networkInsightsService', '$timeout', '$compile', 'profileService', 'growl', 'billingLocations', 'Analytics', 'apiService'];

function NetworkInsightsController($scope, $state, $filter, timeseriesService, grainService, readingTypeService, data, loading, networkInsightsService, $timeout, $compile, profileService, growl, billingLocations, Analytics, apiService) {
    //Default parameters
    $scope.stopRender = false;
    $scope.insight = {
        fromDate : moment().subtract(1, 'month').startOf("month"),
        toDate : moment()
    };

    $scope.billingLocations = billingLocations.data;

    /*Get list of readingtypes*/
    readingTypeService.getAll().then(function(data) {
        $scope.readingTypes = data.data;
    });

    /* Allowed number of location/appliance and readingtype parameters*/
    $scope.maximumParameter = 8;

    $scope.insightData = {};

    $scope.isDateInRange = function(date, selection, summaryDate){
        var startDate = $scope.insight.fromDate;
        var endDate = moment($scope.insight.fromDate).add(1, "month").endOf('month');
        if(selection){
            endDate = moment($scope.insight.toDate);
        }
        if(endDate.diff(moment())>0)
            endDate = moment();
        if(summaryDate){
            startDate = $scope.insight.currentFromDate;
            endDate = $scope.insight.currentToDate;
        }
        var range = moment().range(startDate, endDate);
        return range.contains(date);
    };

    $scope.$watch('insight.fromDate', function(newDate, oldDate) {
        if (newDate && newDate != oldDate) {
            var mDate = moment(newDate);
            if(newDate){
                if(!$scope.isDateInRange($scope.insight.toDate)){
                    $scope.insight.toDate = moment($scope.insight.fromDate).add(1, "month").endOf('month');
                    if($scope.insight.toDate.diff(moment())>0)
                        $scope.insight.toDate = moment();
                }
            }
        }
        $scope.stopRender = true;
    }, false);

    /* Following functions binds with the date change. Responsible for enabling/disabling dates according to selected startDate/endDate of report */

    $scope.endDateBeforeRender = endDateBeforeRender
    $scope.endDateOnSetTime = endDateOnSetTime
    $scope.startDateBeforeRender = startDateBeforeRender
    $scope.startDateOnSetTime = startDateOnSetTime

    function startDateOnSetTime() {
        $scope.$broadcast('start-date-changed');
    }

    function endDateOnSetTime() {
        $scope.$broadcast('end-date-changed');
    }

    function startDateBeforeRender($dates) {
        $dates.filter(function(date) {
            return date.localDateValue() > new Date().getTime();
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    function endDateBeforeRender($dates) {
        $dates.filter(function(date) {
            return !$scope.isDateInRange(moment(date.localDateValue()));
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    /*Insights new APIs*/
    $scope.clearSelections = function(){
        if(!$scope.insightData)return;
        $scope.showAnalyseFurther(false);
        $scope.insightData.selectedType =
        $scope.insightData.selectedIssueType =
        $scope.insightData.selectedFilter =
        $scope.insightData.selectedIssue =
        $scope.insightData.selectedSubItemIndex =
        $scope.insightData.selectedAsset =
        $scope.insightData.selectedCalendarDate =
        $scope.insightData.plotLines =
        $scope.lineGraphData =
        $scope.insightData.selectedIssueData = false;
        $scope.actiontaken = {
            action : "Open",
            comment : "",
            actionDate : null,
            submitted : false
        };
    };

    $scope.fetchSummary = function(){
        $scope.clearSelections();
        $scope.refreshInProgress = true;
        loading(true);

        var startDate = moment($scope.insight.fromDate).format("YYYY-MM-DD");
        var endDate = moment($scope.insight.toDate).format("YYYY-MM-DD");
        var billingLocation = $scope.insight.selectedBillingLocation;

        apiService.network_get_issue_summary(startDate, endDate, billingLocation).then(function(response) {
            loading(false);
            $scope.insight.currentFromDate = startDate;
            $scope.insight.currentToDate = endDate;
            $scope.insight.currentSelectedBillingLocation = billingLocation;
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = false;
            if (response && response.data) {
                $scope.processData(response.data)
            }
        }, function(error) {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });
    };

    $scope.setType = function(type) {

        if ($scope.stopRender = true) {
        $scope.insightData.selectedType = type;
        $scope.renderItems();
        Analytics.trackEvent('Network Insights', 'View Changed To Show : ' + type, $state.current.name);
    }
    }

    $scope.setFilter = function(type){
        $scope.insightData.selectedFilter = type;
        $scope.renderItems();
        Analytics.trackEvent('Network Insights', 'Filter Changed To Show : ' + type, $state.current.name);
    }

    $scope.processData = function(data){
        //Default values for reponse, this will help to handle failure scenario
        var defaultInsightData = {
            Issues : {
                Open : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                },
                Ignored : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                },
                Resolved : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                },
                All : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                }
            },
            Tickets : {
                Open : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                },
                Ignored : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                },
                Resolved : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                },
                All : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                }
            }
        };
        $scope.insightData = $.extend(true, defaultInsightData, data);

        function filterItems(result){
            var nwInsightData = {
                Open : {
                    Energy : {
                            Count : 0,
                            Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                },
                Ignored : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                },
                Resolved : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                },
                Merged : {
                    Energy : {
                        Count : 0,
                        Insights : {}
                    },
                    Health : {
                        Count : 0,
                        Insights : {}
                    }
                },
                All : result.All
            };

            var all = result.All;
            var len = 0;
            for(var key in all){
                var insights = all[key].Insights;
                for(var insight in insights){
                    var curInsight = insights[insight];
                    var assetData = [];
                    var curAssetData = curInsight.AssetData || [];
                    curAssetData.forEach(function(_assetData){
                        var sensorID = _assetData.SensorId;
                        var name = $.trim(_assetData.Name);
                        var dates = _assetData.Dates || [];
                        dates.forEach(function(date){
                            var values = date.Values;
                            for(var _type in values){
                                function addIssue(type, value, dateValue, id){
                                    var addTo = nwInsightData[type][key];
                                    var itemAdded = false;
                                    if(addTo.Insights[insight]){
                                        var addToInsight = addTo.Insights[insight];
                                        var addToAssetData = addToInsight.AssetData || [];
                                        var hasMatch = false;
                                        var added = false;
                                        addToAssetData.forEach(function(_curAD){
                                            if(!added && $.trim(_curAD.Name) == name){
                                                var _curDates = _curAD.Dates;
                                                _curDates.forEach(function(_curDate){
                                                    var _curVals = _curDate.Values;
                                                    if(value.ReadingTypeId == _curDate.ReadingTypeId && $.trim(value.Name) == $.trim(_curDate.Name) && value.Key == _curDate.Key){
                                                        _curAD.Count++;
                                                        addToInsight.Count++;
                                                        _curVals[dateValue] = id;
                                                        itemAdded = true;
                                                        hasMatch = true;
                                                        //added = true;
                                                    }
                                                });
                                            }
                                        });

                                        if(!hasMatch)
                                        {
                                            var hasSensorMatch = false;
                                            addToAssetData.forEach(function(curRef){
                                                if($.trim(curRef.SensorId) == $.trim(sensorID) && $.trim(curRef.Name) == $.trim(name)){
                                                    curRef.Dates = curRef.Dates || [];
                                                    curRef.Count = curRef.Count || 0;
                                                    curRef.Dates.push(value);
                                                    hasSensorMatch = true;
                                                    curRef.Count++;
                                                    addToInsight.Count++;
                                                    itemAdded = true;
                                                }
                                            });
                                            if(!hasSensorMatch){
                                                addToAssetData.push({
                                                    Count : 1,
                                                    "SensorId": sensorID,
                                                    "Dates": [value],
                                                    "Name": name
                                                });
                                                addToInsight.Count++;
                                                itemAdded = true;
                                            }
                                        }
                                    }
                                    else{
                                        addTo.Insights[insight] = {
                                            Count : 1,
                                            AssetData : [{
                                                Count : 1,
                                                "SensorId": sensorID,
                                                "Dates": [value],
                                                "Name": name
                                            }]
                                        };
                                        itemAdded = true;
                                    }
                                    if(itemAdded)
                                        addTo.Count++;
                                }
                                for(var dateValue in values[_type]){
                                    var curValue = {};
                                    var id = values[_type][dateValue];
                                    curValue[dateValue] = id;
                                    var copyDate = $.extend({}, date, true);
                                    copyDate.Values = curValue;
                                    addIssue(_type, copyDate, dateValue, id);
                                }
                                for(var dateValue in values[_type]){
                                    var curValue = {};
                                    var id = values[_type][dateValue];
                                    curValue[dateValue] = id;
                                    var copyDate = $.extend({}, date, true);
                                    copyDate.Values = curValue;
                                    addIssue("Merged", copyDate, dateValue, id);
                                }
                            }
                        });
                    });
                }
            }
            var catListEnergy = result.CategoryList.Energy;
            var catListHealth = result.CategoryList.Health;
            for(var type in nwInsightData){
                var curType = nwInsightData[type];
                catListEnergy.forEach(function(listItem){
                    if(typeof curType.Energy.Insights[listItem.Name] == "undefined"){
                        curType.Energy.Insights[listItem.Name] = {
                            Count : 0,
                            AssetData : []
                        }
                    }
                    curType.Energy.Insights[listItem.Name].AssetData = curType.Energy.Insights[listItem.Name].AssetData.sort(function(a, b){
                        return parseInt(b.Count) - parseInt(a.Count);
                    });
                    curType.Energy.Insights[listItem.Name].Id = listItem.Id;
                });
                var _insights = [];
                for(var ci in curType.Energy.Insights){
                    var tmp = curType.Energy.Insights[ci];
                    tmp.Name = ci;
                    _insights.push(tmp)
                }
                _insights = _insights.sort(function(a, b){
                    return parseInt(b.Count) - parseInt(a.Count);
                });
                curType.Energy.Insights = _insights;
                catListHealth.forEach(function(listItem){
                    if(typeof curType.Health.Insights[listItem.Name] == "undefined"){
                        curType.Health.Insights[listItem.Name] = {
                            Count : 0,
                            AssetData : []
                        }
                    }
                    curType.Health.Insights[listItem.Name].AssetData = curType.Health.Insights[listItem.Name].AssetData.sort(function(a, b){
                        return parseInt(b.Count) - parseInt(a.Count);
                    });
                    curType.Health.Insights[listItem.Name].Id = listItem.Id;
                });
                var _insights = [];
                for(var ci in curType.Health.Insights){
                    var tmp = curType.Health.Insights[ci];
                    tmp.Name = ci;
                    _insights.push(tmp)
                }
                _insights = _insights.sort(function(a, b){
                    return parseInt(b.Count) - parseInt(a.Count);
                });
                curType.Health.Insights = _insights;
            }
            nwInsightData.All = nwInsightData.Merged;
            return nwInsightData;
        }

        $scope.insightData.Issues = filterItems($scope.insightData.Issues);
        $scope.insightData.Tickets = filterItems($scope.insightData.Tickets);

        for(var filter in $scope.insightData.Issues){
            if($scope.insightData.Issues[filter])
                $scope.insightData.Issues[filter].Count = $scope.insightData.Issues[filter].Energy.Count + $scope.insightData.Issues[filter].Health.Count;
        }

        for(var filter in $scope.insightData.Tickets){
            $scope.insightData.Tickets[filter]
                $scope.insightData.Tickets[filter].Count = $scope.insightData.Tickets[filter].Energy.Count + $scope.insightData.Tickets[filter].Health.Count;
        }

        $scope.selectDefaultItems();
    }

    $scope.selectDefaultItems = function(){
        $scope.insightData.selectedType = $scope.insightData.selectedType || "Issues";
        $scope.insightData.selectedFilter = $scope.insightData.selectedFilter || "Open";
        $scope.renderItems();
    }

    $scope.renderItems = function(){
        function getPerc(val, val2){
            var total = val + val2;
            if(total == 0)
                return 100;
            return Math.round((100 * val) / total);
        }
        var insightData = $scope.insightData;
        var type = insightData.selectedType;
        var filter = insightData.selectedFilter;
        if(insightData && insightData[type] && insightData[type][filter] && insightData[type][filter].Energy && insightData[type][filter].Health){
            if(!insightData.selectedIssueType || insightData[type][filter][insightData.selectedIssueType].Count == 0){
                insightData.selectedIssueType = insightData[type][filter]["Energy"].Count > insightData[type][filter]["Health"].Count ? "Energy" : "Health";
            }
            var altKey = insightData.selectedIssueType == "Energy" ? "Health" : "Energy";
            var colors = insightData.selectedIssueType == "Energy" ? ['#ff6666', '#e6e6e6'] : ['#e6e6e6', '#ff6666'];
            var chartText = "<div class='chart-text'><div class='title'><strong>"+insightData.selectedIssueType+"</strong></div><div class='values'><span class='count'>"+insightData[type][filter][insightData.selectedIssueType].Count+"</span><span class='perc'>"+getPerc(insightData[type][filter][insightData.selectedIssueType].Count, insightData[type][filter][altKey].Count)+"%</span></div></div>";
            insightData[type][filter].issueChartData = {
                series :
                [
                    {
                        name: 'Issues',
                        data: [
                            {
                                name : 'Energy',
                                y : insightData[type][filter].Energy.Count,
                                perc : getPerc(insightData[type][filter].Energy.Count, insightData[type][filter].Health.Count),
                                selected : insightData.selectedIssueType == "Energy"
                            },
                            {
                                name : 'Health',
                                y : insightData[type][filter].Health.Count,
                                perc : getPerc(insightData[type][filter].Health.Count, insightData[type][filter].Energy.Count),
                                selected : insightData.selectedIssueType == "Health"
                            }
                        ]
                    }
                ],
                options : {
                    forNI : true,
                    colors : colors,
                    title : {
                        text : chartText
                    },
                    onSelect : function(evt, point){
                        $scope.insightData.selectedIssueType = point.options.name;
                        $scope.insightData[type][filter].issueChartData.options.title.text = "<div class='chart-text'><div class='title'><strong>"+point.options.name+"</strong></div><div class='values'><span class='count'>"+point.options.y+"</span><span class='perc'>"+point.options.perc+"%</span></div></div>";
                        $timeout(function(){
                            $scope.$apply();
                            $scope.showInsights(0);
                        }, 100);
                        Analytics.trackEvent('Network Insights', 'Issue type changed to show : ' + $scope.insightData.selectedIssueType, $state.current.name);
                    }
                }
            }
        }
        $scope.insightData = insightData;
        $scope.showInsights(0);
    }

    $scope.changePlotFilter = function(filterType){
        $scope.insightData.filterPlotsBy = filterType;
    };

    $scope.showInsights = function(index){
        $scope.lineGraphData =
        $scope.insightData.selectedAsset = false;
        if(!$scope.insightData)
            return;
        $scope.showAnalyseFurther(false);
        var insightData = $scope.insightData;
        var type = insightData.selectedType;
        var filter = insightData.selectedFilter;
        var curInsight = insightData[type][filter];
        if(curInsight && curInsight[insightData.selectedIssueType] && curInsight[insightData.selectedIssueType].Insights && curInsight[insightData.selectedIssueType].Insights)
        {
            var insights = curInsight[insightData.selectedIssueType].Insights;
            if(!$.isArray(insights)){
                var arr = [];
                for (var item in insights) {
                    var curitem = insights[item];
                    arr.push({
                        Count : curitem.Count,
                        AssetData : curitem.AssetData,
                        Name : item,
                        Id : curitem.Id
                    });
                }
                curInsight[insightData.selectedIssueType].Insights = arr;
                $scope.insightData[type][filter][insightData.selectedIssueType].Insights = arr;
            }
            var insight = $scope.insightData[type][filter][insightData.selectedIssueType].Insights[index];
            $scope.insightData.selectedIssue = insight;
            $scope.insightData.selectedSubItemIndex = index;
            if($scope.insightData.selectedIssue)
                $scope.showAssetIssues($scope.insightData.selectedIssue.AssetData[0]);
            $scope.renderDualCalendar();
        }
        else{
            $scope.insightData.selectedIssue =
            $scope.insightData.selectedSubItemIndex = false;
        }
    }

    $scope.showAssetIssues = function(asset){
        if(!asset)
            return;
        $scope.lineGraphData = false;
        $scope.insightData.selectedDate = false;
        $scope.insightData.selectedAsset = asset;
        $scope.renderDualCalendar();
    }

    $scope.showIssuesForDate = function(id, marker, date){
        var issuesForDate = $("div[uid='"+id+"']").data("issueItems");
        if(!issuesForDate)
            return false;
        $scope.insightData.selectedDate = issuesForDate;
        if(issuesForDate.issues && issuesForDate.issues.length>0)
            $scope.showGraphForIssue($scope.insightData.selectedDate.issues[0]);
    };

    $scope.showGraphForIssue = function(issue){
        $scope.showAnalyseFurther(false);
        $scope.insightData.selectedIssueItem = issue;
        var issueId = issue.id;
        var key = issue.key;
        var date = issue.date;
        var readingtypeId = issue.readingTypeId;
        if(!issueId)
            return false;
        loading(true);
        var category = $scope.insightData.selectedIssue.Name;
        var billingLocation = $scope.insight.currentSelectedBillingLocation;
        apiService.network_get_issue_data(date, issueId, key, category, billingLocation).then(function(response) {
            $scope.changePlotFilter("Daywise");
            var issueData = response.data.SummaryData[0];
            if(!issueData){
                loading(false);
                growl.error("Summary Data not available", {
                    ttl: 3000
                });
                return false;
            }
            issueData.Key = issueData.Key || key;
            if(!issueData)
                return;
            $scope.lineGraphData = false;
            var assetItem = $scope.insightData.selectedAsset;
            if(!assetItem)
                return;
            $scope.insightData.selectedIssueData = issueData;
            var calendars = $('#calendar1, #calendar2');
            var parent = calendars.find(".date[data-date-formatted='"+date+"']").parent();
            $scope.insightData.selectedCalendarDate = moment(date, "YYYY-MM-DD").format("(ddd) DD MMM, YY");
            if(parent.hasClass('issue')){
                calendars.find(".selected").removeClass('selected');
                parent.addClass('selected');
                var curIssue = {
                    Key : key,
                    StartDate : issueData.StartDate || date,
                    EndDate : issueData.EndDate || date,
                    SensorsIds : [assetItem.SensorId],
                    SummaryInfo : issueData.SummaryInfo || [],
                    IssueId : issueId,
                    ReadingTypeId : readingtypeId,
                    DateRange : issueData.DateRange,
                    lineData : issueData.lineconstant
                };
                $scope.actiontaken = {
                    action : $scope.insightData.selectedIssueData.Action + "",
                    comment : "",
                    actionDate : new Date(),
                    submitted : false
                };
                $scope.showIssueGraphActivity(curIssue);
            }
            else{
                loading(false);
            }
        }, function(){
            loading(false);
        });
        Analytics.trackEvent('Network Insights', 'Requested details for issue : ' + issue.name, $state.current.name);
    }

    $scope.showIssueGraphActivity = function(issue){
        $scope.lineGraphData = [];
        scrolled = false;
        loading(true);
        $scope.getBaseline(issue, function(lines){
            $scope.getTimeSeries(issue, function(serieses){
                var graphs = lines.concat(serieses);
                var lineconstandAdded;
                var category = $scope.insightData.selectedIssue.Name;
                graphs.forEach(function(curSeries){
                    if(!lineconstandAdded && curSeries.timeSeries && curSeries.timeSeries.length>0){
                        for(var key in issue.lineData){
                            //By default disable the legend of rated power in chart if its for under load, to save space on the graph
                            var visible = true;
                            if(category == "Underload" && key == "Rated Power"){
                                visible = false;
                            }
                            var lineItem = "";
                            var lineItemValue = 0;
                            if(!lineItem){
                                lineItem = key;
                                lineItemValue = issue.lineData[key];
                            }
                            if(lineItem){
                                var constantLine = {
                                    timeSeries : [],
                                    "readingType": {
                                        "readingtypeid": null,
                                        "readingtypename": lineItem,
                                        "parentreadingtypeid": null,
                                        "export": false,
                                        "timebased": false,
                                        "scalar": true,
                                        "priority": 1
                                    }
                                };
                                curSeries.timeSeries.forEach(function(curTS){
                                    constantLine.timeSeries.push({
                                        timeStamp : curTS.timeStamp,
                                        value : lineItemValue.Value || lineItemValue
                                    });
                                });
                                graphs.push({
                                    type : "lineConstant",
                                    name: lineItem,
                                    chartType : "line",
                                    animation: false,
                                    timeSeries: constantLine.timeSeries,
                                    readingtype: constantLine.readingType,
                                    unit : lineItemValue.Unit,
                                    id: "Graph_" + utils.random(),
                                    visible : visible
                                });
                                lineconstandAdded = true;
                            }
                        }
                    }
                })
                $scope.lineGraphData = $scope.lineGraphData || [];
                $scope.lineGraphData = $scope.lineGraphData.concat(graphs);
                $scope.getActivityLog(function(){
                    if($("#networkInsight-lineChart").length>0){
                        $('html, body').animate({
                            scrollTop: $("#networkInsight-lineChart").offset().top + 520
                        }, 1000);
                    }
                    loading(false);
                });
            });
        });
    }

    $scope.renderDualCalendar = function(){
        var asset = $scope.insightData.selectedAsset;
        var dates = asset.Dates || [];
        var markerDates = {};
        dates.forEach(function(curDate){
            var values = curDate.Values || {};
            var name = curDate.Name;
            var key = curDate.Key;
            var dayOffset = curDate.DayOffset;
            var readingTypeId = curDate.ReadingTypeId;
            for(var dt in values){
                markerDates[dt] = markerDates[dt] || {
                    issues : [],
                    titles : []
                };
                markerDates[dt].issues.push({
                    id : values[dt],
                    date : dt,
                    name : name,
                    readingTypeId : readingTypeId,
                    key : key,
                    dayOffset : dayOffset
                });
                markerDates[dt].titles.push(name);
            }
        });

        $scope.dualCalendar = {
            firstMonth : $scope.insight.currentFromDate,
            onBeforeRender : function($view, $dates, $leftDate, $upDate, $rightDate){
                $dates.filter(function(date) {
                    return !$scope.isDateInRange(moment(date.localDateValue()), true, true);
                }).forEach(function(date) {
                    date.selectable = false;
                });

                $scope.dualCalendar.delay(function(){
                    var calendars = $('#calendar1, #calendar2');
                    calendars.find("td.active").removeClass('active');
                    function bindDates(calendar){
                        var month;
                        calendar.find("thead").find("tr:first").each(function(){
                            var dt = "";
                            if(calendar.is("#calendar1"))
                                dt = moment($scope.dualCalendar.firstMonth).format("MMMM YYYY");
                            else
                                dt = moment($scope.dualCalendar.secondMonth).format("MMMM YYYY");
                            month = dt;
                            $(this).html("<th colspan='7'>"+dt+"</th>");
                        });
                        calendar.find("td.day:visible:not(.past)").unbind().each(function(){
                            var date = $(this).text();
                            $(this).text("");
                            var curDate = moment(month + "-" + date, "MMMM YYYY-DD");
                            var _date = curDate.format("DD-MM-YYYY");
                            var _dateFormatted = curDate.format("YYYY-MM-DD");
                            if(!$scope.isDateInRange(curDate, true, true)){
                                $(this).addClass('strike');
                            }
                            var id = generateRandomCode();
                            var html = '<div ng-click="showIssuesForDate(\''+id+'\')" uid="'+id+'" class="date" data-date-formatted="'+_dateFormatted+'" data-date="'+_date+'"><div class="text">'+date+'</div><div class="bullet"></div></div>';
                            $(this).append($compile(html)($scope));
                        });
                        $scope.dualCalendar.addMarkers(calendar);
                    }
                    bindDates(calendars.filter("#calendar1"));
                    bindDates(calendars.filter("#calendar2"));
                }, 100);
            },
            addMarkers : function(calendar){
                calendar.find("div.date").removeClass('tool-tip').removeData('issueItems').removeAttr('title').each(function(){
                    $(this).closest('td').removeClass('issue').removeClass('holiday').removeClass('selected');
                });
                for (var i = 0; i < $scope.holidays.length; i++) {
                    var holiday = $scope.holidays[i];
                    calendar.find("div.date[data-date-formatted='"+holiday.date+"']").addClass('tool-tip').attr("title", holiday.name).attr("data-html", "true").closest('td').addClass('holiday');
                }
                for (var item in markerDates) {
                    var date = item;
                    var curItem = markerDates[item];
                    var text = "Total " + curItem.titles.length;
                    if($scope.insightData.selectedType == "Tickets"){
                        text += " ticket(s)";
                    }
                    else{
                        text += " issue(s)";
                    }
                    calendar.find("div.date[data-date-formatted='"+date+"']").data("issueItems", curItem).addClass('tool-tip').attr("title", text).attr("data-html", "true").closest('td').addClass('issue');
                }

                calendar.find(".tool-tip").tooltip({
                    container : "body",
                    placement : "top"
                });
            },
            secondMonth : moment($scope.insight.currentFromDate).add(1, "month"),
            delayTimer : 0,
            delay : (function () {
                return function (callback, ms) {
                    $timeout.cancel($scope.dualCalendar.delayTimer);
                    $scope.dualCalendar.delayTimer = $timeout(callback, ms);
                };
            })()
        };
        $scope.$broadcast('re-render-dual-calendar');
        $scope.$broadcast('re-render-dual-calendar-2');
    }

    $scope.lineGraphData = [];
    var scrolled = false;

    $scope.graphOptions = {
        chart: {
            events: {
                redraw: function(event) {
                    if (!scrolled) {
                        try{
                            $('html, body').animate({
                                scrollTop: $("#networkInsight-lineChart").offset().top - 140
                            }, 1000);
                            scrolled = true;
                        }catch(ex){}
                    }
                }
            }
        },
        chartTypeBasedOnScalar : true,
        issuePointType : "shift",
        hideXAxisLabels : true,
        hideYAxisLabels : true,
        sameyAxis: 0
    };

    $scope.getTimeSeries = function(issue, cb) {
        var category = $scope.insightData.selectedIssue.Name;
        var graphs = [];
        var grain = $scope.insightData.selectedType == 'Tickets' ? {value : 1440} : undefined;
        apiService.network_get_actual(issue, category, grain).then(function(response) {
            response.data[0].readingType.timebased = false;
            var chartType = $scope.insightData.selectedIssueType == "Energy" ? "bar" : "area";
            $scope.insightData.plotLines = networkInsightsService.createPlotLines(issue.DateRange);
            var plantShifts = [];
            var summaryText = "";
            if(issue.SummaryInfo && issue.SummaryInfo.length>0){
                issue.SummaryInfo.forEach(function(info){
                    if(info.Name == "PlantShift"){
                        plantShifts = info.Value;
                    }
                    else if(info.Name == "SummaryText"){
                        $scope.insightData.selectedIssueData.SummaryText = info.Value;
                    }
                });
            }
            graphs.push({
                name: 'Actual',
                animation: false,
                chartType : chartType,
                timeSeries: response.data[0].timeSeries,
                readingtype: response.data[0].readingType,
                id: "Graph_" + utils.random(),
                plotLines: $scope.insightData.plotLines,
                plotBands: networkInsightsService.createPlotBands(plantShifts, category),
                showOnlyIfDataExists : true,
                markerOptions : {
                    enabled: false,
                    states: {
                        hover: {
                            enabled:true,
                            symbol:'circle',
                            radius:5,
                            fillColor:'white',
                            lineColor : 'red',
                            lineBorder : '1px',
                            lineWidth : '1px'
                        }
                    }
                },
                color : '#33bbff'
            });
            var totalActual = 0;
            //Add actual value to summary info only if trendline/baseline values exists
            if(response.data[0].timeSeries && response.data[0].timeSeries.length>0 && $scope.insightData.selectedIssueData.SummaryInfo && $scope.insightData.selectedIssueData.SummaryInfo[0] && $scope.insightData.selectedIssueData.SummaryInfo[0].Name == "Trendline"){
                response.data[0].timeSeries.forEach(function(val){
                    totalActual += val.value
                });
                $scope.insightData.selectedIssueData.SummaryInfo.unshift({
                    Name : "Actual",
                    Value : totalActual,
                    Unit : "KWh"
                });
            }
            if(cb)
                cb(graphs);
        })
    }

    $scope.getBaseline = function(issue, cb) {
        $scope.selectedIssue = issue;
        $scope.lineGraphData = [];
        $scope.refreshInProgress = true;
        var graphs = [];
        var category = $scope.insightData.selectedIssue.Name;
        var categoryId = $scope.insightData.selectedIssue.Id;
        apiService.network_get_baseline(issue, category, categoryId).then(function(response) {
            if (response && response.data) {
                var totalBaseline = 0, totalTrendline = 0;
                if(response.data.Baseline && response.data.Baseline.readingType){
                    response.data.Baseline.readingType.timebased = false;
                    graphs.push({
                        animation: false,
                        name: 'Baseline',
                        chartType : "area",
                        timeSeries: response.data.Baseline.timeSeries,
                        readingtype: response.data.Baseline.readingType,
                        id: "Graph_" + utils.random(),
                    });
                    response.data.Baseline.timeSeries.forEach(function(val){
                        totalBaseline += val.value;
                    });
                    $scope.insightData.selectedIssueData.SummaryInfo.unshift({
                        Name : "Baseline",
                        Value : totalBaseline,
                        Unit : "KWh"
                    });
                }
                if(response.data.TrendLine && response.data.TrendLine.readingType){
                    response.data.TrendLine.readingType.timebased = false;
                    graphs.push({
                        animation: false,
                        name: 'Trendline',
                        chartType : "area",
                        timeSeries: response.data.TrendLine.timeSeries,
                        readingtype: response.data.TrendLine.readingType,
                        id: "Graph_" + utils.random(),
                    });
                    response.data.TrendLine.timeSeries.forEach(function(val){
                        totalTrendline += val.value;
                    });
                    $scope.insightData.selectedIssueData.SummaryInfo.unshift({
                        Name : "Trendline",
                        Value : totalTrendline,
                        Unit : "KWh"
                    });
                }
                if(response.data.Imbalance && response.data.Imbalance.readingType){
                    response.data.Imbalance.readingType.timebased = false;
                    graphs.push({
                        animation: false,
                        name: '',
                        chartType : "area",
                        timeSeries: response.data.Imbalance.timeSeries,
                        readingtype: response.data.Imbalance.readingType,
                        id: "Graph_" + utils.random(),
                        markerOptions : {
                            enabled: false,
                            states: {
                                hover: {
                                    enabled:true,
                                    symbol:'circle',
                                    radius:5,
                                    fillColor:'white',
                                    lineColor : 'red',
                                    lineBorder : '1px',
                                    lineWidth : '1px'
                                }
                            }
                        },
                        color : '#33bbff'
                    });
                }
                if(cb)
                    cb(graphs);
            }
        }, function(error) {
            if(cb)
                cb(false);
        });
    }

    $scope.$watch('actiontaken.action', function(newValue, oldValue) {
        if (newValue  && newValue == 'IgnoreAllPrevious') {
             $scope.actiontaken.actionDate = new Date();
        }
    });

    $scope.getActivityLog = function(cb){
        var issueData = $scope.insightData.selectedIssueData;
        if(!issueData){
            if(cb)
                cb();
            return;
        }
        var isseuId = issueData.IssueId || issueData.TicketId;
        var key = issueData.Key;
        apiService.network_get_activity_log(isseuId, key).then(function(response) {
            $scope.selectedIssue.activityLog = response.data.activityLogs;
            if(cb)
                cb();
        });
    }

    $scope.submitActivityLog = function(){
        function continueSavingActivity(){
            loading(true);
            apiService.network_submit_activity_log(isseuId, key, action, comment, date).then(function(response) {
                $scope.actiontaken = {
                    action : "Open",
                    comment : "",
                    actionDate : null,
                    submitted : true
                };
                growl.success("Activity saved.", {
                    ttl: 3000
                });
                $scope.selectedIssue.activityLog = response.data.activityLogs;
                if(action != $scope.insightData.selectedFilter)
                {
                    $scope.fetchSummary();
                }
                else{
                    loading(false);
                }
            }, function(err){
                growl.error("Error while saving activity. <br>" + err.message, {
                    ttl: 3000
                });
            });
        }

        var issueData = $scope.insightData.selectedIssueData;
        if(!issueData)
            return;
        var isseuId = issueData.IssueId;
        var key = issueData.Key;
        var action = $scope.actiontaken.action;
        var comment = $scope.actiontaken.comment;
        var date = moment($scope.actiontaken.actionDate).format("YYYY/MM/DD HH:mm:ss");
        if(action == "IgnoreAllPrevious"){
            bootbox.confirm("Are you sure you want to ignore all previous issues?", function(flag) {
                if (flag) {
                    $scope.$apply(function() {
                        continueSavingActivity();
                    });
                }
            });
        }
        else{
            continueSavingActivity();
        }
    }

    $scope.getTime = function(epoch){
        return moment(epoch*1000).format("DD/MM/YYYY hh:mm A");
    }

    $scope.hasSummary = function(){
        if($scope.insightData && $scope.insightData.selectedIssueData && $scope.insightData.selectedIssueData.SummaryInfo && Object.keys($scope.insightData.selectedIssueData.SummaryInfo).length>0)
            return true;
        else
            return false;
    }

    $scope.formatIssueName = function(name){
        var items = name.split("-").reverse();
        if(items.length>1)
            items[0] = "(" + items[0] + ") ";
        return items.join(" - ");
    }

    $scope.roundValue = function(val){
        return utils.roundAbs(val);
    }

    $scope.analyzeFurther = {
        enabled : false,
        date : {},
        readingTypes : [],
        grain : 900,
        dateRangeOpts : {
            locale: {
                applyClass: 'btn-green',
                applyLabel: "Apply",
                fromLabel: "From",
                format: "DD/MM/YYYY",
                toLabel: "To",
                cancelLabel: 'Cancel',
                customRangeLabel: 'Custom Range'
            },
            opens: "left",
            autoApply: true,
            maxDate: new Date(),
            eventHandlers: {
                'apply.daterangepicker': function(evt, picker) {
                    if (evt && evt.model) {
                        var endDate = moment(evt.model.endDate).startOf('day').valueOf();
                        var startDate = moment(evt.model.startDate).startOf('day').valueOf();
                        var today = moment().startOf('day').valueOf();
                        var last2Yrs = moment().subtract(2, 'year').startOf('day').valueOf();
                        if (startDate == last2Yrs && endDate == today) {
                            $scope.showTillNow = true;
                        } else {
                            $scope.showTillNow = false;
                        }
                    }
                }

            }
        }
    }

    $scope.showAnalyseFurther = function(flag){
        $scope.analyzeFurther.enabled = flag;
        if(flag){
            var issueItem = $scope.insightData.selectedIssueItem;
            var issue = $scope.insightData.selectedIssue;
            var category = issue.Name;
            var selectedAsset = $scope.insightData.selectedAsset;
            var readingTypeId = [issueItem.readingTypeId];
            var dayOffset = issueItem.dayOffset;
            var dateOfIssue = issueItem.date;
            if(category == "Voltage Imbalance")
                readingTypeId = [2003,2016,2017,2018];
            else if(category == "Current Imbalance")
                readingTypeId = [2004,2019,2020,2021];
            var sensorId = selectedAsset.SensorId;
            var selectedReadingTypes = [];
            if(readingTypeId){
                $scope.readingTypes.forEach(function(curType){
                    if(readingTypeId.indexOf(curType.readingtypeid)>=0)
                    {
                        selectedReadingTypes.push(curType);
                    }
                });
            };
            $scope.analyzeFurther.selectedReadingTypes = selectedReadingTypes;
            $scope.analyzeFurther.selectedSensors = sensorId;
            if(dayOffset){
                $scope.analyzeFurther.date = {
                    startDate : moment(dateOfIssue).subtract(dayOffset, 'days'),
                    endDate : moment(dateOfIssue)
                };
            }
            else{
                $scope.analyzeFurther.date = {
                    startDate : moment(dateOfIssue),
                    endDate : moment(dateOfIssue)
                };
            }
            $scope.analyzeFurther.dateRangeOpts.ranges = {
                'Week': [moment(dateOfIssue).subtract(1, 'weeks'), moment(dateOfIssue)],
                'Month': [moment(dateOfIssue).subtract(1, 'months'), moment(dateOfIssue)]
            };
            $scope.applyFurtherAnalyze();
            Analytics.trackEvent('Network Insights', 'Analyze further enabled : ' + $scope.insightData.selectedIssueItem.name, $state.current.name);
        }
        else{
            $scope.analyzeFurther.selectedReadingTypes = [];
            delete $scope.analyzeFurther.selectedSensors;
            delete $scope.analyzeFurther.graphData;
            $scope.applyFurtherAnalyze();
            try{
                $('html, body').animate({
                    scrollTop: $("#networkInsight-lineChart").offset().top - 140
                }, 1000);
                scrolled = true;
            }catch(ex){}
        }
    }

    $scope.$watch('analyzeFurther.date', function(newDate) {
        if(newDate)
            $scope.applyFurtherAnalyze();
    });

    $scope.applyFurtherAnalyze = function(item) {
        var opts = $scope.analyzeFurther;
        if (!opts || !opts.selectedReadingTypes)
            return;
        var totalItems = opts.selectedReadingTypes.length;
        var done = 0;
        var graphs = [];

        // check if maximumParameter selection if reached then show alert message by nirali.patel

        if ($scope.analyzeFurther.selectedReadingTypes.length >= $scope.maximumParameter && $scope.analyzeFurther.selectedReadingTypes.indexOf(item) == -1) {
            bootbox.alert('Maximum ' + $scope.maximumParameter + ' parameters are allowed');
            return;
        }


        loading(true);
        if(opts.selectedReadingTypes && opts.selectedReadingTypes.length>0){
            opts.selectedReadingTypes.forEach(function(curType){
                var req = {
                    fromdate : opts.date.startDate.format("YYYY-MM-DD"),
                    todate : opts.date.endDate.format("YYYY-MM-DD"),
                    sensorsid : opts.selectedSensors,
                    readingtypeid : curType.readingtypeid
                }
                timeseriesService.get(req).then(function(response) {
                    var data = response.data[0];
                    done++;
                    graphs.push({
                        type : "furtherAnalyze",
                        name: curType.readingtypename,
                        chartType : "line",
                        animation: false,
                        timeSeries: data.timeSeries,
                        readingtype: data.readingType,
                        id: "Graph_" + utils.random()
                    });
                    if(totalItems == done)
                    {
                        loading(false);
                        $scope.analyzeFurther.graphData = graphs;
                        try{
                            $('html, body').animate({
                                scrollTop: $("#furtherAnalyze-lineChart").offset().top - 140
                            }, 1000);
                            scrolled = true;
                        }catch(ex){}
                    }
                });
            });
        }
        else{
            loading(false);
            delete $scope.analyzeFurther.graphData;
        }
    }

    $scope.getBillingLocations = function(cb){
        apiService.network_get_issue_summary().then(function(response) {
            cb(response);
        });
    }

    //Init Data
    $scope.init = function(){
        $scope.holidays = [];
        if ($scope.refreshInProgress)
            return;
        $scope.refreshInProgress = true;
        loading(true);
        apiService.profile_get().then(function(profile) {
            if(profile && profile.data.plantholidays && profile.data.plantholidays.length>0){
                var holidays = profile.data.plantholidays;
                for (var i = 0; i < holidays.length; i++) {
                    $scope.holidays.push({
                        date : holidays[i].date,
                        name : holidays[i].name
                    });
                }
            }
            $scope.insight.selectedBillingLocation = $scope.billingLocations[0].LocationId;
            $scope.fetchSummary();
        });
    }
    $scope.init();
}

smartsenseApp.factory('networkInsightsService', networkInsightsService);

networkInsightsService.$inject = ['$http', 'timeseriesService', 'SETTINGS', 'data'];

function networkInsightsService($http, timeseriesService, SETTINGS, data) {

    var filters = {
        category: [{
            label: 'All',
            value: ''
        }, {
            label: 'Health',
            value: 'health'
        }, {
            label: 'Energy',
            value: 'energy'
        }],
        type: [{
            label: 'All',
            value: ''
        }, {
            label: 'Asset',
            value: 'assets'
        }, {
            label: 'Tags',
            value: 'tags'
        }, {
            label: 'Plant',
            value: 'overall'
        }],
        status: [{
            label: 'All',
            value: 'all'
        }, {
            label: 'Open',
            value: 'open'
        }, {
            label: 'Ignored',
            value: 'ignored'
        }, {
            label: 'Resolved',
            value: 'resolved'
        }]
    };

    var service = {
        filters: filters,
        createFlags: createFlags,
        generatePieChartData: generatePieChartData,
        createPlotLines : createPlotLines,
        createPlotBands : createPlotBands
    };

    return service;

    //////////

    function createFlags(flags) {
        var chartFlagSeries = [];
        for(var ts in flags){
            chartFlagSeries.push({
                x: parseInt(ts) * 1000,
                title: "!",
                text: utils.formatCurrency(flags[ts], true, true)
            });
        }
        return chartFlagSeries;
    }

    function createPlotLines(points){
        var lines = {};
        for(var type in points){
            var curType = points[type];
            var plotLines = [];
            for(var ts in curType){
                if(!isNaN(parseInt(ts)))
                {
                    plotLines.push({
                        value: parseInt(ts) * 1000,
                        pointValue : curType[ts],
                        color: '#f45b5b',
                        width:1,
                        zIndex:4,
                        label: {
                            visible : false
                        }
                    });
                }
            }
            lines[type] = plotLines;
        }
        return lines;
    }

    function createPlotBands(points, category){
        if(category != "Underload")
            return [];
        var shiftColors = ['#ddf7fa', '#ebfada', '#f2f1f1', '#f6e0fa', '#FCFFC5'];
        if(!points)
            return [];
        var plotBands = [];
        var i = 0;
        for(var ts in points){
            var curPoint = points[ts];
            if(curPoint && curPoint.starttime)
            {
                plotBands.push({
                    from: parseInt(curPoint.starttime) * 1000,
                    to: parseInt(curPoint.endtime) * 1000,
                    color: curPoint.shiftcolorcode || shiftColors[i],
                    legend : {
                        color : curPoint.shiftcolorcode || shiftColors[i],
                        label : curPoint.name
                    },
                    label: {
                        visible : false
                    }
                });
                i++;
            }
        }
        return plotBands;
    }

    function generatePieChartData(issues) {
        var issueMapping = {};
        if (issues && issues.length > 0) {
            for (var i = 0; i < issues.length; i++) {
                var curIssue = issues[i];
                issueMapping[curIssue.Category] = issueMapping[curIssue.Category] || [];
                issueMapping[curIssue.Category].push(curIssue);
            }
        }
        var pieChartData = [];
        for (var type in issueMapping) {
            pieChartData.push({
                name: type,
                unit: '',
                y: issueMapping[type].length,
                value: issueMapping[type].length,
                color: type == 'Energy' ? '#437EDE' : '#B8E986',
            });
        }
        var pieChartConfig = {
            tooltip: {
                pointFormatter: function() {
                    return '<b> Total : ' + this.value + '</b>';
                },
                shared: true
            },
            colorByPoint: true,
            data: pieChartData
        }
        return pieChartConfig;

    }

}

smartsenseApp.controller('MotorInsightsController', MotorInsightsController);

MotorInsightsController.$inject = ['$scope', '$filter', 'timeseriesService', 'readingTypeService', 'grainService', 'data', 'loading', 'motorInsightsService', '$timeout', '$compile', 'profileService', 'growl', '$state', 'Analytics', 'apiService'];

function MotorInsightsController($scope, $filter, timeseriesService, readingTypeService, grainService, data, loading, motorInsightsService, $timeout, $compile, profileService, growl, $state, Analytics, apiService) {
    //Default parameters
    $scope.insightInfo = {
        fromDate : moment().subtract(1, 'month').startOf("month"),
        toDate : moment(),
        selectedIssue : null,
        calendarIssueData : null,
        filter : null,
        actiontaken : {
            actionDate : new Date(),
            act : {}
        },
        graphData : []
    };

    /*Get list of readingtypes*/
    readingTypeService.getAll().then(function(data) {
        $scope.readingTypes = data.data;
    });

    $scope.graphOptions = {
        chartTypeBasedOnScalar : true,
        hideXAxisLabels : true,
        hideYAxisLabels : true,
        sameyAxis: 0
    };

    $scope.loadingGraphOptions = {
        chart: {
            height: 250
        },
        hideXAxisLabels : true,
        hideYAxisLabels : true,
        sameyAxis: 0,
        onlyDataName : true
    };

    $scope.hasAnyActionSelected = function(acts){
        var hasSelection = false;
        for(var item in acts){
            if(item && acts[item])
                hasSelection = true;
        }
        return hasSelection;
    }

    $scope.isDateInRange = function(date, selection, summaryDate){
        var startDate = $scope.insightInfo.fromDate;
        var endDate = moment($scope.insightInfo.fromDate).add(1, "month").endOf('month');
        if(selection){
            endDate = moment($scope.insightInfo.toDate);
        }
        if(endDate.diff(moment())>0)
            endDate = moment();
        if(summaryDate){
            startDate = $scope.insightInfo.currentFromDate;
            endDate = $scope.insightInfo.currentToDate;
        }
        var range = moment().range(startDate, endDate);
        return range.contains(date);
    };

    $scope.$watch('insightInfo.fromDate', function(newDate, oldDate) {
        if (newDate && newDate != oldDate) {
            var mDate = moment(newDate);
            if(newDate){
                if(!$scope.isDateInRange($scope.insightInfo.toDate)){
                    $scope.insightInfo.toDate = moment($scope.insightInfo.fromDate).add(1, "month").endOf('month');
                    if($scope.insightInfo.toDate.diff(moment())>0)
                        $scope.insightInfo.toDate = moment();
                }
            }
        }
    }, false);

    /* Following functions binds with the date change. Responsible for enabling/disabling dates according to selected startDate/endDate of report */

    $scope.endDateBeforeRender = endDateBeforeRender;
    $scope.endDateOnSetTime = endDateOnSetTime;
    $scope.startDateBeforeRender = startDateBeforeRender;
    $scope.startDateOnSetTime = startDateOnSetTime;

    $scope.actionDateBeforeRender = actionDateBeforeRender;

    function startDateOnSetTime() {
        $scope.$broadcast('start-date-changed');
    }

    function endDateOnSetTime() {
        $scope.$broadcast('end-date-changed');
    }

    function startDateBeforeRender($dates) {
        $dates.filter(function(date) {
            return date.localDateValue() > new Date().getTime();
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    function actionDateBeforeRender($dates) {
        $dates.filter(function(date) {
            var issueInfo = $scope.insightInfo.selectedIssueInfo;
            if(issueInfo){
                var evenddate = issueInfo.eventdate;
                return date.localDateValue() > new Date().getTime() || date.localDateValue() < moment(evenddate, "YYYY-MM-DD").valueOf();
            }
            else{
                return date.localDateValue() > new Date().getTime();
            }
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    function endDateBeforeRender($dates) {
        $dates.filter(function(date) {
            return !$scope.isDateInRange(moment(date.localDateValue()));
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    /*Insights new APIs*/
    $scope.clearSelections = function(){
        $scope.insightInfo.actiontaken = {
            actionDate : new Date(),
            act : {}
        };
        $scope.insightInfo.calendarIssueData =
        $scope.insightInfo.filter =
        $scope.insightInfo.selectedIssueInfo =
        $scope.insightInfo.selectedIssue =
        $scope.insightInfo.selectedAsset =
        $scope.insightInfo.selectedCalendarDate =
        $scope.insightInfo.graphData = null;
    };

    // Get most recent event date on load and set it as a end date in calendar
    $scope.getMostRecentEventDate = function(callback){
        apiService.motor_get_event_date().then(function(response) {
            if(callback)
                callback(moment(response.data.LastEventTime * 1000));
        });
    }

    //Get issue data from server for specified date range
    $scope.fetchIssueSummary = function(){
        $scope.clearSelections();
        $scope.refreshInProgress = true;
        loading(true);

        var startDate = moment($scope.insightInfo.fromDate).format("YYYY-MM-DD");
        var endDate = moment($scope.insightInfo.toDate).format("YYYY-MM-DD");

        apiService.motor_get_issue_summary(startDate, endDate).then(function(response) {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.insightInfo.currentFromDate = startDate;
            $scope.insightInfo.currentToDate = endDate;
            $scope.serverNotRecheable = false;
            if (response && response.data) {
                $scope.processData(response.data)
            }
        }, function(error) {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });
    };

    $scope.setFilter = function(type){
        $scope.insightInfo.filter = type;
        $scope.insightInfo.selectedAsset = false;
        delete $scope.insightInfo.selectedIssue;
        $scope.showLocationsForCategory(0);
        if(typeof $scope.insightInfo.selectedIssue != "undefined")
        {
            $scope.showLocationIssues($scope.insightInfo.records[$scope.insightInfo.filter].Insights[$scope.insightInfo.selectedIssue].assetData[0]);
        }
        $scope.renderDonutChart();
        Analytics.trackEvent('Motor Insights', 'Filter Changed To Show : ' + type, $state.current.name);
    }

    $scope.processData = function(data){
        //Default values for reponse, this will help to handle failure scenario
        var defaultInsightData = {
            Issues : {
                Open : {
                },
                Ignored : {
                },
                Resolved : {
                },
                All : {
                }
            },
            Tickets : {
                Open : {
                },
                Ignored : {
                },
                Resolved : {
                },
                All : {
                }
            }
        };
        $scope.insightInfo.records = $.extend(true, defaultInsightData, data);

        function filterItems(result, catList, assetList){
            catList = catList || [];
            var motorInsightsData = {
                all : {
                    Count : 0,
                    Insights : {}
                },
                open : {
                    Count : 0,
                    Insights : {}
                },
                ignored : {
                    Count : 0,
                    Insights : {}
                },
                resolved : {
                    Count : 0,
                    Insights : {}
                }
            }

            for(var key in result)
            {
                var allItems = result[key];
                for (var i = 0; i < allItems.length; i++) {
                    var data = allItems[i];
                    var assetid = data.assetid;
                    var assetname = data.assetname;
                    var dates = data.dates || [];
                    for (var j = 0; j < dates.length; j++) {
                        var curDate = dates[j] || {};
                        function addItemBasedOnType(obj, status){
                            if((status == "Open" && curDate.eventstatus != "Resolved" && curDate.eventstatus != "Ignored") || (curDate.eventstatus == status || !status)){
                                obj.Insights[key] = obj.Insights[key] || {
                                    Count : 0,
                                    Name : key,
                                    assetData : []
                                };
                                var assets = obj.Insights[key].assetData;
                                var hasItem = false;
                                if(assets.length>0){
                                    for (var k = 0; k < assets.length; k++) {
                                        if(assets[k].assetid == assetid){
                                            hasItem = true;
                                            if(!assets[k].dates)
                                                assets[k].dates = [];
                                            obj.Count++;
                                            obj.Insights[key].Count++;
                                            assets[k].dates.push(curDate);
                                        }
                                    }
                                }
                                if(!hasItem){
                                    obj.Count++;
                                    obj.Insights[key].Count++;
                                    assets.push({
                                        assetid : assetid,
                                        assetname : assetname,
                                        dates : [curDate]
                                    });
                                }
                            }
                        }
                        addItemBasedOnType(motorInsightsData.all);
                        addItemBasedOnType(motorInsightsData.resolved, "Resolved");
                        addItemBasedOnType(motorInsightsData.ignored, "Ignored");
                        addItemBasedOnType(motorInsightsData.open, "Open");
                    }
                }
            }
            for(var type in motorInsightsData){
                var curType = motorInsightsData[type] || {Insights : {}};
                catList.forEach(function(listItem){
                    if(typeof curType.Insights[listItem.Name] == "undefined"){
                        curType.Insights[listItem.Name] = {
                            Count : 0,
                            assetname : "",
                            assetData : [],
                            Name : listItem.Name,
                            dates : [],
                            colorCode : listItem.Color
                        }
                    }
                    else{
                        curType.Insights[listItem.Name].colorCode = listItem.Color;
                    }
                });
                var _insights = [];
                for(var ci in curType.Insights){
                    var tmp = curType.Insights[ci];
                    tmp.Name = ci;
                    var assetData = tmp.assetData;
                    function hasAssetInfo(id){
                        var hasData;
                        assetData.forEach(function(curAsset){
                            if(curAsset.assetid == id + "")
                                hasData = true;
                        });
                        return hasData;
                    }
                    if(type == "all"){
                        assetList.forEach(function(asset){
                            var curId = asset.sensorid;
                            var curName = asset.name;
                            if(!hasAssetInfo(curId)){
                                tmp.assetData.push({
                                    assetid : curId,
                                    assetname : curName,
                                    noissues : true,
                                    dates :[]
                                });
                            }
                        });
                    }
                    _insights.push(tmp)
                }
                _insights = _insights.sort(function(a, b){
                    return parseInt(b.Count) - parseInt(a.Count);
                });
                curType.Insights = _insights;
            }
            return {
                All : motorInsightsData.all,
                Open : motorInsightsData.open,
                Resolved : motorInsightsData.resolved,
                Ignored : motorInsightsData.ignored
            }
        }

        $scope.insightInfo.records = filterItems($scope.insightInfo.records.Events, $scope.insightInfo.records.CategoryList, $scope.insightInfo.records.AssetList);
        delete $scope.insightInfo.records.Events;
        $scope.selectDefaultItems();
    }

    $scope.selectDefaultItems = function(){
        $scope.insightInfo.filter = $scope.insightInfo.filter || "Open";
        delete $scope.insightInfo.selectedIssue;
        $scope.insightInfo.selectedAsset = false;
        $scope.showLocationsForCategory(0);
        if(typeof $scope.insightInfo.selectedIssue != "undefined")
        {
            $scope.showLocationIssues($scope.insightInfo.records[$scope.insightInfo.filter].Insights[$scope.insightInfo.selectedIssue].assetData[0]);
        }
        $scope.renderDonutChart();
    }

    $scope.renderDonutChart = function(){
        function getPerc(val, total){
            return Math.round((100 * val) / total);
        }
        var insightData = $scope.insightInfo.records;
        var insightInfo = $scope.insightInfo;
        var filter = insightInfo.filter;
        if(insightData[filter]){
            var seriesData = [];
            var index = 0;
            insightData[filter].Insights.forEach(function(insight){
                var item = insightData[filter].Insights[index];
                seriesData.push({
                    name : item.Name,
                    y : item.Count,
                    color : item.colorCode,
                    perc : getPerc(item.Count, insightData[filter].Count),
                    selected : insightInfo.selectedIssue == index,
                    sliced: insightInfo.selectedIssue == index
                });
                index++;
            });
            var selectedInsight = insightData[filter].Insights[insightInfo.selectedIssue];
            var chartText = "<div class='chart-text'>Event(s) : "+selectedInsight.Count+" ("+getPerc(selectedInsight.Count, insightData[filter].Count)+"%)</div>";

            insightData[filter].issueChartData = {
                series :
                [
                    {
                        name: 'Events',
                        data: seriesData
                    }
                ],
                options : {
                    legend : {
                        visible : false,
                        enabled : false
                    },
                    title : {
                        text : chartText
                    },
                    onSelect : function(evt, point){
                        insightData[filter].issueChartData.options.title.text = "<div class='chart-text'>Event(s) : "+point.options.y+" ("+point.options.perc+"%)</div>";
                        var index = $scope.getCategoryIndex(point.name);
                        if(typeof index != "undefined"){
                            $timeout(function(){
                                $scope.showLocationsForCategory(index);
                                $scope.$apply();
                            }, 100);
                        }
                    }
                }
            }
        }
        $scope.insightInfo.records = insightData;
    };

    $scope.getCategoryIndex = function(name){
        var res;
        var index = 0;
        $scope.insightInfo.records[$scope.insightInfo.filter].Insights.forEach(function(insight){
            if(insight.Name == name)
                res = index;
            index++;
        });
        return res;
    }

    $scope.showLocationsForCategory = function(index){
        $scope.showAnalyseFurther(false);
        $scope.insightInfo.graphData = false;
        $scope.insightInfo.selectedIssue = index;
        if(typeof $scope.insightInfo.selectedIssue != "undefined")
        {
            $scope.showLocationIssues($scope.insightInfo.records[$scope.insightInfo.filter].Insights[$scope.insightInfo.selectedIssue].assetData[0]);
        }
        $scope.renderDonutChart();
        $scope.renderDualCalendar();
    }

    $scope.showLocationIssues = function(asset){
        $scope.showAnalyseFurther(false);
        $scope.insightInfo.selectedAsset = asset;
        if(!asset){
            return;
        }
        $scope.insightInfo.graphData = false;
        $scope.renderDualCalendar();
        if(asset.noissues){
            $scope.showGraphForAssetWithNoIssues(asset);
        }
    }

    $scope.findIssueInfo = function(issueId){
        var asset = $scope.insightInfo.selectedAsset;
        if(asset){
            for (var i = 0; i < asset.dates.length; i++) {
                var curIssue = asset.dates[i];
                if(curIssue.eventid == issueId)
                    return curIssue;
            }
        }
        return {};
    }

    $scope.showGraphForAssetWithNoIssues = function(asset){
        $scope.showAnalyseFurther(false);
        if(!asset)
            return;
        $scope.insightInfo.graphData = false;
        var assetItem = $scope.insightInfo.selectedAsset;
        if(!assetItem)
            return;

        $scope.insightInfo.selectedIssueInfo = asset;
        var issue = {
            StartDate : $scope.insightInfo.fromDate.format("YYYY-MM-DD"),
            EndDate : $scope.insightInfo.toDate.format("YYYY-MM-DD"),
            SensorsIds : [asset.assetid]
        };
        $scope.insightInfo.calendarIssueData = issue;
        $scope.showGraph(issue);
    }

    $scope.showGraphForDate = function(id, marker, date){
        $scope.insightInfo.actiontaken = {
            actionDate : new Date(),
            act : {}
        };
        $scope.resetActionFormValidation();
        $scope.showAnalyseFurther(false);
        var issueId = $("div[uid='"+id+"']").attr("issue-id");
        var assetId = $("div[uid='"+id+"']").attr("asset-id");
        var readingtypeId = $("div[uid='"+id+"']").attr("readingtypeId");
        var evtdate = $("div[uid='"+id+"']").attr("evtdate");
        if(!issueId)
            return;
        $scope.insightInfo.graphData = false;
        var assetItem = $scope.insightInfo.selectedAsset;
        if(!assetItem)
            return;
        var issueInfo = $scope.findIssueInfo(issueId);
        if(!issueInfo)
            return;
        issueInfo.SensorId = assetId;
        $scope.insightInfo.selectedIssueInfo = issueInfo;
        var calendars = $('#calendar1, #calendar2');
        var parent = calendars.find(".date[data-date='"+marker+"']").parent();
        $scope.insightInfo.selectedCalendarDate = moment(date, "YYYY-MM-DD").format("DD MMMM, YYYY");
        if(parent.hasClass('issue')){
            calendars.find(".selected").removeClass('selected');
            parent.addClass('selected');
            var issue = {
                EventDate : date,
                EventId : issueId,
                StartDate : issueInfo.eventstartdate || date,
                EndDate : issueInfo.eventenddate || date,
                SensorsIds : [assetId],
                ReadingTypeId : issueInfo.readingtypeid
            };
            $scope.insightInfo.calendarIssueData = issue;
            //$scope.getActivityLog();
            $scope.showGraph(issue);
        }
    }

    $scope.renderDualCalendar = function(){
        var assetItem = $scope.insightInfo.selectedAsset;
        var markers = [];
        if(assetItem){
            markers = assetItem.dates;
        }
        // console.log(markers);
        $scope.dualCalendar = {
            firstMonth : $scope.insightInfo.fromDate,
            onBeforeRender : function($view, $dates, $leftDate, $upDate, $rightDate){
                $dates.filter(function(date) {
                    return !$scope.isDateInRange(moment(date.localDateValue()), true, true);
                }).forEach(function(date) {
                    date.selectable = false;
                });

                $scope.dualCalendar.delay(function(){
                    var calendars = $('#calendar1, #calendar2');
                    calendars.find("td.active").removeClass('active');
                    function bindDates(calendar){
                        var month;
                        calendar.find("thead").find("tr:first").each(function(){
                            var dt = "";
                            if(calendar.is("#calendar1"))
                                dt = moment($scope.dualCalendar.firstMonth).format("MMMM YYYY");
                            else
                                dt = moment($scope.dualCalendar.secondMonth).format("MMMM YYYY");
                            month = dt;
                            $(this).html("<th colspan='7'>"+dt+"</th>");
                        });
                        calendar.find("td.day:visible:not(.past)").unbind().each(function(){
                            var date = $(this).text();
                            $(this).text("");
                            var curDate = moment(month + "-" + date, "MMMM YYYY-DD");
                            var _date = curDate.format("DD-MM-YYYY");
                            var _dateFormatted = curDate.format("YYYY-MM-DD");
                            //console.log(curDate);
                            if(!$scope.isDateInRange(curDate, true, true)){
                                $(this).addClass('strike');
                            }
                            var id = generateRandomCode();
                            var html = '<div ng-click="showGraphForDate(\''+id+'\',\''+_date+'\', \''+_dateFormatted+'\')" uid="'+id+'" class="date" data-date-formatted="'+_dateFormatted+'" data-date="'+_date+'"><div class="text">'+date+'</div><div class="bullet"></div></div>';
                            $(this).append($compile(html)($scope));
                        });
                        $scope.dualCalendar.addMarkers(calendar);
                    }
                    bindDates(calendars.filter("#calendar1"));
                    bindDates(calendars.filter("#calendar2"));
                }, 100);
            },
            addMarkers : function(calendar){
                calendar.find("div.date").removeClass('tool-tip').removeAttr('asset-id').removeAttr('issue-id').removeAttr("readingtypeId").removeAttr('title').each(function(){
                    $(this).closest('td').removeClass('issue').removeClass('holiday').removeClass('selected');
                });
                for (var i = 0; i < $scope.holidays.length; i++) {
                    var holiday = $scope.holidays[i];
                    calendar.find("div.date[data-date-formatted='"+holiday.date+"']").addClass('tool-tip').attr("title", holiday.name).closest('td').addClass('holiday');
                }
                var text = assetItem.Name;
                var assetid = assetItem.assetid;
                for (var i = 0; i < markers.length; i++) {
                    var date = markers[i];
                    var id = date.eventid;
                    var dateToMatch = moment(date.eventdate).format("YYYY-MM-DD");
                    var readingtypeId = date.readingtypeid;
                    calendar.find("div.date[data-date-formatted='"+dateToMatch+"']").attr("evtdate", date.eventdate).attr("readingtypeId", readingtypeId).attr("asset-id", assetid).attr("issue-id", id).addClass('tool-tip').attr("title", text).closest('td').addClass('issue');
                }

                calendar.find(".tool-tip").tooltip({
                    container : "body",
                    placement : "top"
                });
            },
            secondMonth : moment($scope.insightInfo.fromDate).add(1, "month"),
            delayTimer : 0,
            delay : (function () {
                return function (callback, ms) {
                    $timeout.cancel($scope.dualCalendar.delayTimer);
                    $scope.dualCalendar.delayTimer = $timeout(callback, ms);
                };
            })()
        };
        $scope.$broadcast('re-render-dual-calendar');
        $scope.$broadcast('re-render-dual-calendar-2');
    }

    $scope.showGraph = function(issue) {
        $scope.showAnalyseFurther(false);
        $scope.insightInfo.graphData = [];
        $scope.getBaseline(issue);
    }

    $scope.getBaseline = function(issue) {
        var selectedIssueInfo = $scope.insightInfo.selectedIssueInfo;
        $scope.refreshInProgress = true;
        loading(true);

        apiService.motor_get_baseline(issue, $scope.insightInfo.currentFromDate, $scope.insightInfo.currentToDate).then(function(response) {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = false;
            if (response && response.data) {
                $scope.insightInfo.graphData = response.data;
                selectedIssueInfo.activityLog = $scope.insightInfo.graphData.ActivityLog;
                selectedIssueInfo.actionSummary = $scope.insightInfo.graphData.ActionSummary;
                if($("#networkInsight-lineChart").length>0){
                    $('html, body').animate({
                        scrollTop: $("#networkInsight-lineChart").offset().top + 500
                    }, 1000);
                }
                if(selectedIssueInfo.actionSummary && selectedIssueInfo.actionSummary.eventstatus && selectedIssueInfo.actionSummary.eventstatus != "Open"){
                    if(selectedIssueInfo.actionSummary.eventuserreponse){
                        var response = selectedIssueInfo.actionSummary.eventuserreponse.split(",");
                        response.forEach(function(item){
                            $scope.insightInfo.actiontaken.act[item] = true;
                        });
                    }
                    $scope.insightInfo.actiontaken.comment = selectedIssueInfo.actionSummary.eventusercomment;
                    $scope.insightInfo.actiontaken.action = selectedIssueInfo.actionSummary.eventstatus;
                    $scope.insightInfo.actiontaken.actionDate = moment(selectedIssueInfo.actionSummary.eventuserresponsedate);
                    $scope.insightInfo.actiontaken.hasAction = true;
                }
                else{
                    $scope.insightInfo.actiontaken = {
                        actionDate : new Date(),
                        act : {}
                    };
                }
                var readingType = $scope.insightInfo.graphData && $scope.insightInfo.graphData.TicketTimeSeries && $scope.insightInfo.graphData.TicketTimeSeries.readingType ? $scope.insightInfo.graphData.TicketTimeSeries.readingType : false;
                if(readingType){
                    $scope.insightInfo.graphData.TicketTimeSeries.name = readingType.readingtypename;
                    $scope.insightInfo.graphData.TicketTimeSeries.chartType = "line";
                    if(readingType.readingtypeid == 5026){
                        $scope.insightInfo.graphData.TicketTimeSeries.yaxis = {
                            min : 0,
                            max : 100
                        };
                    }
                }
                $scope.insightInfo.graphData.TicketTimeSeries = [$scope.insightInfo.graphData.TicketTimeSeries];

                if($scope.insightInfo.graphData.Imbalance){
                    var imbalance = [];
                    $scope.insightInfo.graphData.Imbalance.CurrentImbalance.name = "Current Imbalance";
                    $scope.insightInfo.graphData.Imbalance.CurrentImbalance.chartType = "line";

                    for (var i = 0; i < $scope.insightInfo.graphData.Imbalance.CurrentImbalance.timeseries.length; i++) {
                        if($scope.insightInfo.graphData.Imbalance.CurrentImbalance.timeseries[i].value)
                            $scope.insightInfo.graphData.Imbalance.CurrentImbalance.timeseries[i].value = $scope.insightInfo.graphData.Imbalance.CurrentImbalance.timeseries[i].value;
                    }
                    imbalance.push($scope.insightInfo.graphData.Imbalance.CurrentImbalance);

                    $scope.insightInfo.graphData.Imbalance.VoltageImbalance.name = "Voltage Imbalance";
                    $scope.insightInfo.graphData.Imbalance.VoltageImbalance.chartType = "line";
                    for (var i = 0; i < $scope.insightInfo.graphData.Imbalance.VoltageImbalance.timeseries.length; i++) {
                        if($scope.insightInfo.graphData.Imbalance.VoltageImbalance.timeseries[i].value)
                            $scope.insightInfo.graphData.Imbalance.VoltageImbalance.timeseries[i].value = $scope.insightInfo.graphData.Imbalance.VoltageImbalance.timeseries[i].value;
                    }
                    imbalance.push($scope.insightInfo.graphData.Imbalance.VoltageImbalance);

                    var lineCosntants = $scope.insightInfo.graphData.Imbalance.lineconstant;
                    var lineConstantGraphs = [];
                    for(var lineItem in lineCosntants){
                        var lineItemValue = lineCosntants[lineItem];
                        var customLine = false;
                        var constantLine = {
                            timeseries : [],
                            "readingType": {
                                "readingtypeid": null,
                                "readingtypename": lineItem,
                                "parentreadingtypeid": null,
                                "export": false,
                                "timebased": false,
                                "scalar": true,
                                "priority": 1
                            }
                        };
                        $scope.insightInfo.graphData.Imbalance.CurrentImbalance.timeseries.forEach(function(curTS){
                            constantLine.timeseries.push({
                                timeStamp : curTS.timeStamp,
                                value : lineItemValue.Value || lineItemValue
                            });
                        });
                        if(customLine){
                            lineConstantGraphs.push(constantLine);
                        }
                        else{
                            lineConstantGraphs.push({
                                type : "lineConstant",
                                name: constantLine.name || lineItem,
                                chartType : "line",
                                lineWidth : 1,
                                dashStyle : "Dash",
                                animation: false,
                                timeseries: constantLine.timeseries,
                                readingtype: constantLine.readingType,
                                unit : lineItemValue.Unit,
                                id: "Graph_" + utils.random()
                            });
                        }
                    }
                    $scope.insightInfo.graphData.Imbalance.imbalanceProcessed = imbalance.concat(lineConstantGraphs);
                }

                if($scope.insightInfo.graphData.Loading){
                    var current = [];
                    for(var item in $scope.insightInfo.graphData.Loading.CurrentMonth){
                        var curData = $scope.insightInfo.graphData.Loading.CurrentMonth[item];
                        curData.name = item;
                        current.push(curData);
                    }
                    $scope.insightInfo.graphData.Loading.currentmonthProcessed = current;

                    var prev = [];
                    for(var item in $scope.insightInfo.graphData.Loading.PreviousMonth){
                        var curData = $scope.insightInfo.graphData.Loading.PreviousMonth[item];
                        curData.name = item;
                        prev.push(curData);
                    }
                    $scope.insightInfo.graphData.Loading.prevmonthProcessed = prev;

                    $scope.insightInfo.graphData.Loading.KW.name = "KW";
                    $scope.insightInfo.graphData.Loading.KW.color = "#437ede";
                    $scope.insightInfo.graphData.Loading.KW.chartType = "line";

                    var lineCosntants = $scope.insightInfo.graphData.Loading.lineconstant;
                    var lineConstantGraphs = [];
                    for(var lineItem in lineCosntants){
                        var lineItemValue = lineCosntants[lineItem];
                        var customLine = false;
                        var constantLine = {
                            timeseries : [],
                            "readingType": {
                                "readingtypeid": null,
                                "readingtypename": lineItem,
                                "parentreadingtypeid": null,
                                "export": false,
                                "timebased": false,
                                "scalar": true,
                                "priority": 1
                            }
                        };
                        if(lineItem == "OverLoadLimit"){
                            constantLine = {
                                name : "Overload Limit",
                                color : "red",
                                chartType : "line",
                                lineWidth : 1,
                                dashStyle : "Dash",
                                timeseries : [],
                                readingType : {
                                   export : false,
                                   parentreadingtypeid : null,
                                    priority : 1,
                                    readingtypeid : null,
                                    readingtypename : "Overload Limit",
                                    scalar : false,
                                    timebased : false
                                },
                                unit : lineItemValue.Unit
                            };
                            $scope.insightInfo.graphData.Loading.OverLoadLimit = lineItemValue;
                            customLine = true;
                        }
                        else if(lineItem == "UnderLoadLimit"){
                            constantLine = {
                                name : "Underload Limit",
                                color : "blue",
                                chartType : "line",
                                lineWidth : 1,
                                dashStyle : "Dash",
                                timeseries : [],
                                readingType : {
                                   export : false,
                                   parentreadingtypeid : null,
                                    priority : 1,
                                    readingtypeid : null,
                                    readingtypename : "Underload Limit",
                                    scalar : false,
                                    timebased : false
                                },
                                unit : lineItemValue.Unit
                            };
                            $scope.insightInfo.graphData.Loading.UnderLoadLimit = lineItemValue;
                            customLine = true;
                        }
                        $scope.insightInfo.graphData.Loading.KW.timeseries.forEach(function(curTS){
                            constantLine.timeseries.push({
                                timeStamp : curTS.timeStamp,
                                value : lineItemValue.Value || lineItemValue
                            });
                        });
                        if(customLine){
                            lineConstantGraphs.push(constantLine);
                        }
                        else{
                            lineConstantGraphs.push({
                                type : "lineConstant",
                                name: constantLine.name || lineItem,
                                chartType : "line",
                                lineWidth : 1,
                                dashStyle : "Dash",
                                animation: false,
                                timeseries: constantLine.timeseries,
                                readingtype: constantLine.readingType,
                                unit : lineItemValue.Unit,
                                id: "Graph_" + utils.random()
                            });
                        }
                    }

                    /*Genrating loading stacked bar graphs*/
                    var curMonthData = $scope.insightInfo.graphData.Loading.CurrentMonth;
                    var prevMonthData = $scope.insightInfo.graphData.Loading.PreviousMonth;
                    var curWeekData = $scope.insightInfo.graphData.Loading.CurrentWeek;
                    var prevWeekData = $scope.insightInfo.graphData.Loading.PreviousWeek;
                    var selectedPeriodData = $scope.insightInfo.graphData.Loading.SelectedPeriod;
                    var barGraphCategories = ['Current Month', 'Previous Month', 'Current Week', 'Previous Week', 'Selected Period'];
                    var barGraphsSeries = [{
                        showInLegend: false,
                        name: 'Off Hours',
                        data: [
                            curMonthData.Off.Percent,
                            prevMonthData.Off.Percent,
                            curWeekData.Off.Percent,
                            prevWeekData.Off.Percent,
                            selectedPeriodData.Off.Percent],
                        color : "#b1e67b"
                    },{
                        showInLegend: false,
                        name: 'Under Loading',
                        data: [
                            curMonthData.UnderLoading.Percent,
                            prevMonthData.UnderLoading.Percent,
                            curWeekData.UnderLoading.Percent,
                            prevWeekData.UnderLoading.Percent,
                            selectedPeriodData.UnderLoading.Percent],
                        color : "#b9e2f7"
                    },{
                        showInLegend: false,
                        name: 'Normal Loading',
                        data: [
                            curMonthData.NormalLoading.Percent,
                            prevMonthData.NormalLoading.Percent,
                            curWeekData.NormalLoading.Percent,
                            prevWeekData.NormalLoading.Percent,
                            selectedPeriodData.NormalLoading.Percent],
                        color : "#feda56"
                    },{
                        showInLegend: false,
                        name: 'Over Loading',
                        data: [
                            curMonthData.OverLoading.Percent,
                            prevMonthData.OverLoading.Percent,
                            curWeekData.OverLoading.Percent,
                            prevWeekData.OverLoading.Percent,
                            selectedPeriodData.OverLoading.Percent],
                        color : "#fe9985"
                    }];

                    $scope.loadingBarChartOptions = {
                        chart : {
                            height:175
                        },
                        plotOptions: {
                            series: {
                                cursor: 'pointer',
                                point: {
                                    events: {
                                        click: function () {
                                            $scope.insightInfo.graphData.Loading.SelectedBarChart = this.category;
                                            $scope.$apply();
                                        }
                                    }
                                }
                            }
                        },
                        xAxis : {
                            categories : barGraphCategories
                        },
                        hideXAxisLabels : true,
                        hideYAxisLabels : true,
                        series : barGraphsSeries
                    };
                    $scope.insightInfo.graphData.Loading.SelectedBarChart = barGraphCategories[0];
                    $scope.insightInfo.graphData.Loading.kwProcessed = [$scope.insightInfo.graphData.Loading.KW].concat(lineConstantGraphs);
                }
                // console.log($scope.insightInfo.graphData);
            }
            $scope.setImbalanceGraphType("Imbalance");
        }, function(error) {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });
    }

    $scope.getOtherGraphsData = function(cb){
        var issue = $scope.insightInfo.calendarIssueData;
        if(!cb)
            return;
        if(!issue)
            cb();
        $scope.refreshInProgress = true;
        apiService.motor_get_baseline(issue, $scope.insightInfo.currentFromDate, $scope.insightInfo.currentToDate, true).then(function(response) {
            var lineGraphData = response.data;
            if(lineGraphData.Imbalance){
                var current = [];
                for(var item in lineGraphData.Imbalance.Current){
                    var curData = lineGraphData.Imbalance.Current[item];
                    curData.name = item;
                    curData.chartType = "line";
                    current.push(curData);
                }
                $scope.insightInfo.graphData.Imbalance.currentProcessed = current;
                var voltage = [];
                for(var item in lineGraphData.Imbalance.Voltage){
                    var curData = lineGraphData.Imbalance.Voltage[item];
                    curData.name = item;
                    curData.chartType = "line";
                    voltage.push(curData);
                }
                $scope.insightInfo.graphData.Imbalance.voltageProcessed = voltage;
            }
            cb();
        });
    }

    $scope.setImbalanceGraphType = function(type){
        if((type == "Voltage" || type == "Current") && (!$scope.insightInfo.graphData || (!$scope.insightInfo.graphData.Imbalance.voltageProcessed || !$scope.insightInfo.graphData.Imbalance.currentProcessed))){
            loading(true);
            $scope.getOtherGraphsData(function(){
                loading(false);
                $scope.insightInfo.selectedImbalanceGraphType = type;
            });
        }
        else
            $scope.insightInfo.selectedImbalanceGraphType = type;
    }

    $scope.getActivityLog = function(){
        var issueInfo = $scope.insightInfo.selectedIssueInfo;
        if(!issueInfo)
            return;
        var isseuId = issueInfo.IssueId;
        var tableName = issueInfo.TableName;
        apiService.motor_get_activity_log(isseuId, tableName).then(function(response) {
            $scope.insightInfo.selectedIssueInfo.activityLog = response.data.activityLogs;
        });
    }

    $scope.submitActivityLog = function(){
        var issueInfo = $scope.insightInfo.selectedIssueInfo;
        if(!issueInfo)
            return;

        loading(true);
        var curAct = $scope.insightInfo.actiontaken.action;
        apiService.motor_submit_activity_log(issueInfo, $scope.insightInfo.actiontaken).then(function(response) {
            angular.forEach($scope.actionForm, function (input) {
                if (input && input.hasOwnProperty('$viewValue')) {
                  input.$setPristine();
                }
            });
            growl.success("Activity saved.", {
                ttl: 3000
            });
            $scope.insightInfo.selectedIssueInfo.activityLog = response.data.ActivityLog;
            $scope.resetActionFormValidation();
            if(curAct != $scope.insightInfo.filter)
            {
                loading(false);
                $scope.insightInfo.actiontaken = {
                    actionDate : new Date(),
                    act : {}
                };
                $scope.fetchIssueSummary();
            }
            else{
                loading(false);
                $scope.insightInfo.actiontaken.hasAction = true;
            }
        }, function(err){
            growl.error("Error while saving activity. <br>" + err.message, {
                ttl: 3000
            });
        });
    }

    $scope.getTime = function(epoch){
        return moment(epoch*1000).format("DD/MM/YYYY hh:mm A");
    }

    $scope.hasSummary = function(){
        if($scope.insightInfo.selectedIssueInfo && $scope.insightInfo.selectedIssueInfo.Summary && Object.keys($scope.insightInfo.selectedIssueInfo.Summary).length>0)
            return true;
        else
            return false;
    }

    $scope.analyzeFurther = {
        enabled : false,
        date : {},
        readingTypes : [],
        grain : 900,
        dateRangeOpts : {
            locale: {
                applyClass: 'btn-green',
                applyLabel: "Apply",
                fromLabel: "From",
                format: "DD/MM/YYYY",
                toLabel: "To",
                cancelLabel: 'Cancel',
                customRangeLabel: 'Custom Range'
            },
            opens: "left",
            autoApply: true,
            maxDate: new Date(),
            eventHandlers: {
                'apply.daterangepicker': function(evt, picker) {
                    if (evt && evt.model) {
                        var endDate = moment(evt.model.endDate).startOf('day').valueOf();
                        var startDate = moment(evt.model.startDate).startOf('day').valueOf();
                        var today = moment().startOf('day').valueOf();
                        var last2Yrs = moment().subtract(2, 'year').startOf('day').valueOf();
                        if (startDate == last2Yrs && endDate == today) {
                            $scope.showTillNow = true;
                        } else {
                            $scope.showTillNow = false;
                        }
                    }
                }

            }
        }
    }

    $scope.showAnalyseFurther = function(flag){
        $scope.analyzeFurther.enabled = flag;
        if(flag){
            var issueItem = $scope.insightInfo.selectedIssueInfo;
            var selectedAsset = $scope.insightInfo.selectedAsset;
            var defaultParam = "kW";
            var dayOffset = issueItem.dayOffset;
            var dateOfIssue = issueItem.eventdate;
            var sensorId = selectedAsset.assetid;
            var selectedReadingTypes = [];
            if(defaultParam){
                $scope.readingTypes.forEach(function(curType){
                    if(defaultParam == curType.readingtypename)
                    {
                        selectedReadingTypes.push(curType);
                    }
                });
            };
            $scope.analyzeFurther.selectedReadingTypes = selectedReadingTypes;
            $scope.analyzeFurther.selectedSensors = sensorId;
            if(dayOffset){
                $scope.analyzeFurther.date = {
                    startDate : moment(dateOfIssue).subtract(dayOffset, 'days'),
                    endDate : moment(dateOfIssue)
                };
            }
            else{
                $scope.analyzeFurther.date = {
                    startDate : moment(dateOfIssue),
                    endDate : moment(dateOfIssue)
                };
            }
            $scope.analyzeFurther.dateRangeOpts.ranges = {
                'Week': [moment(dateOfIssue).subtract(1, 'weeks'), moment(dateOfIssue)],
                'Month': [moment(dateOfIssue).subtract(1, 'months'), moment(dateOfIssue)]
            };
            $scope.applyFurtherAnalyze();
            Analytics.trackEvent('Motor Insights', 'Analyze further enabled', $state.current.name);
        }
        else{
            $scope.analyzeFurther.selectedReadingTypes = [];
            delete $scope.analyzeFurther.selectedSensors;
            delete $scope.analyzeFurther.graphData;
            $scope.applyFurtherAnalyze();
            try{
                $('html, body').animate({
                    scrollTop: $("#networkInsight-lineChart").offset().top - 140
                }, 1000);
            }catch(ex){}
        }
    }

    $scope.$watch('analyzeFurther.date', function(newDate) {
        if(newDate)
            $scope.applyFurtherAnalyze();
    });

    $scope.applyFurtherAnalyze = function(item, remove){
        var opts = $scope.analyzeFurther;
        if(!opts || !opts.selectedReadingTypes)
            return;
        if(item){
            if(remove){
                var readingTypes = [];
                opts.selectedReadingTypes.forEach(function(rt){
                    if(rt.readingtypeid !== item.readingtypeid)
                        readingTypes.push(rt);
                });
                opts.selectedReadingTypes = readingTypes;
            }
            else
                opts.selectedReadingTypes.push(item);
        }
        var totalItems = opts.selectedReadingTypes.length;
        var done = 0;
        var graphs = [];
        loading(true);
        if(opts.selectedReadingTypes && opts.selectedReadingTypes.length>0){
            opts.selectedReadingTypes.forEach(function(curType){
                var req = {
                    fromdate : opts.date.startDate.format("YYYY-MM-DD"),
                    todate : opts.date.endDate.format("YYYY-MM-DD"),
                    sensorsid : opts.selectedSensors,
                    readingtypeid : curType.readingtypeid,
                    grain : {value : 15}
                }
                timeseriesService.get(req).then(function(response) {
                    var data = response.data[0];
                    done++;
                    graphs.push({
                        type : "furtherAnalyze",
                        name: curType.readingtypename,
                        chartType : "line",
                        animation: false,
                        timeseries: data.timeseries,
                        readingtype: data.readingType,
                        id: "Graph_" + utils.random()
                    });
                    if(totalItems == done)
                    {
                        loading(false);
                        $scope.analyzeFurther.graphData = graphs;
                        try{
                            $('html, body').animate({
                                scrollTop: $("#furtherAnalyze-lineChart").offset().top - 140
                            }, 1000);
                        }catch(ex){}
                    }
                });
            });
        }
        else{
            loading(false);
            delete $scope.analyzeFurther.graphData;
        }
    }

    $scope.setForm = function(form){
        $scope.actionForm = form;
    }

    $scope.resetActionFormValidation = function(){
        var form = $scope.actionForm;
        if(!form)
            return;
        if(form.$setPristine){
            form.$setPristine();
        } else {
            form.$pristine = true;
            form.$dirty = false;
            angular.forEach(form, function (input, key) {
                if (input.$pristine)
                    input.$pristine = true;
                if (input.$dirty) {
                    input.$dirty = false;
                }
            });
        }
    };

    //Init Data
    $scope.init = function(){
        $scope.holidays = [];
        if ($scope.refreshInProgress)
            return;
        $scope.refreshInProgress = true;
        loading(true);
        apiService.profile_get().then(function(profile) {
            if(profile && profile.data.plantholidays && profile.data.plantholidays.length>0){
                var holidays = profile.data.plantholidays;
                for (var i = 0; i < holidays.length; i++) {
                    $scope.holidays.push({
                        date : holidays[i].date,
                        name : holidays[i].name
                    });
                }
            }
            $scope.getMostRecentEventDate(function(date){
                $scope.insightInfo.fromDate = date.subtract(1, 'month').startOf("month");
                $timeout(function(){
                    $scope.fetchIssueSummary();
                    $scope.$apply();
                }, 100);
            });
        });
    }

    $scope.init();
}

smartsenseApp.factory('motorInsightsService', motorInsightsService);

motorInsightsService.$inject = ['$http', 'timeseriesService', 'SETTINGS', 'data'];

function motorInsightsService($http, timeseriesService, SETTINGS, data) {

    var filters = {
        category: [{
            label: 'All',
            value: ''
        }, {
            label: 'Health',
            value: 'health'
        }, {
            label: 'Energy',
            value: 'energy'
        }],
        type: [{
            label: 'All',
            value: ''
        }, {
            label: 'Asset',
            value: 'assets'
        }, {
            label: 'Tags',
            value: 'tags'
        }, {
            label: 'Plant',
            value: 'overall'
        }],
        status: [{
            label: 'All',
            value: 'all'
        }, {
            label: 'Open',
            value: 'open'
        }, {
            label: 'Ignored',
            value: 'ignored'
        }, {
            label: 'Resolved',
            value: 'resolved'
        }]
    };

    var service = {
        filters: filters,
        getActual: getActual,
        createFlags: createFlags,
        generatePieChartData: generatePieChartData,
        getTimeSeries : getTimeSeries
    };

    return service;

    //////////

    function getTimeSeries(data) {
        var grain = data.grain || {
            value: 15
        };
        var req = {
            fromdate: data.fromDate,
            todate: data.toDate,
            sensorid: data.sensorsIds,
            readingtypeid: data.readingTypeId,
            grain: data.grain
        };
        return timeseriesService.getSensorTimeseries(req);
    }

    function getActual(issue) {
        issue.SensorsIds = issue.SensorsIds ? issue.SensorsIds : issue.SensorIds;
        var req = {
            fromdate: issue.StartDate,
            todate: issue.EndDate,
            sensorid: issue.SensorsIds.join(),
            readingtypeid: issue.ReadingTypeId,
            grain: {
                value: 15
            }
        };
        return timeseriesService.getSensorTimeseries(req);
    }

    function createFlags(flags) {
        var chartFlagSeries = [];
        angular.forEach(flags, function(value, datetime) {
            chartFlagSeries.push({
                x: parseInt(datetime) * 1000,
                title: "!",
                text: value
            });
        });
        return chartFlagSeries;
    }

    function generatePieChartData(issues) {
        var issueMapping = {};
        if (issues && issues.length > 0) {
            for (var i = 0; i < issues.length; i++) {
                var curIssue = issues[i];
                issueMapping[curIssue.Category] = issueMapping[curIssue.Category] || [];
                issueMapping[curIssue.Category].push(curIssue);
            }
        }
        var pieChartData = [];
        for (var type in issueMapping) {
            pieChartData.push({
                name: type,
                unit: '',
                y: issueMapping[type].length,
                value: issueMapping[type].length,
                color: type == 'Energy' ? '#437EDE' : '#B8E986',
            });
        }
        var pieChartConfig = {
            tooltip: {
                pointFormatter: function() {
                    return '<b> Total : ' + this.value + '</b>';
                },
                shared: true
            },
            colorByPoint: true,
            data: pieChartData
        }
        return pieChartConfig;

    }

}

smartsenseApp.controller('TransformerInsightsController', TransformerInsightsController);

TransformerInsightsController.$inject = ['$scope', 'local', 'apiService', 'NgTableParams', 'transformerInsightsService', 'summary'];

function TransformerInsightsController($scope, local, apiService, NgTableParams, transformerInsightsService, summary) {

    $scope.localData = local.data;
    $scope.tx_events = []; 
    $scope.tx_event_categories = [];
    $scope.txs = [];
    $scope.tapmechanism_labels = { 'M': 'Manual', 'A': 'Automatic' };
    $scope.tableParams = {};
    $scope.eventGraphConfig = {};
    $scope.THRESHOLDS = transformerInsightsService.THRESHOLDS;

    $scope.backToTop = function() {
        utils.scrollTo(0);
    }

    $scope.selected = {
        event:{},
        tx:{}
    }
    $scope.selectedHealth = {};

    var default_view = {
        event: { open: true },
        health: { open: false },
        activitylog: { open: false },
        meta : {open:true},
        txlist: {open:true}
    };
    $scope.selectedView = angular.copy(default_view);

    var threshold_keys = transformerInsightsService.threshold_keys;

    $scope.stats = {
        txs:{
            total:0,
            unhealthy:0
        },
        events:{
            total:0,
            critical:0
        },
        potential_savings:{
            total:0
        }
    }

    $scope.prepareData = function() {

        $scope.tx_events = summary.data.events;
        $scope.tx_event_categories = summary.data.categories;
        $scope.txs = summary.data.txs;

        angular.forEach($scope.txs, function(tx, index) {
            $scope.txs[index].name = $scope.localData.sensors[tx.htsensorid].name;
        });

        angular.forEach($scope.tx_events, function(txevents, txid) {
            var potential_savings = 0;
            angular.forEach(txevents, function(events, eventid) {
                angular.forEach(events, function(event, key) {
                    $scope.tx_events[txid][eventid][key].eventdata = utils.strToJson($scope.tx_events[txid][eventid][key].eventdata);
                });
                $scope.stats.events.total += events.length; 
                if (events.length) {
                    var ps = $scope.tx_events[txid][eventid][0].eventdata.potential_savings;
                    if (ps>0) {
                        potential_savings = potential_savings + ps;
                    }
                }
            });
            $scope.txs[txid]['potential_savings'] = potential_savings;
            // Stats
            $scope.stats.potential_savings.total += potential_savings;
            $scope.stats.txs.unhealthy++;
            $scope.stats.events.critical += $scope.txs[txid].critical_event_count;
            
        });

        $scope.txs = Object.values($scope.txs);
        $scope.stats.txs.total = $scope.txs.length;

        angular.forEach($scope.tx_event_categories, function(eventCategory, eventid) {
            $scope.tx_event_categories[eventid].graphparameters = utils.strToJson($scope.tx_event_categories[eventid].graphparameters);
        });

        var initialParams = {
            count: 5, // initial page size,
            sorting: { potential_savings: "desc", critical_event_count:"desc"}
        };

        var initialSettings = {
            // page size buttons (right set of buttons in demo)
            counts: [],
            // determines the pager buttons (left set of buttons in demo)
            paginationMaxBlocks: 4,
            paginationMinBlocks: 2,
            dataset: $scope.txs
        };

        $scope.tableParams = new NgTableParams(initialParams, initialSettings);

    }


    var _timesereisEventGraph = function(event) {

        $scope.eventGraphConfig = transformerInsightsService.event_timeseriesGraphConfig();
        $scope.eventGraphConfig.options.chart.id = event.id;

        if (!event.eventdata['event_on']) {
            var event_defaults = event.eventCategory.graphparameters.defaults;
            if ((event_defaults || {}).event_on) {
                event.eventdata['event_on'] = event_defaults.event_on;
            } else {
                return;
            }
        };

        angular.forEach(event.eventdata, function(value, label) {
            if (threshold_keys.indexOf(label) > -1) {
                if ($scope.eventGraphConfig.options.yAxis.minRange < value) {
                    $scope.eventGraphConfig.options.yAxis.minRange = value;
                }
                $scope.eventGraphConfig.options.yAxis.plotLines.push(transformerInsightsService.getPlotLineTemplate(label, value));
            }
        });

        $scope.eventGraphConfig.options.xAxis.plotBands = [{
            color: '#fbfcc5',
            from: event.eventdate.startOf('day').valueOf(),
            to: event.eventdate.endOf('day').valueOf(),
            label: {
                text: 'Event on \n' + event.eventdate.format('MMM, DD'),
                y: -10,
                style: {
                    fontWeight: 'bold'
                }
            }
        }];

        var tx_mapping = { "ht": "htsensorid", "lt": "ltsensorid" };

        angular.forEach(tx_mapping, function(sensor_key, type) {
            if (event.eventdata['event_on'].toLowerCase().indexOf(type) > -1) {
                var params = {
                    sensorid: $scope.selected.tx[sensor_key],
                    readingtypeid: event.eventgraphparameterid,
                    grain: 15,
                    fromdate: event.eventgraphstartdate,
                    todate: event.eventgraphenddate
                }
                $scope.eventGraphConfig.loading = true;
                apiService.reading_series(params).then(function(response) {
                    var data = response.data[0];
                    $scope.eventGraphConfig.options.tooltip.valueSuffix = data.readingtype.unit;
                    $scope.eventGraphConfig.options.yAxis.title.text = data.readingtype.unit;
                    var series = {
                        name: type.toUpperCase() + ' - ' + data.readingtype.readingtypename,
                        data: data.timeseries || [],
                        id: event.id + '_' + params.sensorid + '_' + data.readingtype.readingtypeid
                    }
                    for (var i = 0; i < series.data.length; i++) {
                        series.data[i].x = series.data[i].timeStamp * 1000;
                        series.data[i].y = series.data[i].value;
                        delete series.data[i].timeStamp;
                        delete series.data[i].value;
                    }
                    $scope.eventGraphConfig.series.push(series);
                    $scope.eventGraphConfig.loading = false;
                }, function(error) {
                    $scope.eventGraphConfig.loading = false;
                });
            }
        });
    }


    var getTimeRangeData = function(start, end, step) {
        var epoch = {
            start: moment(start).valueOf() / 1000,
            end: moment(end).valueOf() / 1000,
        }
        var data = {};
        for (var i = epoch.start; i <= epoch.end; i = i + step) {
            data[i] = { x: null, y: null, timestamp: i };
        }
        return data;
    }

    var _oltcEventGraph = function(event) {

        $scope.eventGraphConfig = transformerInsightsService.event_oltcGraphConfig($scope.selected.tx);
        $scope.eventGraphConfig.options.chart.id = event.id;

        var params = {
            readingtypeid: event.eventCategory.graphparameters.parameters[0],
            grain: 15,
            fromdate: moment(event.eventgraphstartdate).startOf('day'),
            todate: moment(event.eventgraphenddate).endOf('day')
        }

        var data = getTimeRangeData(params.fromdate, params.todate, params.grain*60);

        $scope.eventGraphConfig.loading = true;
        var series_count = 0, point = {};
        var LT_Range = { min: $scope.selected.tx.lower_vlt, max: $scope.selected.tx.upper_vlt };
        var sensor_axis_mapping = {
            "x": event.eventCategory.graphparameters["x"],
            "y": event.eventCategory.graphparameters["y"]
        };
        angular.forEach(sensor_axis_mapping, function(sensorKey, axis) {
            params.sensorid = $scope.selected.tx[sensorKey];
            apiService.reading_series(params).then(function(response) {
                series_count++;
                var timeseries = response.data[0].timeseries || [];
                for (var i = 0; i < timeseries.length; i++) {
                    point = timeseries[i];
                    try {
                        data[point.timeStamp][axis] = point.value;
                    } catch (err) {
                        console.log(err)
                    };
                }
            }).catch(function(error) {
                console.error(error);
                series_count++;
            }).finally(function() {
                if (series_count == 2) {
                    $scope.eventGraphConfig.loading = false;
                    for (var epoch in data) {
                        if (data[epoch].x && data[epoch].y) {
                            if (data[epoch].y >= LT_Range.min && data[epoch].y <= LT_Range.max) {
                                $scope.eventGraphConfig.series[0].data.push(data[epoch]);
                            } else {
                                $scope.eventGraphConfig.series[1].data.push(data[epoch]);
                            }
                        }
                    }
                }
            });
        });
    };

    $scope.showEventGraph = function(event) {
        event.eventCategory = angular.copy($scope.tx_event_categories[event.eventid]);
        event.eventdate = moment(event.eventdate);
        var recommendation = event.eventCategory.recommendation;
        var re = /{([^}]+)}/g;
        var keys = recommendation.match(re);
        angular.forEach(keys,function(key){
            value_key = key.replace(/[{()}]/g, '');
            value = event.eventdata[value_key] || '-';
            var re = new RegExp(key, "g")
            recommendation = recommendation.replace(re, value);
        });
        $scope.selected.event.recommendation = recommendation;
        if (event.eventCategory.graphparameters.type == 'line') {
            _timesereisEventGraph(event);
        } else {
            var graphKey = event.eventCategory.graphparameters.key;
            if (graphKey == 'oltc') {
                _oltcEventGraph(event);
            }
        }
    }

    $scope.viewActivityLog = function() {
        var initialParams = {
            count: 5, // initial page size,
            sorting: { event_count: "desc" }
        };
        var initialSettings = {
            // page size buttons (right set of buttons in demo)
            counts: [],
            // determines the pager buttons (left set of buttons in demo)
            paginationMaxBlocks: 4,
            paginationMinBlocks: 2,
            dataset: []
        };
        apiService.tx_insights_activity_log($scope.selected.tx.id).then(function(response) {
            initialSettings.dataset = response.data.activity_log;
            $scope.activityLogTableParams = new NgTableParams(initialParams, initialSettings);
        });
    }

    $scope.onChangeEventDate = function($item, $model) {
        $scope.showEventGraph($item);
    }

    $scope.selectEventByCategory = function(events) {
        $scope.selectedEvents = events;
        $scope.selected.event = events[0];
        $scope.showEventGraph($scope.selected.event);
    }

    // Condition Monitoring

    $scope.health_graphConfigs = transformerInsightsService.ConditionMonitoringConfig;
    $scope.healthGraphs = [];

    var dateRange = {
        startDate: moment().subtract(30, 'days').startOf('day'),
        endDate: moment().subtract(1, 'days').endOf('day')
    }

    var dateRangeOpts = {
        locale: {
            fromLabel: "From",
            format: 'MMM D, YYYY',
            toLabel: "To",
            customRangeLabel: 'Custom Range'
        },
        opens: 'left',
        autoApply: true,
        maxDate: new Date(),
        eventHandlers: {
            'apply.daterangepicker': function(ev, picker) {
                $scope.showHealthGraph();
            }
        },
        ranges: {
            'Today': [moment().startOf('day'), moment()],
            'Last 7 Days': [moment().subtract(6, 'days'), moment()],
            'Last 30 Days': [moment().subtract(29, 'days'), moment()],
            'Last 3 months': [moment().subtract(2, 'months').startOf('month'), moment()],
            'Last 6 months': [moment().subtract(5, 'months').startOf('month'), moment()],
            'Last 12 Months': [moment().subtract(1, 'year').startOf('month'), moment()],
            'This Year': [moment([moment().year()]), moment()]
        }
    };

    $scope.date = {
        dateRange:dateRange,
        dateRangeOpts:dateRangeOpts
    }

    var _showTimeseriesHealthGraph = function(config, index) {

        var graphConfig = transformerInsightsService.health_timeseriesGraphConfig();
        graphConfig.options.chart.id = index;
        graphConfig.title.text = config.title;
        graphConfig.options = utils.MergeRecursive(graphConfig.options, config.options);
        graphConfig.cssClass = config.cssClass;
        graphConfig.options.xAxis.min = $scope.date.dateRange.startDate.valueOf();
        graphConfig.options.xAxis.max = $scope.date.dateRange.endDate.valueOf();

        var startEpoch = $scope.date.dateRange.startDate.valueOf();
        angular.forEach(config.plotLines, function(plotLine) {
            var value = $scope.THRESHOLDS[plotLine['key']];
            graphConfig.options.yAxis.plotLines.push(transformerInsightsService.getPlotLineTemplate(plotLine.label, value, plotLine.color));
            graphConfig.series.push(transformerInsightsService.getScatterPoint(startEpoch, value));
        });

        index = $scope.healthGraphs.push(graphConfig) - 1;
        $scope.healthGraphs[index].loading = true;

        var params = {
            grain: config.grain,
            fromdate: $scope.date.dateRange.startDate,
            todate: $scope.date.dateRange.endDate
        };

        angular.forEach(config.seriesParameter, function(item, key) {
            params.readingtypeid = item.readingtypeid;
            params.sensorid = $scope.selected.tx[item.sensorKey];
            apiService.reading_series(params).then(function(response) {
                var data = response.data[0];
                $scope.healthGraphs[index].options.yAxis.title.text = data.readingtype.unit;
                var series = {
                    name: item.sensorKey.substring(0, 2).toUpperCase() + ' - ' + data.readingtype.readingtypename,
                    data: data.timeseries || [],
                    id: key,
                    _colorIndex: key,
                    color: item.color || null,
                    tooltip:{
                        valueSuffix:data.readingtype.unit
                    }
                }
                for (var i = 0; i < series.data.length; i++) {
                    series.data[i].x = series.data[i].timeStamp * 1000;
                    series.data[i].y = series.data[i].value;
                    delete series.data[i].timeStamp;
                    delete series.data[i].value;
                }
                $scope.healthGraphs[index].series.push(series);
                $scope.healthGraphs[index].loading = false;
            }, function(error) {
                $scope.healthGraphs[index].loading = false;
            });
        });
    }

    var __showOLTCHealthGraph = function(config, index) {
        var graphConfig = transformerInsightsService.health_oltcGraphConfig($scope.selected.tx);
        graphConfig.options.chart.id = index;
        graphConfig.title.text = config.title;
        graphConfig.options = utils.MergeRecursive(graphConfig.options, config.options);
        graphConfig.cssClass = config.cssClass;
        var params = {
            readingtypeid: config.parameters[0],
            grain: config.grain,
            fromdate: moment($scope.date.dateRange.startDate).startOf('day'),
            todate: moment($scope.date.dateRange.endDate).endOf('day')
        }

        var data = getTimeRangeData(params.fromdate, params.todate, params.grain*60);

        index = $scope.healthGraphs.push(graphConfig) - 1;
        $scope.healthGraphs[index].loading = true;
        var series_count = 0;
        var LT_Range = { min: $scope.selected.tx.lower_vlt, max: $scope.selected.tx.upper_vlt };
        angular.forEach(config.sensorKeys, function(sensorKey, axis) {
            params.sensorid = $scope.selected.tx[sensorKey];
            apiService.reading_series(params).then(function(response) {
                series_count++;
                var timeseries = response.data[0].timeseries || [];
                for (var i = 0; i < timeseries.length; i++) {
                    data[timeseries[i].timeStamp][axis] = timeseries[i].value;
                }
            }).catch(function(error) {
                console.error(error);
                series_count++;
            }).finally(function() {
                if (series_count == 2) {
                    $scope.healthGraphs[index].loading = false;
                    for (var epoch in data) {
                        if (data[epoch].x && data[epoch].y) {
                            if (data[epoch].y >= LT_Range.min && data[epoch].y <= LT_Range.max) {
                                $scope.healthGraphs[index].series[0].data.push(data[epoch]);
                            } else {
                                $scope.healthGraphs[index].series[1].data.push(data[epoch]);
                            }
                        }
                    }
                }
            });
        });
    }

    var __showLossvsLoadingHealthGraph = function(config, index) {

        var graphConfig = transformerInsightsService.health_lossvsloadingGraphConfig();
        graphConfig.options.chart.id = index;
        graphConfig.title.text = config.title;
        graphConfig.options = utils.MergeRecursive(graphConfig.options, config.options);
        graphConfig.cssClass = config.cssClass;

        angular.forEach(graphConfig.options.yAxis.plotLines, function(plotLine) {
            graphConfig.series.push(getScatterPoint(epoch.start * 1000, plotLine.value));
        });

        var params = {
            sensorid: $scope.selected.tx[config.sensorKey],
            grain: config.grain,
            fromdate: moment().subtract(6, 'months').startOf('month'),
            todate: moment()
        }
        var epoch = {
            start: params.fromdate.valueOf() / 1000,
            end: params.todate.valueOf() / 1000
        }
        var dateRanges = [];
        // Form dataranges from daterange and group
        for (var d = params.fromdate.clone(); d < params.todate; d.add(1, 'months')) {
            dateRanges.push({
                start: d.clone().startOf('month').valueOf() / 1000,
                end: d.clone().endOf('month').valueOf() / 1000,
                label: d.clone().format('MMMM')
            });
        }
        var data = {};
        for (var i = epoch.start; i <= epoch.end; i = i + params.grain) {
            data[i] = { x: null, y: null, timestamp: i * 1000 };
        }
        graphConfig.loading = true;
        index = $scope.healthGraphs.push(graphConfig) - 1;
        var series_count = 0;
        angular.forEach(config.parameters, function(parameter, axis) {
            params.readingtypeid = parameter;
            apiService.reading_series(params).then(function(response) {
                series_count++;
                var timeseries = response.data[0].timeseries || [];
                for (var i = 0; i < timeseries.length; i++) {
                    try {
                        data[timeseries[i].timeStamp][axis] = timeseries[i].value;
                    } catch (error) {
                        console.error(timeseries[i].timeStamp, error);
                    }
                }
            }).catch(function(error) {
                console.error(error);
                series_count++;
            }).finally(function() {
                if (series_count == 2) {
                    $scope.healthGraphs[index].loading = false;
                    dateRanges.forEach(function(dateRange) {
                        var seriesData = [];
                        for (var i = dateRange.start; i < dateRange.end; i = i + params.grain) {
                            if (data[i].x && data[i].y) {
                                seriesData.push(data[i]);
                            }
                        }
                        $scope.healthGraphs[index].series.push({
                            name: dateRange.label,
                            data: seriesData
                        })
                    });
                }
            });
        });
    }

    $scope.showHealthGraph = function() {
        $scope.healthGraphs = [];
        angular.forEach($scope.selectedHealth.graphConfig, function(item, index) {
            if (item.type == 'timeseries') {
                _showTimeseriesHealthGraph(item, index);
            } else if (item.type == 'oltc') {
                __showOLTCHealthGraph(item, index);
            } else if (item.type == 'lossvsloading') {
                __showLossvsLoadingHealthGraph(item, index);
            }
        });
    }

    $scope.$watch('selectedView.health.open',function(newVal, oldVal){
        if(newVal && newVal!=oldVal && !$scope.selectedHealth.id) {
            $scope.selectHealth($scope.health_graphConfigs[0]);
        }
    });

    $scope.selectHealth = function(healthConfig) {
        if ($scope.selectedHealth.id == healthConfig.id) {
            return;
        }
        $scope.selectedHealth = angular.copy(healthConfig);
        $scope.showHealthGraph();
    }

    $scope.selectTx = function(tx) {
        $scope.selectedView = angular.copy(default_view);
        $scope.activityLogTableParams = null;
        if ($scope.selected.tx.htsensorid == tx.htsensorid) {
            $scope.selected.tx = {};
            return;
        }
        $scope.selected.event = {};
        $scope.selectedHealth = {};
        $scope.healthGraphs = [];
        $scope.selected.tx = tx;
        $scope.THRESHOLDS = angular.merge({}, transformerInsightsService.THRESHOLDS, $scope.selected.tx);
        var keys = Object.keys($scope.tx_events[tx.id]);
        $scope.selectEventByCategory($scope.tx_events[tx.id][keys[0]]);
        var scrollHeight = $("#selectedTx").offset().top - 75;
        utils.scrollTo(scrollHeight);
    }

    $scope.prepareData();

}
smartsenseApp.factory('transformerInsightsService', transformerInsightsService);

transformerInsightsService.$inject = ['$http', 'timeseriesService', 'SETTINGS', 'data'];

function transformerInsightsService($http, timeseriesService, SETTINGS, data) {

    var threshold_keys = ['threshold', 'minhtvoltage', 'maxhtvoltage', 'minltvoltage', 'maxltvoltage']

    var STANDARD_THRESHOLDS = {
        'VOLTAGE_IMB':2,
        'CURRENT_IMB':10,
        'VOLTAGE_THD':2,
        'CURRENT_THD':10,
        'UPPERLOAD_LIMIT':30,
        'OVERLOAD_LIMIT':120,
    }

    var THRESHOLDS = angular.copy(STANDARD_THRESHOLDS);

    var tx_readingtypes = {
        'VOLTAGE_IMB': 5039,
        'CURRENT_IMB': 5040,
        'LOADING_': 5053,
        'VLL_RY': 2013,
        'VLL_YB': 2014,
        'VLL_BR': 2015,
        'I_RY': 2019,
        'I_YB': 2020,
        'I_BR': 2021,
        'VOLTAGE_THD': 2046,
        'CURRENT_THD': 2047,
        'VOLTAGE': 2012,
        'OLTC': 5047,
        'LOSS': 5049,
        'OFF_TIME': 5031,
        'OVERLOADED_TIME': 5032,
        'UNDERLOADED_TIME': 5033,
        'NORMALLOADED_TIME': 5034
    }


    var ConditionMonitoringConfig = [{
        id: 1,
        label: 'Imbalance Analysis',
        graphConfig: [{
            seriesParameter: [{
                readingtypeid: 5039,
                sensorKey: 'htsensorid',
            }, {
                readingtypeid: 5039,
                sensorKey: 'ltsensorid',
            }],
            type: 'timeseries',
            title: 'Voltage Imb',
            grain: 1440,
            plotLines:[{
                key:'VOLTAGE_IMB',
                label:'Standard Voltage Imb'
            }],
            cssClass: 'col-md-6'
        }, {
            seriesParameter: [{
                readingtypeid: 2001,
                sensorid: 1176,
            }, {
                readingtypeid: 2001,
                sensorid: 1177,
            }, {
                readingtypeid: 2003,
                sensorid: 1176,
            }],
            seriesParameter: [{
                readingtypeid: 5040,
                sensorKey: 'htsensorid',
            }, {
                readingtypeid: 5040,
                sensorKey: 'ltsensorid'
            }],
            type: 'timeseries',
            title: 'Current Imb',
            plotLines:[{
                key:'CURRENT_IMB',
                label:'Standard Current Imb'
            }],
            grain: 1440,
            cssClass: 'col-md-6'
        }]
    }, {
        id: 3,
        label: 'Voltage Analysis',
        graphConfig: [{
            seriesParameter: [{
                readingtypeid: 2013,
                sensorKey: 'htsensorid'
            }, {
                readingtypeid: 2014,
                sensorKey: 'htsensorid'
            }, {
                readingtypeid: 2015,
                sensorKey: 'htsensorid'
            }],
            type: 'timeseries',
            plotLines: [{
                    key:'MaxHTVoltage',
                    label:'Max HT Voltage',
                }
            ],
            title: 'HT',
            grain: 1440,
            cssClass: 'col-md-6'
        }, {
            seriesParameter: [{
                readingtypeid: 2013,
                sensorKey: 'ltsensorid'
            }, {
                readingtypeid: 2014,
                sensorKey: 'ltsensorid'
            }, {
                readingtypeid: 2015,
                sensorKey: 'ltsensorid'
            }],
            type: 'timeseries',
            plotLines: [{
                    key:'upper_vlt',
                    label:'Upper LT Voltage',
                }
            ],
            title: 'LT',
            grain: 1440,
            cssClass: 'col-md-6'
        }]
    }, {
        id: 4,
        label: 'Current Analysis',
        graphConfig: [{
            seriesParameter: [{
                readingtypeid: 2019,
                sensorKey: 'htsensorid'
            }, {
                readingtypeid: 2020,
                sensorKey: 'htsensorid'
            }, {
                readingtypeid: 2021,
                sensorKey: 'htsensorid'
            }],
            type: 'timeseries',
            plotLines: [],
            title: 'HT',
            grain: 1440,
            cssClass: 'col-md-6'
        }, {
            seriesParameter: [{
                readingtypeid: 2019,
                sensorKey: 'ltsensorid'
            }, {
                readingtypeid: 2020,
                sensorKey: 'ltsensorid'
            }, {
                readingtypeid: 2021,
                sensorKey: 'ltsensorid'
            }],
            type: 'timeseries',
            plotLines: [],
            title: 'LT',
            grain: 1440,
            cssClass: 'col-md-6'
        }]
    }, {
        id: 5,
        label: 'THD Analysis',
        graphConfig: [{
            seriesParameter: [{
                readingtypeid: 2046,
                sensorKey: 'htsensorid'
            }, {
                readingtypeid: 2046,
                sensorKey: 'ltsensorid'
            }],
            type: 'timeseries',
            title: 'Voltage THD',
            grain: 1440,
            plotLines: [{
                key:'VOLTAGE_THD',
                label:'Voltag Current THD'
            }],
            cssClass: 'col-md-6'
        }, {
            seriesParameter: [{
                readingtypeid: 2047,
                sensorKey: 'htsensorid'
            }, {
                readingtypeid: 2047,
                sensorKey: 'ltsensorid'
            }],
            type: 'timeseries',
            title: 'Current THD',
            grain: 1440,
            plotLines: [{
                key:'CURRENT_THD',
                label:'Standard Current THD'
            }],
            cssClass: 'col-md-6'
        }]
    }, {
        id: 6,
        label: 'OLTC Operation',
        graphConfig: [{
            parameters: [2012],
            sensorKeys: { x: 'htsensorid', y: 'ltsensorid' },
            type: 'oltc',
            title: '',
            grain: 15,
            plotLines: [],
            cssClass: 'col-md-12'
        }]
    }, {
        id: 7,
        label: 'Loss vs Loading',
        hideCalendar: true,
        graphConfig: [{
            parameters: { x: 5053, y: 5049 },
            sensorKey: 'htsensorid',
            type: 'lossvsloading',
            title: '',
            grain: 360,
            cssClass: 'col-md-12',
            group: {
                unit: 'months',
                startOf: 'month',
                value: 1
            }
        }]
    }, {
        id: 8,
        label: 'Loading Analysis',
        graphConfig: [{
            seriesParameter: [{
                readingtypeid: 5053,
                sensorKey: 'htsensorid'
            }],
            type: 'timeseries',
            title: '',
            grain: 15,
            plotLines: [{
                    key:'UPPERLOAD_LIMIT',
                    label:'Upperload Limit',
                    color:'blue'
                },{
                    key:'OVERLOAD_LIMIT',
                    label:'Overload Limit',
                    color:'red'
                }
            ],
            cssClass: 'col-md-6'
        }, {
            seriesParameter: [{
                readingtypeid: tx_readingtypes['OFF_TIME'],
                sensorKey: 'htsensorid',
                color: '#b1e67b'
            }, {
                readingtypeid: tx_readingtypes['OVERLOADED_TIME'],
                sensorKey: 'htsensorid',
                color: '#fe9985'
            }, {
                readingtypeid: tx_readingtypes['UNDERLOADED_TIME'],
                sensorKey: 'htsensorid',
                color: '#b9e2f7'
            }, {
                readingtypeid: tx_readingtypes['NORMALLOADED_TIME'],
                sensorKey: 'htsensorid',
                color: '#feda56'
            }],
            type: 'timeseries',
            title: '',
            grain: 1440 * 7,
            cssClass: 'col-md-6',
            options: {
                chart: {
                    type: 'column'
                },
                xAxis: {
                    type: 'datetime',
                    dateTimeLabelFormats: {
                        day: '%e of %b'
                    }
                },
                plotOptions: {
                    column: {
                        stacking: 'normal'
                    },
                }
            }
        }]
    }];

    function getPlotLineTemplate(label, value, color = 'red') {
        return {
            color: color,
            dashStyle: 'longdashdot',
            value: value,
            label: {
                text: '<p style="background-color:rgba(255,255,255,0.9);padding:0 3px">' + label + ' - ' + value + '</p>',
                useHTML: true
            },
            width: 2,
            zIndex: 5
        }
    }

    function getScatterPoint(x, y) {
        return {
            name: '',
            type: 'scatter',
            marker: {
                enabled: false
            },
            showInLegend: false,
            data: [{ y: y, x: x }]
        }
    }


    function event_timeseriesGraphConfig() {
        var chartConfig = {
            options: {
                chart: {
                    zoomType: 'x',
                    type: 'line',
                    spacingTop: 20
                },
                xAxis: {
                    type: 'datetime',
                    plotBands: []
                },
                yAxis: {
                    plotLines: [],
                    minRange: 0,
                    title: {
                        text: ''
                    }
                },
                tooltip: {
                    valueSuffix: ''
                }
            },
            series: [],
            title: {
                text: ''
            },
            loading: false,
        };
        return chartConfig;
    }

    function event_oltcGraphConfig(thresholds) {
        var graphConfig = {
            options: {
                chart: {
                    zoomType: 'xy',
                    type: 'scatter'
                },
                xAxis: {
                    title: {
                        text: 'HT'
                    }
                },
                yAxis: {
                    title: {
                        text: 'LT'
                    }
                },
                boost: {
                    useGPUTranslations: true,
                    usePreAllocated: true
                },
                plotOptions: {
                    scatter: {
                        tooltip: {
                            headerFormat: '<b>{series.name}</b><br>',
                            pointFormat: '{point.timestamp:%e. %b, %H:%M}<br>HT - <b>{point.x:,.0f} V</b><br> LT - <b>{point.y:,.0f} V</b>'
                        }
                    }
                }
            },
            series: [{
                name: 'Healthy',
                data: [],
                color: '#437ede',
                marker: {
                    symbol: 'circle'
                },
                id:1
            }, {
                name: 'Non-Healthy',
                data: [],
                color: '#f94b4b',
                marker: {
                    symbol: 'triangle'
                },
                id:2
            }],
            title: {
                text: ''
            },
            loading: false
        };
        var plotLines = {
            xAxis: [{
                label: 'HT - Max Voltage',
                value: thresholds['MaxHTVoltage']
            }, {
                label: 'HT - Min Voltage',
                value: thresholds['MinHTVoltage']
            }],
            yAxis: [{
                label: 'LT - Upper Voltage',
                value: thresholds['upper_vlt']
            }, {
                label: 'LT - Lower Voltage',
                value: thresholds['lower_vlt']
            }]
        };
        angular.forEach(plotLines, function(lines, axis) {
            graphConfig.options[axis].plotLines = [];
            angular.forEach(lines, function(item) {
                graphConfig.options[axis].plotLines.push(getPlotLineTemplate(item.label, item.value));
            });
        });
        angular.forEach(plotLines.xAxis, function(xitem) {
            var x = xitem.value
            angular.forEach(plotLines.yAxis, function(yitem) {
                var y = yitem.value;
                graphConfig.series.push(getScatterPoint(x, y));
            });
        });
        return graphConfig;
    }

    function event_lossvsloadingGraphConfig() {
        var graphConfig = {
            options: {
                chart: {
                    zoomType: 'xy',
                    type: 'scatter'
                },
                xAxis: {
                    title: {
                        text: '% Loading'
                    }
                },
                yAxis: {
                    title: {
                        text: '% Loss'
                    },
                    plotLines: []
                },
                boost: {
                    useGPUTranslations: true,
                    usePreAllocated: true
                },
                plotOptions: {
                    scatter: {
                        tooltip: {
                            headerFormat: '<b>{series.name}</b><br>',
                            pointFormat: '{point.timestamp:%e %b, %H:%M}<br>Loading - <b>{point.x:.2f} %</b><br>Loss - <b>{point.y:.2f}%</b>'
                        },
                        marker: {
                            symbol: 'circle',
                            radius: 5
                        }
                    }
                },
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        };
        return graphConfig;
    }

    function health_timeseriesGraphConfig() {
        var chartConfig = {
            options: {
                chart: {
                    zoomType: 'x',
                    type: 'line'
                },
                xAxis: {
                    type: 'datetime'
                },
                yAxis: {
                    plotLines: [],
                    title: {
                        text: ''
                    }
                },
                tooltip: {
                    valueSuffix: ''
                }
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        };
        return chartConfig;
    }

    function health_lossvsloadingGraphConfig() {
        var graphConfig = {
            options: {
                chart: {
                    zoomType: 'xy',
                    type: 'scatter'
                },
                xAxis: {
                    title: {
                        text: '% Loading'
                    }
                },
                yAxis: {
                    title: {
                        text: '% Loss'
                    },
                    plotLines: []
                },
                boost: {
                    useGPUTranslations: true,
                    usePreAllocated: true
                },
                plotOptions: {
                    scatter: {
                        tooltip: {
                            headerFormat: '<b>{series.name}</b><br>',
                            pointFormat: '{point.timestamp:%e %b, %H:%M}<br>Loading - <b>{point.x:.2f} %</b><br>Loss - <b>{point.y:.2f}%</b>'
                        },
                        marker: {
                            symbol: 'circle',
                            radius: 5
                        }
                    }
                }
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        };
        return graphConfig;
    }

    function health_oltcGraphConfig(tx) {
        var graphConfig = {
            options: {
                chart: {
                    zoomType: 'xy',
                    type: 'scatter'
                },
                xAxis: {
                    title: {
                        text: 'HT'
                    }
                },
                yAxis: {
                    title: {
                        text: 'LT'
                    }
                },
                boost: {
                    useGPUTranslations: true,
                    usePreAllocated: true
                },
                plotOptions: {
                    scatter: {
                        tooltip: {
                            headerFormat: '<b>{series.name}</b><br>',
                            pointFormat: '{point.timestamp:%e. %b, %H:%M}<br>HT - <b>{point.x:,.0f} V</b><br> LT - <b>{point.y:,.0f} V</b>'
                        }
                    }
                }
            },
            series: [{
                name: 'Healthy',
                data: [],
                color: '#437ede'
            }, {
                name: 'Non-Healthy',
                data: [],
                color: '#f94b4b'
            }],
            title: {
                text: ''
            },
            loading: false
        };
        var plotLines = {
            xAxis: [{
                label: 'HT - Max Voltage',
                value: tx['MaxHTVoltage']
            }, {
                label: 'HT - Min Voltage',
                value: tx['MinHTVoltage']
            }],
            yAxis: [{
                label: 'LT - Upper Voltage',
                value: tx['upper_vlt']
            }, {
                label: 'LT - Lower Voltage',
                value: tx['lower_vlt']
            }]
        };
        angular.forEach(plotLines, function(lines, axis) {
            graphConfig.options[axis].plotLines = [];
            angular.forEach(lines, function(item) {
                graphConfig.options[axis].plotLines.push(getPlotLineTemplate(item.label, item.value));
            });
        });
        angular.forEach(plotLines.xAxis, function(xitem) {
            var x = xitem.value
            angular.forEach(plotLines.yAxis, function(yitem) {
                var y = yitem.value;
                graphConfig.series.push(getScatterPoint(x, y));
            });
        });
        return graphConfig;
    }

    var service = {
        THRESHOLDS:THRESHOLDS,
        threshold_keys:threshold_keys,
        ConditionMonitoringConfig: ConditionMonitoringConfig,
        getPlotLineTemplate: getPlotLineTemplate,
        getScatterPoint: getScatterPoint,
        // Graph Configs
        event_timeseriesGraphConfig: event_timeseriesGraphConfig,
        event_oltcGraphConfig:event_oltcGraphConfig,
        event_lossvsloadingGraphConfig:event_lossvsloadingGraphConfig,
        health_timeseriesGraphConfig: health_timeseriesGraphConfig,
        health_lossvsloadingGraphConfig: health_lossvsloadingGraphConfig,
        health_oltcGraphConfig: health_oltcGraphConfig,
    };

    return service;

    //////////


}
smartsenseApp.controller("BillingInsightsController", ['$scope', '$stateParams', '$timeout', 'data', 'local', '$http', '$rootScope', 'loading', 'timeseriesService', '$location', '$state', '$document', 'locations', 'SETTINGS', 'billingLocations', 'Analytics', 'apiService', function($scope, $stateParams, $timeout, data, local, $http, $rootScope, loading, timeseriesService, $location, $state, $document, locations, SETTINGS, billingLocations, Analytics, apiService) {

    /* Set local data to use in other components */
    $scope.localData = local.data;
    $scope.localData.billingData = undefined;
    $scope.billingLocations = billingLocations.data;

    $scope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {
        if (toState.name == 'page.login' && $scope.isBackspace) {
            var r = confirm("Leaving this page will logout!");
            if (r == true) {
                $scope.isBackspace = false;
                $location.path('/login');
            } else {
                event.preventDefault();
                $scope.isBackspace = false;
                $state.go(fromState.name, {}, {
                    reload: false
                });
            }
        }
    });

    $scope.widgets = {
        bill : [{
            type : "bill",
            title : "bill",
            tooltip : "bill",
            controller : "BillingWidgetBillController"
        }],
        energyConsumption : [{
            type : "energyConsumption",
            title : "energyConsumption",
            tooltip : "energyConsumption",
            controller : "BillingWidgetEnergyConsumptionController"
        }],
        demand : [{
            type : "demand",
            title : "demand",
            tooltip : "demand",
            controller : "BillingWidgetDemandController"
        }],
        pf : [{
            type : "pf",
            title : "pf",
            tooltip : "pf",
            controller : "BillingWidgetPFController"
        }],
        consumption : [{
            type : "consumptionTrend",
            title : "consumptionTrend",
            tooltip : "consumptionTrend",
            controller : "BillingWidgetConsumptionController"
        }],
        billSimulator : [{
            type : "billSimulator",
            title : "billSimulator",
            tooltip : "billSimulator",
            controller : "BillingWidgetBillSimulatorController"
        }],
        solarPV : [{
            type : "solarPV",
            title : "solarPV",
            tooltip : "solarPV",
            controller : "BillingWidgetSolarPVController"
        }]
    };

    $scope.billData = {
        provisional : undefined,
        projected : undefined,
        previous : undefined
    };

    $scope.getBillDetails = function() {
        var locationID = $scope.selectedBillingLocation;
        $scope.localData.billingDataLoading = true;
        loading(true);
        apiService.billing_get_widgets(locationID).then(function(data) {
            $scope.localData.provisional_bill_details = undefined;
            $scope.localData.billingDataLoading = false;
            if(data && data.data){
                var billDetails = data.data.BILLING;
                if(billDetails.PREVIOUS_BILL && utils.isNumeric(billDetails.PREVIOUS_BILL)){
                    $scope.billData.previous = Math.round(parseFloat(billDetails.PREVIOUS_BILL));
                }
                if(billDetails.PROJECTED_BILL && utils.isNumeric(billDetails.PROJECTED_BILL)){
                    $scope.billData.projected = Math.round(parseFloat(billDetails.PROJECTED_BILL));
                }
                if(billDetails.PROVISIONAL_BILL && utils.isNumeric(billDetails.PROVISIONAL_BILL)){
                    $scope.billData.provisional = Math.round(parseFloat(billDetails.PROVISIONAL_BILL));
                }
                if(billDetails.PREVIOUS_TO_PREVIOUS_BILL && utils.isNumeric(billDetails.PREVIOUS_TO_PREVIOUS_BILL)){
                    $scope.billData.previousToPrevious = Math.round(parseFloat(billDetails.SECOND_PREVIOUS_BILL));
                }
                $scope.billData.rebatePenalty = {
                    PF_PENALTY : billDetails.PF_PENALTY ? Math.round(billDetails.PF_PENALTY) : billDetails.PF_PENALTY,
                    PF_REBATE : billDetails.PF_REBATE ? Math.round(billDetails.PF_REBATE) : billDetails.PF_REBATE
                }
                var demandData = {};
                demandData.actualMaxDemand = billDetails.RECORDED_DEMAND ? parseFloat(parseFloat(billDetails.RECORDED_DEMAND).toFixed(2)) : billDetails.RECORDED_DEMAND;
                demandData.currentBillingDemand = billDetails.BILLING_DEMAND ? parseFloat(parseFloat(billDetails.BILLING_DEMAND).toFixed(2)) : billDetails.BILLING_DEMAND;
                demandData.currentDemandCharges = Math.round(billDetails.TOTAL_DEMAND_CHARGES);
                demandData.previousMaxDemand = billDetails.PREVIOUS_RECORDED_DEMAND ? parseFloat(parseFloat(billDetails.PREVIOUS_RECORDED_DEMAND).toFixed(2)) : billDetails.PREVIOUS_RECORDED_DEMAND;
                demandData.previousBillingDemand = billDetails.PREVIOUS_BILLING_DEMAND ? parseFloat(parseFloat(billDetails.PREVIOUS_BILLING_DEMAND).toFixed(2)) : billDetails.PREVIOUS_BILLING_DEMAND;
                demandData.previousDemandCharges = Math.round(billDetails.PREVIOUS_TOTAL_DEMAND_CHARGES);
                demandData.previousToPreviousMaxDemand = billDetails.SECOND_PREVIOUS_RECORDED_DEMAND ? parseFloat(parseFloat(billDetails.SECOND_PREVIOUS_RECORDED_DEMAND).toFixed(2)) : billDetails.SECOND_PREVIOUS_RECORDED_DEMAND;
                demandData.previousToPreviousBillingDemand = billDetails.SECOND_PREVIOUS_BILLING_DEMAND ? parseFloat(parseFloat(billDetails.SECOND_PREVIOUS_BILLING_DEMAND).toFixed(2)) : billDetails.SECOND_PREVIOUS_BILLING_DEMAND;
                demandData.previousToPreviousDemandCharges = Math.round(billDetails.SECOND_PREVIOUS_TOTAL_DEMAND_CHARGES);

                $scope.billData.billDetails = billDetails;
                $scope.billData.demandData = demandData;
                $scope.localData.billingData = $scope.billData;
            }
            $scope.calculatePercentages();
            $scope.localData.selectedBillingLocation = locationID;
            loading(false);
        }, function(error) {
            loading(false);
            $scope.localData.selectedBillingLocation = undefined;
            $scope.localData.billingData = undefined;
            $scope.localData.billingDataLoading = false;
            $scope.serverNotRecheable = true;
        });
    }

    $scope.calculatePercentages = function(){
        function getPerc(val1, val2){
            val1 = parseFloat(val1);
            val2 = parseFloat(val2);
            if(val1>0){
                var diff = val1 - val2;
                return Math.abs((100 * diff)/val1).toFixed(2);
            }
            else
                return "";
        }
        if($scope.billData.previous){
            if($scope.billData.projected){
                $scope.billData.projectedUp = parseFloat($scope.billData.projected) > parseFloat($scope.billData.previous);
                $scope.billData.projectedPerc = getPerc($scope.billData.previous, $scope.billData.projected);
            }
            if($scope.billData.provisional){
                $scope.billData.provisionalUp = parseFloat($scope.billData.provisional) > parseFloat($scope.billData.previous);
                $scope.billData.provisionalPerc = getPerc($scope.billData.previous, $scope.billData.provisional);
            }
            if($scope.billData.previousToPrevious){
                $scope.billData.previousUp = parseFloat($scope.billData.previous) > parseFloat($scope.billData.previousToPrevious);
                $scope.billData.previousPerc = getPerc($scope.billData.previous, $scope.billData.previousToPrevious);
            }
        }
        if($scope.billData.demandData){
            var demandData = $scope.billData.demandData;
            if(demandData.actualMaxDemand && demandData.previousMaxDemand){
                demandData.actualMaxDemandUp = parseFloat(demandData.actualMaxDemand.original_value) > parseFloat(demandData.previousMaxDemand.original_value);
                demandData.actualMaxDemandPerc = getPerc(demandData.previousMaxDemand.original_value, demandData.actualMaxDemand.original_value);
            }
            if(demandData.currentBillingDemand && demandData.previousBillingDemand){
                demandData.currentBillingDemandUp = parseFloat(demandData.currentBillingDemand.original_value) > parseFloat(demandData.previousBillingDemand.original_value);
                demandData.currentBillingDemandPerc = getPerc(demandData.previousBillingDemand.original_value, demandData.currentBillingDemand.original_value);
            }
            if(demandData.currentDemandCharges && demandData.previousDemandCharges){
                demandData.currentDemandChargesUp = parseFloat(demandData.currentDemandCharges) > parseFloat(demandData.previousDemandCharges);
                demandData.currentDemandChargesPerc = getPerc(demandData.previousDemandCharges, demandData.currentDemandCharges);
            }

            if(demandData.previousMaxDemand && demandData.previousToPreviousMaxDemand){
                demandData.previousMaxDemandUp = parseFloat(demandData.previousMaxDemand.original_value) > parseFloat(demandData.previousToPreviousMaxDemand.original_value);
                demandData.previousMaxDemandPerc = getPerc(demandData.previousToPreviousMaxDemand.original_value, demandData.previousMaxDemand.original_value);
            }
            if(demandData.previousBillingDemand && demandData.previousToPreviousBillingDemand){
                demandData.previousBillingDemandUp = parseFloat(demandData.previousBillingDemand.original_value) > parseFloat(demandData.previousToPreviousBillingDemand.original_value);
                demandData.previousBillingDemandPerc = getPerc(demandData.previousToPreviousBillingDemand.original_value, demandData.previousBillingDemand.original_value);
            }
            if(demandData.previousDemandCharges && demandData.previousToPreviousDemandCharges){
                demandData.previousDemandChargesUp = parseFloat(demandData.previousDemandCharges) > parseFloat(demandData.previousToPreviousDemandCharges);
                demandData.previousDemandChargesPerc = getPerc(demandData.previousToPreviousDemandCharges, demandData.previousDemandCharges);
            }
            $scope.billData.demandData = demandData;
        }
    }

    $scope.refresh = function() {
        $scope.getBillDetails();
        return;
    };

    $scope.selectedBillingLocation = $scope.billingLocations[0].LocationId;
    $scope.refresh();

}]);

smartsenseApp.factory('billingInsightsService', billingInsightsService);

billingInsightsService.$inject = ['$http', 'data'];

function billingInsightsService($http, data) {

    var areaUnits = [{
        name : "Sq. Ft",
        value : "ft"
    },{
        name : "Sq. Metee",
        value : "mt"
    },{
        name : "Sq. Yard",
        value : "yd"
    }];

    var powerUnits = [{
        name : "KWh",
        value : "kwh"
    },{
        name : "KVah",
        value : "kvah"
    }];

    var service = {
        areaUnits: areaUnits,
        powerUnits: powerUnits
    };
    return service;
}
smartsenseApp.controller('ConfigurationController', ConfigurationController);

ConfigurationController.$inject = ['$rootScope', 'Session', 'NgTableParams', 'FileUploader', 'SETTINGS', '$scope', '$state', '$filter', 'growl', 'data', 'loading', '$timeout', '$compile', 'apiService','$q'];

function ConfigurationController($rootScope, Session, NgTableParams, FileUploader, SETTINGS, $scope, $state, $filter, growl, data, loading, $timeout, $compile, apiService, $q) {
    $scope.selected_sensor = {}
    var setSensorsTable = function() {
        var initialParams = {
                count: 10, // initial page size,
                sorting: { name: "asc" },
                filter: $scope.search
            };
            var data = $scope.sensors;
            var initialSettings = {
                // page size buttons (right set of buttons in demo)
                counts: [],
                // determines the pager buttons (left set of buttons in demo)
                paginationMaxBlocks: 10,
                paginationMinBlocks: 2,
                dataset: data,
                };
        
        $scope.tableParams = new NgTableParams(initialParams, initialSettings);

    }
    $scope.applyGlobalSearch = applyGlobalSearch;
    
    function applyGlobalSearch(){
      var term = $scope.globalSearchTerm;
      $scope.tableParams.filter({ $: term });
    }


    $scope.init = function(){
        apiService.get_sensor_list().then(function(response) {
            $scope.sensors = response.data;
            setSensorsTable();
        });

        apiService.get_appliance_type().then(function(response) {
            $scope.appliances = response.data;
        });

        apiService.get_meter_list().then(function(response) {
            $scope.meters = response.data;
        });       
        $scope.MotorArray = [5];
        $scope.TxArray = [13];
        $scope.tx_sensor = {};
        $scope.motor_sensor = {};
        $scope.MOTORDUTY_CHOICES = [ 
            ['S1','S1 - Continuous duty'],['S2','S2 - Short Time duty'],['S3','S3 - Intermittent periodic duty'],
            ['S4','S4 - Intermittent periodic duty with starting'], ['S5', 'S5 - Intermittent periodic duty with electric braking'],
            ['S6','S6 - Continuous operation with intermittent load'], ['S7','S7 - Continuous operation with electric braking'], 
            ['S8','S8 - Continuous operation with periodic changes in load and speed'] 
        ];
        $scope.motorMetaDetails = {};

        $scope.TAP_CHOICES = [['A','Automatic'],['M','Manual']];
        $scope.STATUS_CHOICES = [['active','active'],['inactive','inactive']];
        $scope.search = { term: ''};

    }

    var authToken = Session.get('authToken');
    var uploader = $scope.uploader = new FileUploader({
    	
    	queueLimit: 1,
        url: SETTINGS.BASE_URL + '/upload_bulk_sensor/',
    });
    uploader.onWhenAddingFileFailed  = function(item, filter, options) {
        if(filter.name == "queueLimit") {
            uploader.clearQueue();
            uploader.addToQueue(item);
        }
    };
    uploader.headers["Authorization"] = 'token:' + authToken;
    uploader.onSuccessItem = function(fileItem, response, status, headers) {
        var message = '';
        if(response.hasOwnProperty('message')){
            message += response.message;
        }
        $scope.sensors = angular.extend({}, $scope.sensors, response.sensors);
        angular.element('input[type=file]').val(null);
        uploader.clearQueue();
        angular.element('#bulkUpload').modal('hide');
        growl.success("Sensors Created." + message, {
            ttl: 5000
        });
        console.info('onSuccessItem', fileItem, response, status, headers);
        apiService.get_sensor_list().then(function(response) {
            $scope.sensors = response.data;
            setSensorsTable();
        });
        
    };
    uploader.onErrorItem = function(fileItem, response, status, headers) {
        var message = '';
        if(response.hasOwnProperty('message')){
            message += response.message;
        }
        angular.element('input[type=file]').val(null);
        uploader.clearQueue()
        angular.element('#bulkUpload').modal('hide');
        growl.error("Failed to Upload file. <br/>" + message, {
            ttl: 10000
        });
        console.info('onErrorItem', fileItem, response, status, headers);
        
    };

    $scope.reset_form = function(){
        $scope.selected_sensor = {};
    }

    $scope.show_popup = function(){
        $scope.selected_sensor = {};
        $("h3").text("Add Sensor Details");
        angular.element('#myModal').modal('show');
    }

    $scope.show_upload = function(){
        angular.element('#bulkUpload').modal('show');
    }

    $scope.download_template = function(){
        apiService.download_template().then(function(response) {
            /*filename = response.headers('content-disposition').split('filename=')[1];*/
            var exts = ".xlsx";
            var blob = new Blob([response.data], {
                type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            });
            var objectUrl = URL.createObjectURL(blob);
            var anchor = angular.element('<a/>');
            angular.element(document.body).append(anchor);
            anchor.attr({
                href: objectUrl,
                target: '_blank',
                download: 'SensorConfiguration'+ exts
            })[0].click();
            /*$timeout(function() {
                bootbox.alert("Thank you for using Smartsense configuration. Your template has been downloaded.");
            }, 2000);*/
        }, function() {
            loading(false);
            });
    }

       /* $scope.generateSheet = function(generate, generateObj){
        if (generate.$valid){
            apiService.generate_excel_for_manual_sensor(generateObj).then(function(response) {
                if(response.status == 200){
                    filename = response.headers('content-disposition').split('filename=')[1];
                    var blob = new Blob([response.data], {
                        type: "application/vnd.ms-excel"
                    });
                    var objectUrl = URL.createObjectURL(blob);
                    var anchor = angular.element('<a/>');
                    angular.element(document.body).append(anchor);
                    anchor.attr({
                        href: objectUrl,
                        target: '_blank',
                        download: filename
                    })[0].click();

                    growl.success("Downloading started.", {
                        ttl: 5000
                    });
                    
                }else{
                    message = '';
                    if(response.data.hasOwnProperty('message')){
                        message = response.data.message;
                    }
                    growl.error("Failed to generate files. <br/>" + message, {
                        ttl: 5000
                    });
                }

            }).catch(function(response) {
                message = '';
                if(response.data.hasOwnProperty('message')){
                    message = response.data.message;
                }
                growl.error("Failed to generate files. <br/>" + message, {
                    ttl: 5000
                });
            });
        }

    }*/

    $scope.update_record = function(sensorid){

        angular.element('#myModal').modal('hide');
        angular.forEach($scope.sensors, function(value, key){
            if(sensorid == value.sensorid){
                $scope.selected_sensor = angular.copy($scope.sensors[key]);
            }
        });
        $("h3").text("Edit Sensor Details");
        angular.element('#myModal').modal('show');
    }

    $scope.selected_sensor_for_motor = function(sensorid){
        $scope.motorMetaDetails = {};
        $scope.motorMetaDetails['sensorid'] = sensorid;
        angular.forEach($scope.sensors, function(value, key){
            if(sensorid == value.sensorid){
                $scope.motor_sensor = $scope.sensors[key];
            }
        });
        apiService.get_motor_meta(sensorid).then(function(response) {
            if(response.status == 200){
                if (response.data) {
                    $scope.motorMetaDetails = response.data;                    
                }
            }
        });
    }

    $scope.selected_sensor_for_tx = function(htsensorid){
        $scope.txMetaDetails = {};
        $scope.txMetaDetails['htsensorid'] = htsensorid;
        $scope.txMetaDetails['CommissionedDate'] = moment().toDate();
        $scope.txMetaDetails['has_multiple_lt'] = false
        
        angular.forEach($scope.sensors, function(value, key){
            if(htsensorid == value.sensorid){
                $scope.tx_sensor = $scope.sensors[key];
            }
        });
        apiService.get_tx_meta(htsensorid).then(function(response) {
            if(response.status == 200){
                if (response.data) {
                    $scope.txMetaDetails = response.data;
                    $scope.txMetaDetails.CommissionedDate = moment($scope.txMetaDetails.CommissionedDate).toDate();
                }
            }
        });
    }

    $scope.save_sensor = function(sensorForm, selected_sensor){
        if(sensorForm.$valid){
            if(selected_sensor.hasOwnProperty('sensorid')){
                $scope.update_sensor(selected_sensor);
            }else{
                $scope.create_sensor(selected_sensor);
            }
        }
    }

    $scope.create_sensor = function(sensor){
        apiService.create_sensor(sensor).then(function(response) {
            if(response.status == 201){
                $scope.sensors.unshift(response.data);
                angular.element('#myModal').modal('hide');
                growl.success("Sensor created.", {
                    ttl: 5000
                });
                apiService.get_sensor_list().then(function(response) {
                $scope.sensors = response.data;
                setSensorsTable();
            });
                
            }else{
                if(response.data.hasOwnProperty('message')){
                    message = response.data.message;
                    }
                angular.element('#myModal').modal('hide');
                growl.error("Failed to create Sensor." + message, {
                    ttl: 5000
                });
            }

        }).catch(function(response) {
            message = '';
            if(response.data.hasOwnProperty('message')){
                message = response.data.message;
            }
            angular.element('#myModal').modal('hide');
            growl.error("Not able to create sensor. <br/>" + message, {
                ttl: 5000
            });
        });
    }

    $scope.update_sensor = function(sensor){
        if (sensor.parentid == undefined){
            sensor.parentid = ""
        }
        apiService.update_sensor(sensor).then(function(response) {
            if(response.status == 200){
                angular.forEach($scope.sensors, function(value, key){
                    if(response.data.sensorid == value.sensorid){
                        $scope.sensors[key] = response.data;
                        $scope.selected_sensor=response.data;
                        angular.element('#myModal').modal('hide');
                        growl.success("Sensor Updated.", {
                            ttl: 5000
                        });
                        apiService.get_sensor_list().then(function(response) {
                        $scope.sensors = response.data;
                        setSensorsTable();
                    });
                    }
                });
                
            }else{
                // message = '<ul>';
                // angular.forEach(response.data, function(k,v){
                //     message += '<li>'+ v +' : '+ k +'</li>';
                // });
                // message += '<ul>';
                growl.error("Failed to update sensor.", {
                    ttl: 5000
                });
            }
        }).catch(function(response) {
            // message = '<ul>';
            // angular.forEach(response.data, function(k,v){
            //     message += '<li>'+ v +' : '+ k +'</li>';
            // });
            // message += '<ul>';
            message = '';
            if(response.data.hasOwnProperty('message')){
                message = response.data.message;
            }
            else if(response.data.hasOwnProperty('non_field_errors')){
                message = response.data.non_field_errors;
            }
            angular.element('#myModal').modal('hide');
            growl.error("Not able to update sensor. <br/>" + message, {
                ttl: 5000
            });
        });
        
    }

    $scope.save_motor_meta = function(motorMetaForm, motorMetaDetails){
        if(motorMetaForm.$valid){
            apiService.create_or_update_motor_meta(motorMetaDetails).then(function(response) {
                if(response.status == 201 || response.status == 200){
                    angular.element('#motorMeta').modal('hide');
                    growl.success("Motor Meta Data Updated.", {
                        ttl: 5000
                    });
                    
                }else{
                    angular.element('#motorMeta').modal('hide');
                    growl.error("Failed to create Motor Meta Details.", {
                        ttl: 5000
                    });
                }

            }).catch(function(response) {
                message = '';
                if(response.data.hasOwnProperty('message')){
                    message = response.data.message;
                }
                angular.element('#motorMeta').modal('hide');
                growl.error("Not able to create Meta Details. <br/>" + message, {
                    ttl: 5000
                });
            });
        }else{
            console.log("Not valid");
        }

    }
    $scope.save_tx_meta = function(txMetaForm, txMetaDetails){
        if(txMetaForm.$valid){
            apiService.create_or_update_tx_meta(txMetaDetails).then(function(response) {
                if(response.status == 201 || response.status == 200){
                    angular.element('#txMeta').modal('hide');
                    growl.success("Tx Meta Data Updated.", {
                        ttl: 5000
                    });
                    
                }else{
                    angular.element('#txMeta').modal('hide');
                    growl.error("Failed to update Tx Meta Details.", {
                        ttl: 5000
                    });
                }

            }).catch(function(response) {
                message = '';
                if(response.data.hasOwnProperty('message')){
                    message = response.data.message;
                }
                angular.element('#txMeta').modal('hide');
                growl.error("Not able to update Meta Details. <br/>" + message, {
                    ttl: 5000
                });
            });
        }else{
            console.log("Not valid");
        }

    }


    $scope.send_command = function(){
        apiService.send_command().then(function(response) {            
            if(response.status != 200){   
                if(response.data.hasOwnProperty('message')){
                    message = response.data.message;
                    console.log(message);
                    }
                }
            bootbox.alert(response.data.message);
        });


    }



}

smartsenseApp.controller('SensorDataController', SensorDataController);

SensorDataController.$inject = ['$rootScope', 'SETTINGS', 'Session', '$scope', '$state', '$filter', '$http','growl', 'data', 'loading', '$timeout', '$compile', 'apiService','FileUploader'];

function SensorDataController($rootScope, SETTINGS, Session, $scope, $state, $filter, $http, growl, data, loading, $timeout, $compile, apiService,FileUploader) {
    
    // TODO : Need to add token in header, so everything works straight forward
    var authToken = Session.get('authToken');
    var uploader = $scope.uploader = new FileUploader({
    	
    	queueLimit: 1,
        url: SETTINGS.BASE_URL + '/upload_excel_for_manual_sensor/',
    });
    uploader.onWhenAddingFileFailed  = function(item, filter, options) {
        if(filter.name == "queueLimit") {
            uploader.clearQueue();
            uploader.addToQueue(item);
        }
    };
    uploader.headers["Authorization"] = 'token:' + authToken;
    uploader.onSuccessItem = function(fileItem, response, status, headers) {
        var message = '';
        if(response.hasOwnProperty('message')){
            message += response.message;
        }
        if(response.hasOwnProperty('validation_message')){
            message += response.validation_message;
        }
        angular.element('input[type=file]').val(null);
        uploader.clearQueue()
        growl.success("Upload complete. <br/>" + message, {
            ttl: 5000
        });
        apiService.get_sensor_list().then(function(response) {
            $scope.sensors = response.data;
        });
        $('body').removeClass('modal-open');
        $('.modal-backdrop').remove();
    };
    uploader.onErrorItem = function(fileItem, response, status, headers) {
        var message = '';
        if(response.hasOwnProperty('message')){
            message += response.message;
        }
        angular.element('input[type=file]').val(null);
        uploader.clearQueue()
        growl.error("Failed to Upload file. <br/>" + message, {
            ttl: 5000
        });
        $('body').removeClass('modal-open');
        $('.modal-backdrop').remove();
    };
    // Uploader callback functions ends


    $scope.generateObj = {}
    $scope.uploadObj = {}
    $scope.init = function(){
        
        $('input[name="daterange"]').daterangepicker({
            minDate: moment().subtract(1, 'months'),
            maxDate: moment().add(1, 'months'),
            locale: {
                format: 'YYYY-MM-DD'
            }
        });
        $('input[name="daterange"]').on('apply.daterangepicker', function(ev, picker) {
          $(this).val(picker.startDate.format('YYYY-MM-DD') + ' - ' + picker.endDate.format('YYYY-MM-DD'));
        });
        $('input[name="daterange"]').on('cancel.daterangepicker', function(ev, picker) {
          $(this).val('');
        });


        apiService.get_sensor_list().then(function(response) {
            $scope.sensors = response.data;
        });

        apiService.get_reading_type_list().then(function(response) {
            $scope.listofreadingtypes = response.data;
        });
    }

    $scope.date_changed = function(){
        date_array = angular.element('input[name="daterange"]').val().split(" - ");
        $scope.generateObj.startdate = date_array[0].trim();
        $scope.generateObj.enddate = date_array[1].trim();
    }

    $scope.generateSheet = function(generate, generateObj){
        if (generate.$valid){
            apiService.generate_excel_for_manual_sensor(generateObj).then(function(response) {
                if(response.status == 200){
                    filename = response.headers('content-disposition').split('filename=')[1];
                    var blob = new Blob([response.data], {
                        type: "application/vnd.ms-excel"
                    });
                    var objectUrl = URL.createObjectURL(blob);
                    var anchor = angular.element('<a/>');
                    angular.element(document.body).append(anchor);
                    anchor.attr({
                        href: objectUrl,
                        target: '_blank',
                        download: filename
                    })[0].click();

                    growl.success("Downloading started.", {
                        ttl: 5000
                    });
                    
                }else{
                    message = '';
                    if(response.data.hasOwnProperty('message')){
                        message = response.data.message;
                    }
                    growl.error("Failed to generate files. <br/>" + message, {
                        ttl: 5000
                    });
                }

            }).catch(function(response) {
                message = '';
                if(response.data.hasOwnProperty('message')){
                    message = response.data.message;
                }
                growl.error("Failed to generate files. <br/>" + message, {
                    ttl: 5000
                });
            });
        }

    }

    $scope.invokeUploadFile = function(that) {
        angular.element(that).scope().uploadFile(that)
        angular.element(that).scope().$digest();
    }


    $scope.upload_data = function(uploader){
            apiService.upload_excel_for_manual_sensor(uploader).then(function(response) {
                if(response.status == 200){
                    growl.success("We are processing your file.", {
                        ttl: 5000
                    });
                    
                }else{
                    message = '';
                    if(response.data.hasOwnProperty('message')){
                        message = response.data.message;
                    }
                    growl.error("Failed to process uploaded file. <br/>" + message, {
                        ttl: 5000
                    });
                }

            }).catch(function(response) {
                message = '';
                if(response.data.hasOwnProperty('message')){
                    message = response.data.message;
                }
                if(response.data.hasOwnProperty('detail')){
                    message = response.data.details;
                }
                growl.error("Failed to process uploaded file. <br/>" + message, {
                    ttl: 5000
                });
            });
        }
        

}

smartsenseApp.controller('ProfileController', ProfileController);

ProfileController.$inject = ['$scope', 'loading', 'profileService', '$timeout', 'growl', '$filter', 'apiService'];

function ProfileController($scope, loading, profileService, $timeout, growl, $filter, apiService) {
    $scope.data = {};
    $scope.data.timezoneTypes = profileService.timezoneTypes;
    $scope.data.daysOption = profileService.daysOption;
    $scope.data.targetTypes = profileService.targetTypes;
    $scope.data.allowedHours = profileService.getHours();
    $scope.data.allowedMinutes = profileService.getMinutes();
    $scope.data.maxShifts = profileService.maxShifts;
    $scope.data.maxHolidays = profileService.maxHolidays;
    $scope.data.maxEmails = 2;
    $scope.defaultValues = {
        plantshifts: [{}],
        plantholidays: [{}],
    };

    $scope.refreshInProgress = false;
    $scope.init = function() {
        if ($scope.refreshInProgress)
            return;
        $scope.refreshInProgress = true;
        loading(true);
        apiService.profile_get().then(function(profile) {

            $scope.refreshInProgress = false;
            loading(false);
            if (profile && profile.data) {
                profile = angular.extend({}, $scope.defaultValues, profile.data);
                $scope.profile = angular.extend({}, profile, profile.plant, profile.admin);
                $scope.profile.emails = [];
                $scope.profile.email.split(",").forEach(function(item){
                    $scope.profile.emails.push({
                        value : item
                    });
                });
                $scope.profile.discomid = $scope.profile.discomid ? $scope.profile.discomid.discomid : "";
                var defaultStandards = $scope.profile.standards;
                var plantStandards = [];
                var savedStandards = $scope.profile.plantstandards || [];
                for (var i = 0; i < defaultStandards.length; i++) {
                    var id = defaultStandards[i].standardid;
                    var found = false;
                    for (var j = 0; j < savedStandards.length; j++) {
                        if (savedStandards[j].standardid.standardid == id) {
                            plantStandards.push({
                                standardid: id,
                                name: defaultStandards[i].name,
                                value: parseFloat(savedStandards[j].value).toFixed(4)
                            });
                            found = true;
                            j = savedStandards.length;
                        }
                    }
                    if (!found) {
                        plantStandards.push({
                            standardid: id,
                            name: defaultStandards[i].name,
                            value: parseFloat(defaultStandards[i].defaultvalue).toFixed(4)
                        });
                    }
                }

                plantStandards = plantStandards.sort(function(a,b){
                    return a.name > b.name;
                });

                $scope.profile.plantstandards = plantStandards;

                var plantShifts = [];
                var savedShifts = $scope.profile.plantshifts;
                for (var i = 0; i < savedShifts.length; i++) {
                    var curShift = savedShifts[i];
                    if (curShift.name && curShift.starttime && curShift.endtime) {
                        var startTime = curShift.starttime.split(":");
                        var endTime = curShift.endtime.split(":");
                        plantShifts.push({
                            name: curShift.name,
                            startHour: startTime[0] || 00,
                            startMin: startTime[1] || 00,
                            endHour: endTime[0] || 00,
                            endMin: endTime[1] || 00
                        });
                    }
                }
                $scope.profile.plantshifts = plantShifts;
                $scope.bindOptions();
                $scope.bindCategories();
                $scope.profile.categoryid = $scope.profile.categoryid ? $scope.profile.categoryid.customercategoryid : "";
                
            }
        }, function(err) {
            $scope.refreshInProgress = false;
            loading(false);
            console.log(err);
        });
    }

    function getPlantStandardValue(plantStandards, defaults, id) {
        for (var i = 0; i < plantStandards.length; i++) {
            if (plantStandards[i].standardid == id) {
                if (plantStandards[i].value)
                    return value;
                else {
                    for (var j = 0; j < defaults.length; j++) {
                        if (defaults[j].standardid == id) {
                            return defaults[j].defaultvalue;
                        }
                    }
                }
            }
        }
        return 0;
    }

    $scope.saveProfile = function(profile) {
        var data = $scope.prepareData(profile);
        loading(true);
        apiService.profile_save(data).then(function(data) {
            loading(false);
            growl.success("Profile saved.", {
                ttl: 5000
            });
        }, function(err) {
            loading(false);
            growl.error("Error while saving profile. <br>" + err.data.message, {
                ttl: 10000
            });
        });
    }

    $scope.prepareData = function(profile) {
        var data = {
            name: profile.name,
            customername: profile.customername,
            address: profile.address,
            lat: profile.lat,
            lng: profile.lng,
            discomid: profile.discomid,
            categoryid: profile.categoryid,
            timezone: profile.timezone
        };
        if (profile.timezone) {
            data.timezone = profile.timezone.label
        }
        if (profile.plantholidays) {
            var holidays = [];
            profile.plantholidays.forEach(function(item, index) {
                if (item.name && item.date) {
                    holidays.push({
                        name: item.name,
                        date: $filter('date')(new Date(item.date), 'yyyy-MM-dd')
                    });
                }
            });
            data.holidays = JSON.stringify(holidays);
        }
        if (profile.plantshifts) {
            var shifts = [];
            profile.plantshifts.forEach(function(item, index) {
                if (item.name && item.startHour && item.startMin && item.endHour && item.endMin) {
                    shifts.push({
                        name: item.name,
                        starttime: item.startHour + ":" + item.startMin,
                        endtime: item.endHour + ":" + item.endMin
                    });
                }
            });
            data.shifts = JSON.stringify(shifts);
        }
        if (profile.plantstandards) {
            var standards = [];
            for (var item in profile.plantstandards) {
                if (profile.plantstandards[item] && typeof profile.plantstandards[item].value != "undefined") {
                    standards.push({
                        standardid: profile.plantstandards[item].standardid,
                        value: profile.plantstandards[item].value || ""
                    });
                }
            }
            data.standards = JSON.stringify(standards);
        }

        for (var item in profile) {
            var curItem = profile[item];
            if (typeof curItem !== "object" && typeof curItem !== "function") {
                data[item] = curItem;
            }
            else if(item == "emails"){
                var emails = [];
                curItem.forEach(function(curEmail){
                    if($.trim(curEmail.value))
                        emails.push($.trim(curEmail.value));
                });
                data.email = emails.join(",");
            }
        }
        return data;
    }

    $scope.bindOptions = function() {
        if ($scope.profile && $scope.profile.discoms) {
            $scope.profile.discoms = $scope.profile.discoms.sort(function(a, b) {
                return a.name == b.name ? 0 : +(a.name > b.name) || -1;
            });
        }
    }

    $scope.bindCategories = function() {
        var disCom = $scope.profile.discomid;
        if (disCom) {
            $scope.availableCategories = [];
            for (var i = 0; i < $scope.profile.categories.length; i++) {
                var curItem = $scope.profile.categories[i];
                if (curItem.discomid == disCom)
                    $scope.availableCategories.push(curItem);
            }
            $scope.discomPopulated = true;
        } else
            $scope.discomPopulated = false;
    }

    $scope.init();

    $scope.addShift = function() {
        if ($scope.profile.plantshifts.length < $scope.data.maxShifts)
            $scope.profile.plantshifts.push({});
    }

    $scope.removeShift = function($event, index) {
        if ($event.currentTarget)
            $event.currentTarget.blur();
        bootbox.confirm("Are you sure you want to remove this shift?", function(flag) {
            if (flag) {
                $scope.$apply(function() {
                    $scope.profile.plantshifts.remove(index);
                    $scope.reValidateShifts("", index, true);
                    $scope.reValidateShiftNames("", index, true);
                });
            }
        });
    }

    $scope.addHoliday = function() {
        if ($scope.profile.plantholidays.length < $scope.data.maxHolidays)
            $scope.profile.plantholidays.push({});
    }

    $scope.removeHoliday = function($event, index) {
        if ($event.currentTarget)
            $event.currentTarget.blur();
        bootbox.confirm("Are you sure you want to remove this holiday entry?", function(flag) {
            if (flag) {
                $scope.$apply(function() {
                    $scope.profile.plantholidays.remove(index);
                    $scope.reValidateHolidayNames("", index, true);
                    $scope.reValidateHolidayDates("", index, true);
                });
            }
        });
    }

    $scope.onHolidayDateSelect = function() {

    }

    $scope.addEmail = function(){
        // bootbox.confirm("Adding new email address to this plant means, they will get all notifications and emails, are you sure you want to add another email address?", function(flag) {
        //     if (flag) {
        //         $scope.$apply(function() {
        //             $scope.profile.emails.push({value : ""});
        //         });
        //     }
        // });
        $scope.profile.emails.push({value : ""});
    }

    $scope.removeEmail = function($event, index) {
        if ($event.currentTarget)
            $event.currentTarget.blur();
        bootbox.confirm("Are you sure you want to remove this email address?", function(flag) {
            if (flag) {
                $scope.$apply(function() {
                    $scope.profile.emails.remove(index);
                    $scope.reValidateEmails("", index, true);
                });
            }
        });
    }

    /*Duplicate email address*/
    $scope.reValidateEmails = function(value, index, force){
        if($scope.profile && $scope.profile.emails && $scope.profile.plantshifts.emails>0){
            $scope.profile.plantshifts.emails.forEach(function(item, _index) {
                if(force){
                    $scope.profileForm["email"+_index].$setDirty();
                    $scope.profileForm["email"+_index].$validate();
                }
                else{
                    if(_index != index){
                        if($scope.profileForm["email"+_index] && $scope.profileForm["email"+_index].$error.duplicateEmail){
                            $scope.profileForm["email"+_index].$setDirty();
                            $scope.profileForm["email"+_index].$validate();
                        }
                    }
                    else{
                        $scope.profileForm["email"+_index].$setDirty();
                    }
                }
            });
        }
    }

    $scope.isUniqueEmail = function(value, index){
        var isUnique = false;
        if($scope.profile && $scope.profile.emails && $scope.profile.emails.length>0){
            $scope.profile.emails.forEach(function(item, _index) {
                if(_index != index && value){
                    if($.trim(item.value) == $.trim(value)){
                        isUnique = true;
                    }
                }
            });
        }
        else
            return isUnique;
        return isUnique;
    }

    /*Duplicate shift validation*/
    $scope.reValidateShiftNames = function(value, index, force){
        if($scope.profile && $scope.profile.plantshifts && $scope.profile.plantshifts.length>0){
            $scope.profile.plantshifts.forEach(function(item, _index) {
                if(force){
                    $scope.profileForm["shift"+_index].$setDirty();
                    $scope.profileForm["shift"+_index].$validate();
                }
                else{
                    if(_index != index){
                        if($scope.profileForm["shift"+_index] && $scope.profileForm["shift"+_index].$error.duplicateName){
                            $scope.profileForm["shift"+_index].$setDirty();
                            $scope.profileForm["shift"+_index].$validate();
                        }
                    }
                    else{
                        $scope.profileForm["shift"+_index].$setDirty();
                    }
                }
            });
        }
    }

    $scope.isUniqueShiftName = function(value, index){
        var isUnique = false;
        if($scope.profile && $scope.profile.plantshifts && $scope.profile.plantshifts.length>0){
            $scope.profile.plantshifts.forEach(function(item, _index) {
                if(_index != index && value){
                    if($.trim(item.name) == $.trim(value)){
                        isUnique = true;
                    }
                }
            });
        }
        else
            return isUnique;
        return isUnique;
    }

    $scope.reValidateShifts = function(item, index, force){
        if($scope.profile && $scope.profile.plantshifts && $scope.profile.plantshifts.length>0){
            var startTime = item.startHour + ":" + item.startMin;
            var endTime = item.endHour + ":" + item.endMin;
            $scope.profile.plantshifts.forEach(function(curItem, _index) {
                if(force){
                    $scope.profileForm["shiftStartHour"+_index].$setDirty();
                    $scope.profileForm["shiftStartHour"+_index].$validate();
                }
                else
                {
                    if(_index != index){
                        if($scope.profileForm["shiftStartHour"+_index] && $scope.profileForm["shiftStartHour"+_index].$error.duplicateShift)
                        {
                            $scope.profileForm["shiftStartHour"+_index].$setDirty();
                            $scope.profileForm["shiftStartHour"+_index].$validate();
                        }
                    }
                    else{
                        $scope.profileForm["shiftStartHour"+_index].$setDirty();
                    }

                }
            });
        }
    }

    $scope.isUniqueShift = function(item, index){
        var isUnique = false;
        var startTime = item.startHour && item.startMin ? item.startHour + ":" + item.startMin : false;
        var endTime = item.endHour && item.endMin ? item.endHour + ":" + item.endMin : false;
        if($scope.profile && $scope.profile.plantshifts && $scope.profile.plantshifts.length>0){
            $scope.profile.plantshifts.forEach(function(curItem, _index) {
                if(_index != index && startTime && endTime)
                {
                    var curStartTime = curItem.startHour + ":" + curItem.startMin;
                    var curEndTime = curItem.endHour + ":" + curItem.endMin;
                    //console.log(startTime, curStartTime, endTime, curEndTime);
                    if(startTime == curStartTime && endTime == curEndTime){
                        isUnique = true;
                    }
                }
            });
        }
        else
            return isUnique;
        return isUnique;
    }

    /*Holiday Validations*/
    $scope.reValidateHolidayNames = function(value, index, force){
        if($scope.profile && $scope.profile.plantholidays && $scope.profile.plantholidays.length>0){
            $scope.profile.plantholidays.forEach(function(item, _index) {
                if(force){
                    console.log(_index, item);
                    $scope.profileForm["holiday"+_index].$setDirty();
                    $scope.profileForm["holiday"+_index].$validate();
                }
                else{
                    if(_index != index){
                        if($scope.profileForm["holiday"+_index].$error.duplicateName){
                            $scope.profileForm["holiday"+_index].$setDirty();
                            $scope.profileForm["holiday"+_index].$validate();
                        }
                    }
                    else{
                        $scope.profileForm["holiday"+_index].$setDirty();
                    }
                }
            });
        }
    }

    $scope.isUniqueHolidayName = function(value, index){
        var isUnique = false;
        if($scope.profile && $scope.profile.plantholidays && $scope.profile.plantholidays.length>0){
            $scope.profile.plantholidays.forEach(function(item, _index) {
                if(_index != index && value){
                    if($.trim(item.name) == $.trim(value)){
                        isUnique = true;
                    }
                }
            });
        }
        else
            return isUnique;
        return isUnique;
    }

    $scope.reValidateHolidayDates = function(value, index, force){
        if($scope.profile && $scope.profile.plantholidays && $scope.profile.plantholidays.length>0){
            $scope.profile.plantholidays.forEach(function(item, _index) {
                if(force){
                    $scope.profileForm["holidayDate"+_index].$setDirty();
                    $scope.profileForm["holidayDate"+_index].$validate();
                }
                else{
                    if(_index != index){
                        if($scope.profileForm["holidayDate"+_index].$error.duplicateDate){
                            $scope.profileForm["holidayDate"+_index].$setDirty();
                            $scope.profileForm["holidayDate"+_index].$validate();
                        }
                    }
                    else{
                        $scope.profileForm["holidayDate"+_index].$setDirty();
                    }
                }
            });
        }
    }

    $scope.isUniqueHolidayDate = function(value, index){
        var isUnique = false;
        if($scope.profile && $scope.profile.plantholidays && $scope.profile.plantholidays.length>0){
            $scope.profile.plantholidays.forEach(function(item, _index) {
                if(_index != index && value){
                    if(item.date == $filter('date')(new Date(value), 'yyyy-MM-dd')){
                        isUnique = true;
                    }
                }
            });
        }
        else
            return isUnique;
        return isUnique;
    }
}

smartsenseApp.factory('profileService', profileService);

profileService.$inject = [];

function profileService() {

    var timezoneTypes = [{ 
       label:'Etc/GMT+12',
       value:'(GMT-12:00) International Date Line West'
    }, {
       label:'Pacific/Midway',
       value:'(GMT-11:00) Midway Island,Samoa'
    }, {
       label:'Pacific/Honolulu',
       value:'(GMT-10:00) Hawaii'
    }, {
       label:'US/Alaska',
       value:'(GMT-09:00) Alaska'
    }, {
       label:'America/Los_Angeles',
       value:'(GMT-08:00) Pacific Time (US & Canada)'
    }, {
       label:'America/Tijuana',
       value:'(GMT-08:00) Tijuana, Baja California'
    }, {
       label:'US/Arizona',
       value:'(GMT-07:00) Arizona'
    }, {
       label:'America/Chihuahua',
       value:'(GMT-07:00) Chihuahua, La Paz, Mazatlan'
    }, {
       label:'US/Mountain',
       value:'(GMT-07:00) Mountain Time (US & Canada)'
    }, {
       label:'America/Managua',
       value:'(GMT-06:00) Central America'
    }, {
       label:'US/Central',
       value:'(GMT-06:00) Central Time (US & Canada)'
    }, {
       label:'America/Mexico_City',
       value:'(GMT-06:00) Guadalajara, Mexico City, Monterrey'
    }, {
       label:'Canada/Saskatchewan',
       value:'(GMT-06:00) Saskatchewan'
    }, {
       label:'America/Bogota',
       value:'(GMT-05:00) Bogota, Lima, Quito, Rio Branco'
    }, {
       label:'US/Eastern',
       value:'(GMT-05:00) Eastern Time (US & Canada)'
    }, {
       label:'US/East-Indiana',
       value:'(GMT-05:00) Indiana (East)'
    }, {
       label:'Canada/Atlantic',
       value:'(GMT-04:00) Atlantic Time (Canada)'
    }, {
       label:'America/Caracas',
       value:'(GMT-04:00) Caracas, La Paz'
    }, {
       label:'America/Manaus',
       value:'(GMT-04:00) Manaus'
    }, {
       label:'America/Santiago',
       value:'(GMT-04:00) Santiago'
    }, {
       label:'Canada/Newfoundland',
       value:'(GMT-03:30) Newfoundland'
    }, {
       label:'America/Sao_Paulo',
       value:'(GMT-03:00) Brasilia'
    }, {
       label:'America/Argentina/Buenos_Aires',
       value:'(GMT-03:00) Buenos Aires, Georgetown'
    }, {
       label:'America/Godthab',
       value:'(GMT-03:00) Greenland'
    }, {
       label:'America/Montevideo',
       value:'(GMT-03:00) Montevideo'
    }, {
       label:'America/Noronha',
       value:'(GMT-02:00) Mid-Atlantic'
    }, {
       label:'Atlantic/Cape_Verde',
       value:'(GMT-01:00) Cape Verde Is.'
    }, {
       label:'Atlantic/Azores',
       value:'(GMT-01:00) Azores'
    }, {
       label:'Africa/Casablanca',
       value:'(GMT+00:00) Casablanca, Monrovia, Reykjavik'
    }, {
       label:'Etc/Greenwich',
       value:'(GMT+00:00) Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London'
    }, {
       label:'Europe/Amsterdam',
       value:'(GMT+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna'
    }, {
       label:'Europe/Belgrade',
       value:'(GMT+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague'
    }, {
       label:'Europe/Brussels',
       value:'(GMT+01:00) Brussels, Copenhagen, Madrid, Paris'
    }, {
       label:'Europe/Sarajevo',
       value:'(GMT+01:00) Sarajevo, Skopje, Warsaw, Zagreb'
    }, {
       label:'Africa/Lagos',
       value:'(GMT+01:00) West Central Africa'
    }, {
       label:'Asia/Amman',
       value:'(GMT+02:00) Amman'
    }, {
       label:'Europe/Athens',
       value:'(GMT+02:00) Athens, Bucharest, Istanbul'
    }, {
       label:'Asia/Beirut',
       value:'(GMT+02:00) Beirut'
    }, {
       label:'Africa/Cairo',
       value:'(GMT+02:00) Cairo'
    }, {
       label:'Africa/Harare',
       value:'(GMT+02:00) Harare, Pretoria'
    }, {
       label:'Europe/Helsinki',
       value:'(GMT+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius'
    }, {
       label:'Asia/Jerusalem',
       value:'(GMT+02:00) Jerusalem'
    }, {
       label:'Europe/Minsk',
       value:'(GMT+02:00) Minsk'
    }, {
       label:'Africa/Windhoek',
       value:'(GMT+02:00) Windhoek'
    }, {
       label:'Asia/Kuwait',
       value:'(GMT+03:00) Kuwait, Riyadh, Baghdad'
    }, {
       label:'Europe/Moscow',
       value:'(GMT+03:00) Moscow, St. Petersburg, Volgograd'
    }, {
       label:'Africa/Nairobi',
       value:'(GMT+03:00) Nairobi'
    }, {
       label:'Asia/Tbilisi',
       value:'(GMT+03:00) Tbilisi'
    }, {
       label:'Asia/Tehran',
       value:'(GMT+03:30) Tehran'
    }, {
       label:'Asia/Muscat',
       value:'(GMT+04:00) Abu Dhabi, Muscat'
    }, {
       label:'Asia/Baku',
       value:'(GMT+04:00) Baku'
    }, {
       label:'Asia/Yerevan',
       value:'(GMT+04:00) Yerevan'
    }, {
       label:'Asia/Kabul',
       value:'(GMT+04:30) Kabul'
    }, {
       label:'Asia/Yekaterinburg',
       value:'(GMT+05:00) Yekaterinburg'
    }, {
       label:'Asia/Karachi',
       value:'(GMT+05:00) Islamabad, Karachi, Tashkent'
    }, {
       label:'Asia/Kolkata',
       value:'(GMT+05:30) Chennai, Kolkata, Mumbai, New Delhi'
    }, {
       label:'Asia/Calcutta',
       value:'(GMT+05:30) Sri Jayawardenapura'
    }, {
       label:'Asia/Katmandu',
       value:'(GMT+05:45) Kathmandu'
    }, {
       label:'Asia/Almaty',
       value:'(GMT+06:00) Almaty, Novosibirsk'
    }, {
       label:'Asia/Dhaka',
       value:'(GMT+06:00) Astana, Dhaka'
    }, {
       label:'Asia/Rangoon',
       value:'(GMT+06:30) Yangon (Rangoon)'
    }, {
       label:'Asia/Bangkok',
       value:'(GMT+07:00) Bangkok, Hanoi, Jakarta'
    }, {
       label:'Asia/Krasnoyarsk',
       value:'(GMT+07:00) Krasnoyarsk'
    }, {
       label:'Asia/Hong_Kong',
       value:'(GMT+08:00) Beijing, Chongqing, Hong Kong, Urumqi'
    }, {
       label:'Asia/Kuala_Lumpur',
       value:'(GMT+08:00) Kuala Lumpur, Singapore'
    }, {
       label:'Asia/Irkutsk',
       value:'(GMT+08:00) Irkutsk, Ulaan Bataar'
    }, {
       label:'Australia/Perth',
       value:'(GMT+08:00) Perth'
    }, {
       label:'Asia/Taipei',
       value:'(GMT+08:00) Taipei'
    }, {
       label:'Asia/Tokyo',
       value:'(GMT+09:00) Osaka, Sapporo, Tokyo'
    }, {
       label:'Asia/Seoul',
       value:'(GMT+09:00) Seoul'
    }, {
       label:'Asia/Yakutsk',
       value:'(GMT+09:00) Yakutsk'
    }, {
       label:'Australia/Adelaide',
       value:'(GMT+09:30) Adelaide'
    }, {
       label:'Australia/Darwin',
       value:'(GMT+09:30) Darwin'
    }, {
       label:'Australia/Brisbane',
       value:'(GMT+10:00) Brisbane'
    }, {
       label:'Australia/Canberra',
       value:'(GMT+10:00) Canberra, Melbourne, Sydney'
    }, {
       label:'Australia/Hobart',
       value:'(GMT+10:00) Hobart'
    }, {
       label:'Pacific/Guam',
       value:'(GMT+10:00) Guam, Port Moresby'
    }, {
       label:'Asia/Vladivostok',
       value:'(GMT+10:00) Vladivostok'
    }, {
       label:'Asia/Magadan',
       value:'(GMT+11:00) Magadan, Solomon Is., New Caledonia'
    }, {
       label:'Pacific/Auckland',
       value:'(GMT+12:00) Auckland, Wellington'
    }, {
       label:'Pacific/Fiji',
       value:'(GMT+12:00) Fiji, Kamchatka, Marshall Is.'
    }, {
       label:'Pacific/Tongatapu',
       value:'(GMT+13:00) Nuku alofa'
    }];

    var daysOption = [{
        label: 'Mon',
        value: 2
    }, {
        label: 'Tue',
        value: 3
    }, {
        label: 'Wed',
        value: 4
    }, {
        label: 'Thu',
        value: 5
    }, {
        label: 'Fri',
        value: 6
    }, {
        label: 'Sat',
        value: 7
    }, {
        label: 'Sun',
        value: 1
    }];

    var targetTypes = [{
        label: 'Daily',
        value: 'daily'
    }, {
        label: 'Weekly',
        value: 'weekly'
    }, {
        label: 'Monthly',
        value: 'monthly'
    }, {
        label: 'Yearly',
        value: 'yearly'
    }];

    var defaultReadingTypeId = 2002;
    var maxShifts = 4;
    var maxHolidays = 20;

    ////////////

    function getHours() {
        var hours = [];
        for (var i = 0; i < 24; i++) {
            var label = i < 10 ? '0' + i : i + '';
            hours.push({
                label: label,
                value: label
            });
        }
        return hours
    }

    function getMinutes() {
        var minutes = [{
            label: '00',
            value: '00'
        }, {
            label: '15',
            value: '15'
        }, {
            label: '30',
            value: '30'
        }, {
            label: '45',
            value: '45'
        }];
        return minutes;
    }

    var service = {
        /* Allowed values for radio and select inputs */
        timezoneTypes: timezoneTypes,
        daysOption: daysOption,
        targetTypes : targetTypes,
        getHours: getHours,
        getMinutes: getMinutes,
        maxShifts : maxShifts,
        maxHolidays : maxHolidays
    };

    return service;
}

smartsenseApp.controller('MotorInsightsNewController', MotorInsightsNewController);

MotorInsightsNewController.$inject = ['$scope', '$filter', 'timeseriesService', 'readingTypeService', 'grainService', 'data', 'loading', 'motorInsightsNewService', '$timeout', '$compile', 'profileService', 'growl', '$state', 'Analytics', 'apiService'];

function MotorInsightsNewController($scope, $filter, timeseriesService, readingTypeService, grainService, data, loading, motorInsightsNewService, $timeout, $compile, profileService, growl, $state, Analytics, apiService) {
    //Default parameters
    $scope.insightInfo = {
        fromDate : moment().subtract(1, 'month').startOf("month"),
        toDate : moment(),
        selectedIssue : null,
        calendarIssueData : null,
        filter : null,
        actiontaken : {
            // actionDate : new Date(),
            act : {}
        },
        graphData : []
    };

    /*Get list of readingtypes*/
    readingTypeService.getAll().then(function(data) {
        $scope.readingTypes = data.data;
    });

    $scope.graphOptions = {
        chartTypeBasedOnScalar : true,
        hideXAxisLabels : true,
        hideYAxisLabels : true,
        sameyAxis: 0,
        xAxis : { },
    };

    $scope.loadingGraphOptions = {
        chart: {
            height: 250
        },
        hideXAxisLabels : true,
        hideYAxisLabels : true,
        sameyAxis: 0,
        onlyDataName : true
    };

    $scope.hasAnyActionSelected = function(acts){
        var hasSelection = false;
        for(var item in acts){
            if(item && acts[item])
                hasSelection = true;
        }
        return hasSelection;
    }

    $scope.isDateInRange = function(date, selection, summaryDate){
        var startDate = $scope.insightInfo.fromDate;
        var endDate = moment($scope.insightInfo.fromDate).add(1, "month").endOf('month');
        if(selection){
            endDate = moment($scope.insightInfo.toDate);
        }
        if(endDate.diff(moment())>0)
            endDate = moment();
        if(summaryDate){
            startDate = $scope.insightInfo.currentFromDate;
            endDate = $scope.insightInfo.currentToDate;
        }
        var range = moment().range(startDate, endDate);
        return range.contains(date);
    };

    $scope.$watch('insightInfo.fromDate', function(newDate, oldDate) {
        if (newDate && newDate != oldDate) {
            var mDate = moment(newDate);
            if(newDate){
                if(!$scope.isDateInRange($scope.insightInfo.toDate)){
                    $scope.insightInfo.toDate = moment($scope.insightInfo.fromDate).add(1, "month").endOf('month');
                    if($scope.insightInfo.toDate.diff(moment())>0)
                        $scope.insightInfo.toDate = moment();
                }
            }
        }
    }, false);

    /* Following functions binds with the date change. Responsible for enabling/disabling dates according to selected startDate/endDate of report */

    $scope.endDateBeforeRender = endDateBeforeRender;
    $scope.endDateOnSetTime = endDateOnSetTime;
    $scope.startDateBeforeRender = startDateBeforeRender;
    $scope.startDateOnSetTime = startDateOnSetTime;

    $scope.actionDateBeforeRender = actionDateBeforeRender;

    function startDateOnSetTime() {
        $scope.$broadcast('start-date-changed');
    }

    function endDateOnSetTime() {
        $scope.$broadcast('end-date-changed');
    }

    function startDateBeforeRender($dates) {
        $dates.filter(function(date) {
            return date.localDateValue() > new Date().getTime();
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    function actionDateBeforeRender($dates) {
        $dates.filter(function(date) {
            var issueInfo = $scope.insightInfo.selectedIssueInfo;
            if(issueInfo){
                var evenddate = issueInfo.eventdate;
                return date.localDateValue() > new Date().getTime() || date.localDateValue() < moment(evenddate, "YYYY-MM-DD").valueOf();
            }
            else{
                return date.localDateValue() > new Date().getTime();
            }
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    function endDateBeforeRender($dates) {
        $dates.filter(function(date) {
            return !$scope.isDateInRange(moment(date.localDateValue()));
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    $scope.reset = function(){
        $scope.init();
    }

    $scope.resetEvent = function(startDate, endDate, readingtypeid, assetid, eventName, eventDate, assetName, recommendation, id, eventstatus){
        $scope.showGrapForEvent(startDate, endDate, readingtypeid, assetid, eventName, eventDate, assetName, recommendation, id, eventstatus);
    }

    $scope.resetImb = function(assetid, startDate, endDate){
        $scope.showGraphForImbalance(assetid, startDate, endDate);
    }

    $scope.resetLoading = function(assetid, startDate, endDate) {
        $scope.showGraphForLoading(assetid, startDate, endDate);
    }

    $scope.resetCurrent = function(assetid, startDate, endDate) {
        $scope.showGraphForNeutralCurrent(assetid, startDate, endDate);
    }

    $scope.resetIndex = function(assetid, startDate, endDate) {
        $scope.showGraphForHealthIndex(assetid, startDate, endDate);
    }

    /*Insights new APIs*/
    $scope.clearSelections = function(){
        $scope.insightInfo.actiontaken = {
            actionDate : new Date(),
            act : {}
        };
        $scope.insightInfo.calendarIssueData =
        $scope.insightInfo.filter =
        $scope.insightInfo.selectedIssueInfo =
        $scope.insightInfo.selectedIssue =
        $scope.insightInfo.selectedAsset =
        $scope.insightInfo.selectedCalendarDate =
        $scope.insightInfo.graphData = null;
        $scope.insightInfo.graphEventData = null;
        $scope.insightInfo.graphMonitoringData = null;
    };

    // Get most recent event date on load and set it as a end date in calendar
    $scope.getMostRecentEventDate = function(callback){
        apiService.motor_events_summary_date().then(function(response) {
            if(callback)
                callback(moment(response.data.LastEventTime * 1000));
        });
    }

    //Get issue data from server for specified date range
    $scope.fetchIssueSummary = function(){
        $scope.clearSelections();
        $scope.refreshInProgress = true;
        loading(true);

        $scope.orderByLength = function (name) {
            return - name.Events.length
        }

        var startDate = moment($scope.insightInfo.fromDate).format("YYYY-MM-DD");
        var endDate = moment($scope.insightInfo.toDate).format("YYYY-MM-DD");

        apiService.motor_events_summary(startDate, endDate).then(function(response) {

            loading(false);
            if (response && response.data) {
                $scope.refreshInProgress = false;
                $scope.insightInfo.currentFromDate = startDate;
                $scope.insightInfo.currentToDate = endDate;
                $scope.serverNotRecheable = false;
                $scope.eventsData = response.data;
                $scope.eventsData.assetData.forEach(function(key) {
                    key.count = '';
                    $scope.openCount = $filter('filter')(key.Events, {eventstatus: 'Open'}).length;
                    key.count = $scope.openCount;
                })
            }
        }, function(error) {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });

        $scope.showApplyButton = !$scope.showApplyButton;
    };

    $scope.getGrain = function() {
        $scope.grains = grainService.get($scope.insightInfo.fromDate, $scope.insightInfo.toDate);
        $scope.grain = $scope.grains[0].value;
    }

    $scope.setClickedRow = function(group, row, startDate, endDate, readingtypeid, assetid, eventName, eventDate, assetName, recommendation, id, eventstatus){
        $scope.selectedGroup=  group;
        $scope.selectedRow = row; 
        $scope.showGrapForEvent(startDate, endDate, readingtypeid, assetid, eventName, eventDate, assetName, recommendation, id, eventstatus);
    };

    $scope.showGrapForEvent = function(startDate, endDate, readingtypeid, assetid, eventName, eventDate, assetName, recommendation, id, eventstatus) {
        loading(true);
        $scope.startDate = startDate;
        $scope.endDate = endDate;
        $scope.readingtypeid = readingtypeid;
        $scope.sensorid = assetid;
        $scope.eventName = eventName;
        $scope.eventDate = moment(eventDate).format("MMM D,YYYY HH:mm:ss a");
        $scope.assetName = assetName;
        $scope.recommendation = recommendation;
        $scope.eid = id;
        $scope.eventstatus = eventstatus;
        $scope.getGrain();

        var epochTimestamp = moment(eventDate).format("YYYY-MM-DD HH:mm:ss");
        var epochDate = new Date(epochTimestamp).getTime();
        var epochNextTimestamp = moment(eventDate).add(1, 'days');
        epochNextTimestamp = moment(epochNextTimestamp).format("YYYY-MM-DD HH:mm:ss");
        var epochNextDate = new Date(epochNextTimestamp).getTime();
        $scope.graphOptions.xAxis.plotBands = [];
        $scope.graphOptions.xAxis.plotBands.push({
            color: 'rgba(215, 255, 179, 0.57)',
            from: epochDate,
            to: epochNextDate,
            type: 'datetime',
            label: { 
                text: "<i>Event Name</i><br>" + eventName,
                align: 'center',
                style: {
                    fontSize: '12px',
                    fontWeight: 'bold'
                },
                y: 30
            }
        });

        var params = {
            fromdate:startDate,
            todate:endDate,
            grain:$scope.grain,
            readingtypeid:readingtypeid,
            sensorid:assetid
        }
        apiService.reading_series(params).then(function(response) {
            loading(false);
            $scope.insightInfo.graphEventData = response.data;
            $scope.insightInfo.activityLog = $scope.recommendation.activitylog;
            $scope.insightInfo.actionSummary = $scope.recommendation.actionsummary;
            if($scope.insightInfo.actionSummary && $scope.eventstatus && $scope.eventstatus != "Open"){
                if($scope.insightInfo.actionSummary.eventuserreponse){
                    var response = $scope.insightInfo.actionSummary.eventuserreponse.split(",");
                    response.forEach(function(item){
                        $scope.insightInfo.actiontaken.act[item] = true;
                    });
                }
                $scope.insightInfo.actiontaken.comment = $scope.insightInfo.actionSummary.eventusercomment;
                $scope.insightInfo.actiontaken.action = $scope.eventstatus  ;
                $scope.insightInfo.actiontaken.actionDate = moment($scope.insightInfo.actionSummary.eventuserresponsedate);
                $scope.insightInfo.actiontaken.hasAction = true;
            }
            else{
                $scope.insightInfo.actiontaken = {
                    actionDate : new Date(),
                    act : {}
                };
            }
            var readingType = $scope.insightInfo.graphEventData && $scope.insightInfo.graphEventData[0].timeseries && $scope.insightInfo.graphEventData[0].readingtype ? $scope.insightInfo.graphEventData[0].readingtype : false;
            if(readingType){
                $scope.insightInfo.graphEventData[0].timeseries.name = readingType.readingtypename;
                $scope.insightInfo.graphEventData[0].timeseries.chartType = "line";
                $scope.insightInfo.graphEventData[0].timeseries.yaxis = {
                    min : 0,
                    max : 100
                };
            }
            // $('html, body').animate({
            //     scrollTop: $("#motorInsight-lineChart").offset().top + 500
            // }, 1000);
            $scope.insightInfo.graphEventData[0].timeseries = $scope.insightInfo.graphEventData[0].timeseries;
        }, function() {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });
        $scope.insightInfo.graphMonitoringData = false;
        $scope.insightInfo.activityList = false;
        $scope.showApplyEventButton = !$scope.showApplyEventButton;
    }

    $scope.showGraphForImbalance = function(assetid, startDate, endDate) {
        $scope.getGrain();

        var startDate = moment(startDate).format("YYYY-MM-DD");
        var endDate = moment(endDate).format("YYYY-MM-DD");
        var params = {
            startdate : startDate,
            enddate : endDate,
            sensorid : assetid,
            grain: $scope.grain,
        }
        apiService.motorevents_monitorimbalance(params).then(function(response){
            loading(false);
            $scope.insightInfo.graphMonitoringData = response.data;
            if($scope.insightInfo.graphMonitoringData.Imbalance){
                var imbalance = [];
                $scope.insightInfo.graphMonitoringData.Imbalance.CurrentImbalance.name = "Current Imbalance";
                $scope.insightInfo.graphMonitoringData.Imbalance.CurrentImbalance.chartType = "line";

                for (var i = 0; i < $scope.insightInfo.graphMonitoringData.Imbalance.CurrentImbalance.timeseries.length; i++) {
                    if($scope.insightInfo.graphMonitoringData.Imbalance.CurrentImbalance.timeseries[i].value)
                        $scope.insightInfo.graphMonitoringData.Imbalance.CurrentImbalance.timeseries[i].value = $scope.insightInfo.graphMonitoringData.Imbalance.CurrentImbalance.timeseries[i].value;
                }
                imbalance.push($scope.insightInfo.graphMonitoringData.Imbalance.CurrentImbalance);

                $scope.insightInfo.graphMonitoringData.Imbalance.VoltageImbalance.name = "Voltage Imbalance";
                $scope.insightInfo.graphMonitoringData.Imbalance.VoltageImbalance.chartType = "line";
                
                for (var i = 0; i < $scope.insightInfo.graphMonitoringData.Imbalance.VoltageImbalance.timeseries.length; i++) {
                    if($scope.insightInfo.graphMonitoringData.Imbalance.VoltageImbalance.timeseries[i].value)
                        $scope.insightInfo.graphMonitoringData.Imbalance.VoltageImbalance.timeseries[i].value = $scope.insightInfo.graphMonitoringData.Imbalance.VoltageImbalance.timeseries[i].value;
                }
                imbalance.push($scope.insightInfo.graphMonitoringData.Imbalance.VoltageImbalance);

                var lineCosntants = $scope.insightInfo.graphMonitoringData.Imbalance.lineconstant;
                var lineConstantGraphs = [];
                for(var lineItem in lineCosntants){
                    var lineItemValue = lineCosntants[lineItem];
                    var customLine = false;
                    var constantLine = {
                        timeseries : [],
                        "readingType": {
                            "readingtypeid": null,
                            "readingtypename": lineItem,
                            "parentreadingtypeid": null,
                            "export": false,
                            "timebased": false,
                            "scalar": true,
                            "priority": 1
                        }
                    };
                    $scope.insightInfo.graphMonitoringData.Imbalance.CurrentImbalance.timeseries.forEach(function(curTS){
                        constantLine.timeseries.push({
                            timeStamp : curTS.timeStamp,
                            value : lineItemValue.Value || lineItemValue
                        });
                    });

                    if(customLine){
                        lineConstantGraphs.push(constantLine);
                    }
                    else{
                        lineConstantGraphs.push({
                            type : "lineConstant",
                            name: constantLine.name || lineItem,
                            chartType : "line",
                            lineWidth : 1,
                            dashStyle : "Dash",
                            animation: false,
                            timeseries: constantLine.timeseries,
                            readingtype: constantLine.readingType,
                            unit : lineItemValue.Unit,
                            id: "Graph_" + utils.random()
                        });
                    }

                }
                $scope.insightInfo.graphMonitoringData.Imbalance.imbalanceProcessed = imbalance.concat(lineConstantGraphs);
            }
            $scope.setImbalanceGraphType("Imbalance");
        }, function() {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });

        $scope.showApplyImbButton = !$scope.showApplyImbButton;
    }

    $scope.showGraphForLoading = function(assetid, startDate, endDate) {
        $scope.getGrain();

        var startDate = moment(startDate).format("YYYY-MM-DD");
        var endDate = moment(endDate).format("YYYY-MM-DD");
        var params = {
            startdate : startDate,
            enddate : endDate,
            sensorid : assetid,
            grain: $scope.grain,
        }
        apiService.motorevents_monitorloading(params).then(function(response) {
            loading(false);
            $scope.insightInfo.graphMonitoringLoadingData = response.data;
            if($scope.insightInfo.graphMonitoringLoadingData.Loading){
                var current = [];
                for(var item in $scope.insightInfo.graphMonitoringLoadingData.Loading.CurrentMonth){
                    var curData = $scope.insightInfo.graphMonitoringLoadingData.Loading.CurrentMonth[item];
                    curData.name = item;
                    current.push(curData);
                }
                $scope.insightInfo.graphMonitoringLoadingData.Loading.currentmonthProcessed = current;

                var prev = [];
                for(var item in $scope.insightInfo.graphMonitoringLoadingData.Loading.PreviousMonth){
                    var curData = $scope.insightInfo.graphMonitoringLoadingData.Loading.PreviousMonth[item];
                    curData.name = item;
                    prev.push(curData);
                }
                $scope.insightInfo.graphMonitoringLoadingData.Loading.prevmonthProcessed = prev;

                $scope.insightInfo.graphMonitoringLoadingData.Loading.KW.name = "KW";
                $scope.insightInfo.graphMonitoringLoadingData.Loading.KW.color = "#437ede";
                $scope.insightInfo.graphMonitoringLoadingData.Loading.KW.chartType = "line";

                var lineCosntants = $scope.insightInfo.graphMonitoringLoadingData.Loading.lineconstant;
                var lineConstantGraphs = [];
                for(var lineItem in lineCosntants){
                    var lineItemValue = lineCosntants[lineItem];
                    var customLine = false;
                    var constantLine = {
                        timeseries : [],
                        "readingType": {
                            "readingtypeid": null,
                            "readingtypename": lineItem,
                            "parentreadingtypeid": null,
                            "export": false,
                            "timebased": false,
                            "scalar": true,
                            "priority": 1
                        }
                    };
                    if(lineItem == "OverLoadLimit"){
                        constantLine = {
                            name : "Overload Limit",
                            color : "red",
                            chartType : "line",
                            lineWidth : 1,
                            dashStyle : "Dash",
                            timeseries : [],
                            readingType : {
                               export : false,
                               parentreadingtypeid : null,
                                priority : 1,
                                readingtypeid : null,
                                readingtypename : "Overload Limit",
                                scalar : false,
                                timebased : false
                            },
                            unit : lineItemValue.Unit
                        };
                        $scope.insightInfo.graphMonitoringLoadingData.Loading.OverLoadLimit = lineItemValue;
                        customLine = true;
                    }
                    else if(lineItem == "UnderLoadLimit"){
                        constantLine = {
                            name : "Underload Limit",
                            color : "blue",
                            chartType : "line",
                            lineWidth : 1,
                            dashStyle : "Dash",
                            timeseries : [],
                            readingType : {
                               export : false,
                               parentreadingtypeid : null,
                                priority : 1,
                                readingtypeid : null,
                                readingtypename : "Underload Limit",
                                scalar : false,
                                timebased : false
                            },
                            unit : lineItemValue.Unit
                        };
                        $scope.insightInfo.graphMonitoringLoadingData.Loading.UnderLoadLimit = lineItemValue;
                        customLine = true;
                    }
                    $scope.insightInfo.graphMonitoringLoadingData.Loading.KW.timeseries.forEach(function(curTS){
                        constantLine.timeseries.push({
                            timeStamp : curTS.timeStamp,
                            value : lineItemValue.Value || lineItemValue
                        });
                    });
                    if(customLine){
                        lineConstantGraphs.push(constantLine);
                    }
                    else{
                        lineConstantGraphs.push({
                            type : "lineConstant",
                            name: constantLine.name || lineItem,
                            chartType : "line",
                            lineWidth : 1,
                            dashStyle : "Dash",
                            animation: false,
                            timeseries: constantLine.timeseries,
                            readingtype: constantLine.readingType,
                            unit : lineItemValue.Unit,
                            id: "Graph_" + utils.random()
                        });
                    }
                }

                /*Genrating loading stacked bar graphs*/
                var curMonthData = $scope.insightInfo.graphMonitoringLoadingData.Loading.CurrentMonth;
                var prevMonthData = $scope.insightInfo.graphMonitoringLoadingData.Loading.PreviousMonth;
                var curWeekData = $scope.insightInfo.graphMonitoringLoadingData.Loading.CurrentWeek;
                var prevWeekData = $scope.insightInfo.graphMonitoringLoadingData.Loading.PreviousWeek;
                var selectedPeriodData = $scope.insightInfo.graphMonitoringLoadingData.Loading.SelectedPeriod;
                var barGraphCategories = ['Current Month', 'Previous Month', 'Current Week', 'Previous Week', 'Selected Period'];
                var barGraphsSeries = [{
                    showInLegend: false,
                    name: 'Off Hours',
                    data: [
                        curMonthData.Off.Percent,
                        prevMonthData.Off.Percent,
                        curWeekData.Off.Percent,
                        prevWeekData.Off.Percent,
                        selectedPeriodData.Off.Percent],
                    color : "#b1e67b"
                },{
                    showInLegend: false,
                    name: 'Under Loading',
                    data: [
                        curMonthData.UnderLoading.Percent,
                        prevMonthData.UnderLoading.Percent,
                        curWeekData.UnderLoading.Percent,
                        prevWeekData.UnderLoading.Percent,
                        selectedPeriodData.UnderLoading.Percent],
                    color : "#b9e2f7"
                },{
                    showInLegend: false,
                    name: 'Normal Loading',
                    data: [
                        curMonthData.NormalLoading.Percent,
                        prevMonthData.NormalLoading.Percent,
                        curWeekData.NormalLoading.Percent,
                        prevWeekData.NormalLoading.Percent,
                        selectedPeriodData.NormalLoading.Percent],
                    color : "#feda56"
                },{
                    showInLegend: false,
                    name: 'Over Loading',
                    data: [
                        curMonthData.OverLoading.Percent,
                        prevMonthData.OverLoading.Percent,
                        curWeekData.OverLoading.Percent,
                        prevWeekData.OverLoading.Percent,
                        selectedPeriodData.OverLoading.Percent],
                    color : "#fe9985"
                }];

                $scope.loadingBarChartOptions = {
                    chart : {
                        height:175
                    },
                    plotOptions: {
                        series: {
                            cursor: 'pointer',
                            point: {
                                events: {
                                    click: function () {
                                        $scope.insightInfo.graphMonitoringLoadingData.Loading.SelectedBarChart = this.category;
                                        $scope.$apply();
                                    }
                                }
                            }
                        }
                    },
                    xAxis : {
                        categories : barGraphCategories
                    },
                    hideXAxisLabels : true,
                    hideYAxisLabels : true,
                    series : barGraphsSeries
                };
                $scope.insightInfo.graphMonitoringLoadingData.Loading.SelectedBarChart = barGraphCategories[0];
                $scope.insightInfo.graphMonitoringLoadingData.Loading.kwProcessed = [$scope.insightInfo.graphMonitoringLoadingData.Loading.KW].concat(lineConstantGraphs);
            }
        }, function() {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });
        $scope.showApplyLoadingButton = !$scope.showApplyLoadingButton;
    }

    $scope.showGraphForNeutralCurrent = function(assetid, startDate, endDate) {
        $scope.getGrain();

         var params = {
            fromdate:startDate,
            todate:endDate,
            grain:$scope.grain,
            readingtypeid:2051,
            sensorid:assetid
        }
        apiService.reading_series(params).then(function(response) {
            loading(false);
            $scope.insightInfo.graphMonitoringDataCurrent = response.data;
            var readingType = $scope.insightInfo.graphMonitoringDataCurrent && $scope.insightInfo.graphMonitoringDataCurrent[0].timeseries && $scope.insightInfo.graphMonitoringDataCurrent[0].readingtype ? $scope.insightInfo.graphMonitoringDataCurrent[0].readingtype : false;
            if(readingType){
                $scope.insightInfo.graphMonitoringDataCurrent[0].timeseries.name = readingType.readingtypename;
                $scope.insightInfo.graphMonitoringDataCurrent[0].timeseries.chartType = "line";
                $scope.insightInfo.graphMonitoringDataCurrent[0].timeseries.yaxis = {
                    min : 0,
                    max : 100
                };
            }
            $scope.insightInfo.graphMonitoringDataCurrent[0].timeseries = $scope.insightInfo.graphMonitoringDataCurrent[0].timeseries;
        }, function() {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });
        $scope.showApplyCurrentButton = !$scope.showApplyCurrentButton;
    }

    $scope.showGraphForHealthIndex = function(assetid, startDate, endDate) {
        $scope.getGrain();

         var params = {
            fromdate:startDate,
            todate:endDate,
            grain:$scope.grain,
            readingtypeid:5026,
            sensorid:assetid
        }
        apiService.reading_series(params).then(function(response) {
            loading(false);
            $scope.insightInfo.graphMonitoringDataHealth = response.data;
            var readingType = $scope.insightInfo.graphMonitoringDataHealth && $scope.insightInfo.graphMonitoringDataHealth[0].timeseries && $scope.insightInfo.graphMonitoringDataHealth[0].readingtype ? $scope.insightInfo.graphMonitoringDataHealth[0].readingtype : false;
            if(readingType){
                $scope.insightInfo.graphMonitoringDataHealth[0].timeseries.name = readingType.readingtypename;
                $scope.insightInfo.graphMonitoringDataHealth[0].timeseries.chartType = "line";
                $scope.insightInfo.graphMonitoringDataHealth[0].timeseries.yaxis = {
                    min : 0,
                    max : 100
                };
            }
            $scope.insightInfo.graphMonitoringDataHealth[0].timeseries = $scope.insightInfo.graphMonitoringDataHealth[0].timeseries;
        }, function() {
            loading(false);
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });
        $scope.showApplyIndexButton = !$scope.showApplyIndexButton;
    }

    $scope.showGrapForConditionalMonitoring = function(assetid, assetName, $event) {
        $event.stopPropagation();
        $event.preventDefault();
        loading(true);
        $scope.assetName = assetName;
        $scope.sensorid = assetid;
        $scope.insightInfo.graphMonitoringData = false;

        $scope.startDateImbalance = moment($scope.insightInfo.fromDate).format("YYYY-MM-DD");
        $scope.endDateImbalance = moment($scope.insightInfo.toDate).format("YYYY-MM-DD");

        $scope.startDateLoading = moment($scope.insightInfo.fromDate).format("YYYY-MM-DD");
        $scope.endDateLoading = moment($scope.insightInfo.toDate).format("YYYY-MM-DD");

        $scope.startDateCurrent = $scope.insightInfo.fromDate;
        $scope.endDateCurrent = $scope.insightInfo.toDate;

        $scope.startDateHealth = $scope.insightInfo.fromDate;
        $scope.endDateHealth = $scope.insightInfo.toDate;

        $scope.showGraphForLoading(assetid, $scope.startDateLoading, $scope.endDateLoading);
        $scope.showGraphForImbalance(assetid, $scope.startDateImbalance, $scope.endDateImbalance);
        $scope.showGraphForNeutralCurrent(assetid, $scope.startDateCurrent, $scope.endDateCurrent);
        $scope.showGraphForHealthIndex(assetid, $scope.startDateHealth, $scope.endDateHealth);

        $('html, body').animate({
            scrollTop: $("#motorInsight-lineChart").offset().top + 500
        }, 1000);

        $scope.insightInfo.graphEventData = false;
        $scope.insightInfo.activityList = false;
    }

    $scope.closeEvent = function() {
        $scope.insightInfo.graphEventData = false;
    }

    $scope.closeMonitoring = function() {
        $scope.insightInfo.graphMonitoringData = false;
    }

    $scope.activityList = function() {
        alert("hi");
    }

    $scope.getActivityList = function(assetid, $event) {
        $event.stopPropagation();
        $event.preventDefault();
        loading(true);
        $scope.assetid = assetid;
        var params = {
            assetid:assetid,
            assettype:'motor'
        }
        apiService.get_insights_activity_log(params).then(function(response){
            loading(false);
            $scope.insightInfo.activityList = response.data.ActivityLog;
            $scope.email = response.data.lastemail;
            $timeout(function(){
                try{
                    $('html, body').animate({
                        scrollTop: $(".activity-summary").offset().top - 140
                    }, 1000);
                }catch(ex){}
            }, 500);
        },function() {
            loading(false);
        });
        $scope.insightInfo.graphEventData = false;
        $scope.insightInfo.graphMonitoringData = false;
    }

    $scope.addActivity = function(activityLogDate, activityLogName, activityLogType, assetid, $event) {
        loading(true)
        var timestamp = moment(activityLogDate).format("YYYY-MM-DD HH:mm:ss");
        var params = {
            eventtypeid: activityLogType,
            timestamp: timestamp,
            eventname: activityLogName,
            assetid: assetid,
            assettype: 'motor'
        };
        apiService.add_manual_insights_log(params).then(function(response){
            loading(false);
            $scope.getActivityList(assetid, $event);
        }, function(error) {
            loading(false);
        });
    }

    $scope.downloadReport = function(assetid) {
        loading(true);
        var params = {
            isemail: false,
            isdownload: true,
            assetid: assetid,
            assettype: 'motor'
        }
        apiService.activityLog_download(params).then(function(response) {
            loading(false);
            var exts = ".xls";
            var blob = new Blob([response.data], {
                type: 'application/vnd.ms-excel'
            });
            var objectUrl = URL.createObjectURL(blob);
            var anchor = angular.element('<a/>');
            angular.element(document.body).append(anchor);
            anchor.attr({
                href: objectUrl,
                target: '_blank',
                download: 'report' + exts
            })[0].click();
            $timeout(function() {
                bootbox.alert("Thank you for using Smartsense Insights. Your log has been downloaded.");
            }, 2000);
        }, function() {
            loading(false);
        });
    }

    $scope.emailReport = function(assetid, email) {
        loading(true);
        var params = {
            isemail: true,
            isdownload: false,
            assetid: assetid,
            assettype: 'motor',
            emailto: email
        }
        apiService.activityLog_email(params).then(function(response) {
            loading(false);
            $scope.email = null;
            $timeout(function() {
                bootbox.alert("Thank you for using Smartsense Insights. Your log with request id " + email + " will be delivered to your given email id.");
            }, 2000);
        }, function() {
            loading(false);
        });
    }

    $scope.setImbalanceGraphType = function(type){
        if((type == "Voltage" || type == "Current") && (!$scope.insightInfo.graphMonitoringData || (!$scope.insightInfo.graphMonitoringData.Imbalance.voltageProcessed || !$scope.insightInfo.graphMonitoringData.Imbalance.currentProcessed))){
            $scope.insightInfo.selectedImbalanceGraphType = type;
            var lineGraphData = $scope.insightInfo.graphMonitoringData;
            if(lineGraphData.Imbalance){
                var current = [];
                for(var item in lineGraphData.Imbalance.Current){
                    var curData = lineGraphData.Imbalance.Current[item];
                    curData.name = item;
                    curData.chartType = "line";
                    current.push(curData);
                }
                $scope.insightInfo.graphMonitoringData.Imbalance.currentProcessed = current;
                var voltage = [];
                for(var item in lineGraphData.Imbalance.Voltage){
                    var curData = lineGraphData.Imbalance.Voltage[item];
                    curData.name = item;
                    curData.chartType = "line";
                    voltage.push(curData);
                }
                $scope.insightInfo.graphMonitoringData.Imbalance.voltageProcessed = voltage;
            }
        }
        else
            $scope.insightInfo.selectedImbalanceGraphType = type;
    }

    $scope.getActivityLog = function(){
        var issueInfo = $scope.insightInfo.selectedIssueInfo;
        if(!issueInfo)
            return;
        var isseuId = issueInfo.IssueId;
        var tableName = issueInfo.TableName;
        apiService.motor_get_activity_log(isseuId, tableName).then(function(response) {
            $scope.insightInfo.selectedIssueInfo.activityLog = response.data.activityLogs;
        });
    }

    $scope.submitActivityLog = function(){
        // var issueInfo = $scope.insightInfo.selectedIssueInfo;
        // if(!issueInfo)
        //     return;

        loading(true);
        // var curAct = $scope.insightInfo.actiontaken.action;
        var userResponses = $scope.insightInfo.actiontaken.act;
        var eventuserresponse = [];
        for(var act in userResponses){
            if(userResponses[act] == true)
                eventuserresponse.push(act + "");
        }
        var curAct = $scope.insightInfo.actiontaken.action;
        var eventid = $scope.eid;
        var eventdate = moment($scope.eventDate).format("YYYY-MM-DD");
        var eventstatus = curAct;
        var eventcomment = $scope.insightInfo.actiontaken.comment;
        var eventuseractiondate = moment($scope.insightInfo.actiontaken.actionDate).format("YYYY/MM/DD HH:mm:ss");
        apiService.motor_submit_activity_log(eventid, eventdate, eventstatus, eventcomment, eventuserresponse.join(","), eventuseractiondate).then(function(response) {
            angular.forEach($scope.actionForm, function (input) {
                if (input && input.hasOwnProperty('$viewValue')) {
                  input.$setPristine();
                }
            });
            growl.success("Activity saved.", {
                ttl: 3000
            });
            $scope.insightInfo.activityLog = response.data.ActivityLog;
            $scope.resetActionFormValidation();
            if(curAct != $scope.insightInfo.filter)
            {
                loading(false);
                $scope.insightInfo.actiontaken = {
                    // actionDate : new Date(),
                    act : {}
                };
                $scope.fetchIssueSummary();
            }
            else{
                loading(false);
                $scope.insightInfo.actiontaken.hasAction = true;
            }
        }, function(err){
            growl.error("Error while saving activity. <br>" + err.message, {
                ttl: 3000
            });
        });
    }

    $scope.getTime = function(epoch){
        return moment(epoch*1000).format("DD/MM/YYYY hh:mm A");
    }

    $scope.hasSummary = function(){
        if($scope.insightInfo.selectedIssueInfo && $scope.insightInfo.selectedIssueInfo.Summary && Object.keys($scope.insightInfo.selectedIssueInfo.Summary).length>0)
            return true;
        else
            return false;
    }

    $scope.setForm = function(form){
        $scope.actionForm = form;
    }

    $scope.resetActionFormValidation = function(){
        var form = $scope.actionForm;
        if(!form)
            return;
        if(form.$setPristine){
            form.$setPristine();
        } else {
            form.$pristine = true;
            form.$dirty = false;
            angular.forEach(form, function (input, key) {
                if (input.$pristine)
                    input.$pristine = true;
                if (input.$dirty) {
                    input.$dirty = false;
                }
            });
        }
    };

    //Init Data
    $scope.init = function(){
        $scope.holidays = [];
        if ($scope.refreshInProgress)
            return;
        $scope.refreshInProgress = true;
        loading(true);
        apiService.profile_get().then(function(profile) {
            if(profile && profile.data.plantholidays && profile.data.plantholidays.length>0){
                var holidays = profile.data.plantholidays;
                for (var i = 0; i < holidays.length; i++) {
                    $scope.holidays.push({
                        date : holidays[i].date,
                        name : holidays[i].name
                    });
                }
            }
            $scope.getMostRecentEventDate(function(date){
                $scope.insightInfo.fromDate = date.subtract(1, 'month').startOf("month");
                $timeout(function(){
                    $scope.fetchIssueSummary();
                    $scope.$apply();
                }, 100);
            });
        });

    }

    $scope.init();
}

smartsenseApp.factory('motorInsightsNewService', motorInsightsNewService);

motorInsightsNewService.$inject = ['$http', 'timeseriesService', 'SETTINGS', 'data'];

function motorInsightsNewService($http, timeseriesService, SETTINGS, data) {

    var filters = {
        category: [{
            label: 'All',
            value: ''
        }, {
            label: 'Health',
            value: 'health'
        }, {
            label: 'Energy',
            value: 'energy'
        }],
        type: [{
            label: 'All',
            value: ''
        }, {
            label: 'Asset',
            value: 'assets'
        }, {
            label: 'Tags',
            value: 'tags'
        }, {
            label: 'Plant',
            value: 'overall'
        }],
        status: [{
            label: 'All',
            value: 'all'
        }, {
            label: 'Open',
            value: 'open'
        }, {
            label: 'Ignored',
            value: 'ignored'
        }, {
            label: 'Resolved',
            value: 'resolved'
        }]
    };

    var service = {
        filters: filters,
        getActual: getActual,
        createFlags: createFlags,
        generatePieChartData: generatePieChartData,
        getTimeSeries : getTimeSeries
    };

    return service;

    //////////

    function getTimeSeries(data) {
        var grain = data.grain || {
            value: 15
        };
        var req = {
            fromdate: data.fromDate,
            todate: data.toDate,
            sensorid: data.sensorsIds,
            readingtypeid: data.readingTypeId,
            grain: data.grain
        };
        return timeseriesService.getSensorTimeseries(req);
    }

    function getActual(issue) {
        issue.SensorsIds = issue.SensorsIds ? issue.SensorsIds : issue.SensorIds;
        var req = {
            fromdate: issue.StartDate,
            todate: issue.EndDate,
            sensorid: issue.SensorsIds.join(),
            readingtypeid: issue.ReadingTypeId,
            grain: {
                value: 15
            }
        };
        return timeseriesService.getSensorTimeseries(req);
    }

    function createFlags(flags) {
        var chartFlagSeries = [];
        angular.forEach(flags, function(value, datetime) {
            chartFlagSeries.push({
                x: parseInt(datetime) * 1000,
                title: "!",
                text: value
            });
        });
        return chartFlagSeries;
    }

    function generatePieChartData(issues) {
        var issueMapping = {};
        if (issues && issues.length > 0) {
            for (var i = 0; i < issues.length; i++) {
                var curIssue = issues[i];
                issueMapping[curIssue.Category] = issueMapping[curIssue.Category] || [];
                issueMapping[curIssue.Category].push(curIssue);
            }
        }
        var pieChartData = [];
        for (var type in issueMapping) {
            pieChartData.push({
                name: type,
                unit: '',
                y: issueMapping[type].length,
                value: issueMapping[type].length,
                color: type == 'Energy' ? '#437EDE' : '#B8E986',
            });
        }
        var pieChartConfig = {
            tooltip: {
                pointFormatter: function() {
                    return '<b> Total : ' + this.value + '</b>';
                },
                shared: true
            },
            colorByPoint: true,
            data: pieChartData
        }
        return pieChartConfig;

    }

}

smartsenseApp.controller('UtilizationController', UtilizationController);

UtilizationController.$inject = ['$scope', '$filter', 'data', 'loading', '$timeout', 'growl', '$state', 'apiService', 'local', 'highchartService'];

function UtilizationController($scope, $filter, data, loading, $timeout, growl, $state, apiService, local, highchartService) { 
// 
    $scope.grain = "daily";
    var grain = $scope.grain;

    $scope.daterange = {
        startDate: moment().subtract(7, 'days'),
        endDate: moment()
    }

    $scope.dateRangeOpts = {
        locale: {
            fromLabel: "From",
            format: 'MMMM D, YYYY',
            toLabel: "To",
            customRangeLabel: 'Custom Range'
        },
        opens: "left",
        autoApply: true,
        linkedCalendars:false,
        eventHandlers: {
            'apply.daterangepicker': function(ev, picker) {
                $scope.getData();
            }
        },
        ranges: { 
            'Last 7 Days': [moment().subtract(6, 'days'), moment()], 
            'Last 30 Days': [moment().subtract(29, 'days'), moment()], 
            'Last 3 months': [moment().subtract(2, 'months').startOf('month'), moment()], 
            'Last 6 months': [moment().subtract(5, 'months').startOf('month'), moment()], 
            'Last 12 Months': [moment().subtract(1, 'year').startOf('month'), moment()], 
            'This Year': [moment([moment().year()]), moment()] 
        }  
    };

    $scope.filter = {
        sector : [],
        business: [],
        location: [],
        type: [],
        stand: []
    }

    $scope.chartConfig = highchartService.GeneralConfig();
    $scope.chartConfig.options.xAxis.categories = [];
    $scope.chartConfig.options.yAxis[0] = { title: { text: "% Utilization" } , min: 0 , max: 100 };
    $scope.chartConfig.options.legend = { align: 'center', verticalAlign: 'bottom', x: 0, y: -20, layout: 'horizontal',};
    $scope.chartConfig.options.plotOptions = { series: { stacking: 'normal'}, line:{ marker:{ enabled:true, symbol:'square', lineWidth: 5, lineColor: '#DDDF0D'} } }
    $scope.chartConfig.title = {text: '', align: 'center', x: 0, verticalAlign: 'bottom', y: 0}
    $scope.chartConfig.options.tooltip = {
        shared: true,
        headerFormat: '{point.key}<br/>',
        pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:0.0f}</b><br/>'
    }

    $scope.dialChartConfig = highchartService.gaugeConfig();
    $scope.dialChartConfig.options.chart.height = 150;
    $scope.dialChartConfig.options.chart.style = {position: "relative", bottom: "10" }
    $scope.dialChartConfig.options.title.text = "Utilization";
    $scope.dialChartConfig.options.pane.size = '140%';
    $scope.dialChartConfig.options.pane.center = ['50%', '75%'];
    $scope.dialChartConfig.options.yAxis = {
        stops: [
        [0.1, '#DF5353'], 
        [0.5, '#DDDF0D'],
        [0.9, '#55BF3B']
        ],
        lineWidth: 0,
        minorTickInterval: null,
        tickAmount: 2,
        title: {
            y: -70
        },
        labels: {
            y: 16
        },
        min: 0,
        max: 100
    };
    $scope.dialChartConfig.title = { text: 'Utilization for selected time period', x: 0, verticalAlign: 'bottom', y: -2, style: { fontSize: '12px'} };

    $scope.availableTimeChartConfig = highchartService.pieChartConfig()
    $scope.availableTimeChartConfig.options.tooltip = {
        headerFormat: '{point.key}<br/>',
        pointFormat: '<span style="color:{point.color}">\u25CF</span><b> {point.y:0.2f}% </b>of total AvailableTime<br/>'
    }
    $scope.availableTimeChartConfig.options.chart.height = 150;
    $scope.availableTimeChartConfig.options.chart.style = {position: "relative", bottom: "10" };
    $scope.availableTimeChartConfig.title = { text: '',align: 'center', x: 0, verticalAlign: 'bottom', y: 10, style: { fontSize: '12px'} };

    $scope.plannedTimeChartConfig = angular.copy($scope.availableTimeChartConfig);
    $scope.plannedTimeChartConfig.options.tooltip = {
        headerFormat: '{point.key}<br/>',
        pointFormat: '<span style="color:{point.color}">\u25CF</span><b> {point.custom:0.2f}% </b>of total AvailableTime<br/><span style="color:{point.color}">\u25CF</span><b> {point.y:0.2f}%</b> of PlannedTime'
    }

    $scope.unplannedTimeChartConfig = angular.copy($scope.availableTimeChartConfig)
    $scope.unplannedTimeChartConfig.options.tooltip = {
        headerFormat: '{point.key}<br/>',
        pointFormat: '<span style="color:{point.color}">\u25CF</span><b> {point.custom:0.2f}% </b>of total AvailableTime<br/><span style="color:{point.color}">\u25CF</span><b> {point.y:0.2f}%</b> of Unplanned DownTime'
    }

    $scope.getCategories = function() {
        loading(true);
        $scope.categories = [];
        apiService.eaton_utilization_categories().then(function(response) {
            loading(false);
            $scope.categories = response.data;
        }, function(error) {
            loading(false);
        });
    }
    $scope.getCategories();

    $scope.getData = function() {
        $scope.chartConfig.series = [];
        $scope.dialChartConfig.series = [];
        $scope.availableTimeChartConfig.series = [];
        $scope.plannedTimeChartConfig.series = [];
        $scope.unplannedTimeChartConfig.series = [];
        loading(true);
        var sector = $scope.filter.sector.toString();
        var business = $scope.filter.business.toString();
        var location = $scope.filter.location.toString();
        var stand = $scope.filter.stand.toString();
        var type = $scope.filter.type.toString();
        var params = {
            starttime : moment($scope.daterange.startDate).format("YYYY-MM-DD"),
            endtime : moment($scope.daterange.endDate).format("YYYY-MM-DD"),
            grain : $scope.grain,
            sector: sector,
            business: business,
            location: location,
            stand: stand,
            type: type
        }
        apiService.eaton_utilization_timeseries(params).then(function(response) {
            loading(false);
            var list = [];
            var total = [];
            if (response.data.series.RunTime.length != 0 && response.data.series.Utilization.length != 0 && response.data.series.SetUpTime.length != 0 && response.data.series.PlannedTime.length != 0 && response.data.series.UnplannedTime.length != 0 && response.data.series.IdleTime.length != 0) {
                $scope.dataAvailable = response.data;
                total.push($scope.dataAvailable.utilization);
                $scope.dialChartConfig.series.push({
                    name: 'Utilization',
                    data: total
                });

                if(response.data.show_pie != true) {
                    $("div.pieCharts").addClass("disabled")
                } else {
                    $("div.pieCharts").removeClass("disabled")
                }

                $scope.availableTimeChartConfig.series.push({
                    data: [{
                        name: 'Run Time',
                        y: response.data.run_time,
                        color: '#DD7722' 
                    }, {
                        name: 'Set Up Time',
                        y: response.data.setup_time,
                        color: '#22AA99' 
                    }, {
                        name: 'Unplanned DownTime',
                        y: response.data.unplanned_down_time,
                        color: '#2288cc'
                    }, {
                        name: 'Planned DownTime',
                        y: response.data.planned_down_time,
                        color: '#94caf9'
                    }, {
                        name: 'Idle Run Time',
                        y: response.data.idle_time,
                        color: '#dd3322'
                    }]
                });
                $scope.availableTimeChartConfig.title.text = "Available Time"

                $scope.plannedTimeChartConfig.series.push({
                    data: [{
                        name: 'Preventive Maintenance Time',
                        y: response.data.preventive_maintenance_time,
                        color: '#63D23C',
                        custom: (response.data.preventive_maintenance_time * response.data.planned_down_time)/100
                    }, {
                        name: 'Test Stand Upgrades',
                        y: response.data.test_stand_upgrades,
                        color: '#D4F600',
                        custom: (response.data.test_stand_upgrades * response.data.planned_down_time)/100
                    }, {
                        name: 'Calibration',
                        y: response.data.calibration,
                        color: '#C38BC9',
                        custom: (response.data.calibration * response.data.planned_down_time)/100
                    }]
                });
                $scope.plannedTimeChartConfig.title.text = "Planned DownTime"

                $scope.unplannedTimeChartConfig.series.push({
                    data: [{
                        name: 'Test Stand Breakdown',
                        y: response.data.test_stand_breakdown,
                        color: '#FF9CAD',
                        custom: (response.data.test_stand_breakdown * response.data.unplanned_down_time)/100
                    }, {
                        name: 'No Operator',
                        y: response.data.no_operator,
                        color: '#B9B9BC',
                        custom: (response.data.no_operator * response.data.unplanned_down_time)/100
                    }]
                });
                $scope.unplannedTimeChartConfig.title.text = "Unplanned DownTime"

                angular.forEach(response.data.series.RunTime, function(k,v) {
                    if($scope.grain == "daily") {
                        list.push(moment(Object.keys(k)[0]).format("ddd-MM-DD"))
                    } else {
                        list.push(Object.keys(k)[0]);
                    }
                });
                $scope.chartConfig.options.xAxis.categories = list;
                angular.forEach(response.data.series, function(v, k) {
                    var keys = Object.keys(v),i=0,len=0;
                    var arr = [];
                    for (i=0,len=keys.length;i<len;i++) {
                        arr.push([v[i][Object.keys(v[i])[0]]]);
                    }
                    if (k == "RunTime") {
                        $scope.chartConfig.series.push({
                            name:'RunTime %',
                            data:arr,
                            type: 'column',
                            stack: true,
                            color: '#DD7722',
                            legendIndex:1,
                            index: 6
                        });
                    } else if (k == "SetUpTime") {
                        $scope.chartConfig.series.push({
                            name:'SetUpTime %',
                            data:arr,
                            type: 'column',
                            stack: true,
                            color: '#22AA99',
                            legendIndex:2,
                            index: 5
                        });
                    } else if (k == "UnplannedTime") {
                        $scope.chartConfig.series.push({
                            name:'Unplanned DownTime %',
                            data:arr,
                            type: 'column',
                            stack: true,
                            color: '#2288cc',
                            legendIndex:3,
                            index: 3
                        });
                    } else if (k == "PlannedTime") {
                        $scope.chartConfig.series.push({
                            name:'Planned DownTime %',
                            data:arr,
                            type: 'column',
                            stack: true,
                            color: '#94caf9',
                            legendIndex:4,
                            index: 2
                        });
                    } else if (k == "IdleTime") {
                        $scope.chartConfig.series.push({
                            name:'Idle Time %',
                            data:arr,
                            type: 'column',
                            stack: true,
                            color: '#dd3322',
                            legendIndex:5,
                            index: 1
                        });
                    } else if (k == "Utilization") {
                        $scope.chartConfig.series.push({
                            name:'Utilization(RunTime + Setup Time) %',
                            data:arr,
                            type: 'line',
                            stack: false,
                            color: '#DDDF0D',
                            zIndex: 2,
                            legendIndex:0,
                            index: 4,
                            dataLabels: {
                                enabled: true,
                                rotation: 0,
                                color: '#000000',
                                align: 'left',
                                format: '{point.y:.0f}'+'%',
                                // y: 10,
                                // x: 25,
                                style: {
                                    fontSize: '12px'
                                }
                            }
                        });
                    }
                });
            } else {
                $scope.dataAvailable = false;
            };
            
        }, function(error) {

        });
    }
    $scope.getData();

    $scope.clearFilter = function() {
        $scope.filter = {
            sector : [],
            business: [],
            location: [],
            type: [],
            stand: []
        };
        $scope.getCategories();
        $scope.grain = "daily";
        $scope.chartConfig.series = [];
        $scope.dialChartConfig.series = [];
        $scope.availableTimeChartConfig.series = [];
        $scope.plannedTimeChartConfig.series = [];
        $scope.unplannedTimeChartConfig.series = [];
        $scope.daterange = {
            startDate: moment().subtract(7, 'days'),
            endDate: moment()
        }
        $scope.getData();
    };

}

smartsenseApp.controller('ChillerInsightsController', ChillerInsightsController);
ChillerInsightsController.$inject = ['$scope', 'orderByFilter', 'NgTableParams', 'local', 'apiService', 'chillers', 'chiller_uiconfigs'];

function ChillerInsightsController($scope, orderByFilter, NgTableParams, local, apiService, chillers, chiller_uiconfigs) {

    $scope.localData = local.data;

    // Default Selection
    var default_selected = {
        chiller: {},
        health: {},
        event: {},
        view: {
            event: { open: false },
            health: { open: true },
            chillerlist: { open: true},
            meta: {open:true}
        }
    };

    // Selected variable to store all user selection like chiller, event, health etc
    $scope.selected = angular.copy(default_selected);

    $scope.conditionMonitoringGraphConfigs = [];

    $scope.date = {
        health: {
            dateRange: {
                startDate: moment().subtract(1, 'days').startOf('day'),
                endDate: moment()
            },
            dateRangeOpts: {
                locale: {
                    fromLabel: "From",
                    format: 'MMM D, YYYY',
                    toLabel: "To",
                    customRangeLabel: 'Custom Range'
                },
                opens: 'left',
                autoApply: true,
                maxDate: new Date(),
                eventHandlers: {
                    'apply.daterangepicker': function(ev, picker) {
                        $scope.showHealthGraph();
                    }
                },
                ranges: {
                    'Today': [moment().startOf('day'), moment()],
                    'Last 7 Days': [moment().subtract(6, 'days'), moment()],
                    'Last 30 Days': [moment().subtract(29, 'days'), moment()],
                    'Last 3 months': [moment().subtract(2, 'months').startOf('month'), moment()],
                    'Last 6 months': [moment().subtract(5, 'months').startOf('month'), moment()],
                    'Last 12 Months': [moment().subtract(1, 'year').startOf('month'), moment()],
                    'This Year': [moment([moment().year()]), moment()]
                }
            }
        }
    };

    $scope.init = function() {
        // Set Chiller List Table
        var chiller_list = chillers.data.chillers;
        angular.forEach(chiller_list, function(chiller, index) {
            chiller_list[index].name = $scope.localData.sensors[chiller.sensor_id].name;
        });
        $scope.chillers = chiller_list;
        var initialParams = {
            count: 5, // initial page size,
            sorting: { name: "asc" }
        };
        var initialSettings = {
            // page size buttons (right set of buttons in demo)
            counts: [],
            // determines the pager buttons (left set of buttons in demo)
            paginationMaxBlocks: 4,
            paginationMinBlocks: 2,
            dataset: $scope.chillers
        };
        $scope.tableParams = new NgTableParams(initialParams, initialSettings);

        // Set Condition Monitoring List
        if (chiller_uiconfigs.data.chiller_ui_configs.length > 0) {
            var result = chiller_uiconfigs.data.chiller_ui_configs[0].config.graphs.reduce(function(r, a) {
                r[a.category] = r[a.category] || [];
                r[a.category].push(a);
                return r;
            }, Object.create(null));
            $scope.conditionMonitoringGraphConfigs = result;
        }
    };

    $scope.showHealthGraph1 = function() {
        var chartConfig = {
            options: {
                chart: {
                    zoomType: 'x',
                    defaultType: 'area'
                },
                xAxis: {
                    type: 'datetime'
                },
                yAxis: [],
                tooltip: {
                    valueSuffix: ''
                }
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        };
        var params = {
            grain: 15,
            fromdate: $scope.date.health.dateRange.startDate,
            todate: $scope.date.health.dateRange.endDate,
            sensorid: $scope.selected.chiller.sensor_id
        };
        $scope.selected.health.chartConfig = chartConfig;
        $scope.selected.health.chartConfig.loading = true;
        angular.forEach($scope.selected.health.config, function(item, index) {
            angular.forEach(item.parameters, function(readingtypeid, key) {
                params.readingtypeid = readingtypeid;
                apiService.reading_series(params).then(function(response) {
                    var data = response.data[0];
                    var readingtype = data.readingtype;
                    var series = {
                        name: readingtype.readingtypename,
                        timeSeries: data.timeseries,
                        readingtype: readingtype,
                        unit: readingtype.unit,
                        type: 'line'
                    };
                    $scope.selected.health.chartConfig.series.push(series);
                    $scope.selected.health.chartConfig.loading = false;
                }, function(error) {
                    $scope.selected.health.chartConfig.loading = false;
                });
            })

        });
    }

    $scope.showHealthGraph = function() {
        var chartConfig = {
            options: {
                chart: {
                    zoomType: 'x',
                    defaultType: 'area'
                },
                xAxis: {
                    type: 'datetime'
                },
                yAxis: [],
                tooltip: {
                    valueSuffix: ''
                }
            },
            series: [],
            title: {
                text: ''
            },
            loading: false
        };
        var params = {
            grain: 15,
            fromdate: $scope.date.health.dateRange.startDate,
            todate: $scope.date.health.dateRange.endDate,
            sensorid: $scope.selected.chiller.sensor_id
        };
        $scope.selected.health.chartConfig = chartConfig;
        $scope.selected.health.chartConfig.loading = true;
        angular.forEach($scope.selected.health.config.parameters, function(readingtypeid, key) {
            params.readingtypeid = readingtypeid;
            apiService.reading_series(params).then(function(response) {
                var data = response.data[0];
                var readingtype = data.readingtype;
                var series = {
                    name: readingtype.readingtypename,
                    timeSeries: data.timeseries,
                    readingtype: readingtype,
                    unit: readingtype.unit,
                    type: 'line'
                };
                $scope.selected.health.chartConfig.series.push(series);
                $scope.selected.health.chartConfig.loading = false;
            }, function(error) {
                $scope.selected.health.chartConfig.loading = false;
            });
        });
    }

    $scope.selectHealth = function(config) {
        $scope.selected.health = { config: config, chartConfig: {} };
        $scope.showHealthGraph();
    }

    $scope.selectChiller = function(item) {
        if (item.sensor_id == $scope.selected.chiller.sensor_id) {
            $scope.selected = angular.copy(default_selected);
            return;
        }
        console.log(item);
        $scope.selected.chiller = item;
        var category = Object.keys($scope.conditionMonitoringGraphConfigs)[0];
        var config = $scope.conditionMonitoringGraphConfigs[category][0];
        $scope.selectHealth(config);
    }

    $scope.init();

}
smartsenseApp.controller('TreeBuilderController', TreeBuilderController);

TreeBuilderController.$inject = ['$scope', '$filter', 'data', 'loading', '$timeout', 'growl', '$state', 'apiService' , '$log', 'local'];

function TreeBuilderController($scope, $filter, data, loading, $timeout, growl, $state, apiService, $log, local) { 
    $scope.localData = local.data;
    $scope.sensors = $scope.localData.sensorlist;
    $scope.readingtypes = $scope.localData.readingtypeslist
    $scope.locations = $scope.localData.locations;
    $scope.tree = {};
    $scope.sensorlist = [];
    $scope.saveBtn = true;
    angular.forEach($scope.sensors, function(k,v) {
        $scope.sensorlist.push({
            name: k.name,
            sensorid: k.sensorid
        })
    })

    apiService.sensor_health().then(function(response) {
        $scope.sensorHealth = response.data;
        $scope.localData.sensorHealth = response.data;
    });

    $scope.tagTransform = function (newTag) {
        var item = {
            name: newTag,
            sensorid: ''
        };
        return item;
    };

    $scope.disabled = undefined;

    $scope.treeConfig = {
        core : {
            multiple : false,
            animation: true,
            error : function(error) {
                $log.error('treeCtrl: error from js tree - ' + angular.toJson(error));
            },
            check_callback : true,
            worker : true
        },
        types : {
            default : {
                icon : 'fa fa-info-circle'
            }
        },
        version : 1,
        plugins : ['types','contextmenu','conditionalselect'],
        contextmenu: {
            items: function(node) {
                var tree = $scope.treeInstance.jstree(true);
                return {
                    "Rename": {
                        "separator_before": false,
                        "separator_after": false,
                        "label": "Edit",
                        "icon" : "fa fa-pencil",
                        "action": function (obj) { 
                            // alert(node);
                            loading(true)
                            apiService.get_single_node(node.id).then(function(response) {
                                loading(false);
                                $scope.updateBtn = true;
                                $scope.saveBtn = false;
                                $scope.nodelist = {
                                    sensorname: [{
                                        name: response.data.name,
                                        sensorid: response.data.sensorid
                                    }],
                                    nodename: response.data.name,
                                    parent: response.data.parent,
                                    readingtypeid: response.data.readingtypeid,
                                    showalert: response.data.showalerts,
                                    id: response.data.id
                                };
                                // $scope.nodelist.sensorname.push({
                                //     name: response.data.name,
                                //     sensorid: response.data.sensorid
                                // })
                            })
                            // tree.edit(node,'',function(node,status) {
                            //     for (var i = 0; i < $scope.originalData.length; i++) {
                            //         if($scope.originalData[i].id == tree._model.data[node.id].id) {
                            //             if($scope.originalData[i].parent == '#') {
                            //                 $scope.originalData[i].parent = '';
                            //                 var params = {
                            //                     sensorid: $scope.originalData[i].sensorid,
                            //                     parent: $scope.originalData[i].parent,
                            //                     readingtypeid: $scope.originalData[i].readingtypeid,
                            //                     treeid: $scope.originalData[i].treeid,
                            //                     order: $scope.originalData[i].order,
                            //                     name: tree._model.data[node.id].text,
                            //                     id: $scope.originalData[i].id
                            //                 }
                            //             } else {
                            //                 var params = {
                            //                     sensorid: $scope.originalData[i].sensorid,
                            //                     parent: $scope.originalData[i].parent,
                            //                     readingtypeid: $scope.originalData[i].readingtypeid,
                            //                     treeid: $scope.originalData[i].treeid,
                            //                     order: $scope.originalData[i].order,
                            //                     name: tree._model.data[node.id].text,
                            //                     id: $scope.originalData[i].id
                            //                 }
                            //             }
                            //             apiService.edit_node(params).then(function(response) {
                            //                 loading(false);
                            //             })
                            //         }
                            //     }
                            // });
                        }
                    },
                    "Remove": {
                        "separator_before": false,
                        "separator_after": false,
                        "label": "Remove",
                        "icon" : "fa fa-trash",
                        "action": function (obj) { 
                            var id = tree._model.data[node.id].id;
                            apiService.delete_node(id).then(function(response) {
                                tree.delete_node(node);
                                loading(false);
                            })
                        }
                    }
                };
            }
        }
    };

    $scope.reCreateTree = function() {
        $scope.treeConfig.version++;
    }

    $scope.createTree = function(treename) {
        loading(true)
        var params = {
            memberid: $scope.localData.memberId,
            name: treename
        }
        apiService.create_tree(params).then(function(response) {
            loading(false);
            $scope.getTreeList();
        }, function() {
            loading(false)
        });

    }

    $scope.getTreeList = function() {
        loading(true)
        apiService.retrieve_tree().then(function(response) {
            loading(false)
            $scope.treeList = response.data;
            angular.forEach($scope.treeList, function(k,v) {
                if($scope.treeList[v].name == 'DEFAULT') {
                    var default_tree = $scope.treeList[v].name
                    $scope.treeid = $scope.treeList[v].id;
                    $scope.getTreeNodes($scope.treeid);
                } 
                // else {
                //     $scope.treeid = $scope.treeList[0].id;
                //     $scope.getTreeNodes($scope.treeid);
                // }
            });
            // $scope.treeid = $scope.treeList[0].id;
            // $scope.getTreeNodes($scope.treeid);
        }, function() {
            loading(false)
        });
    }
    $scope.getTreeList();

    $scope.nodelist = {
        sensorname: [],
        nodename: '',
        parent: '',
        readingtypeid: '',
        showalert: ''
    };

    $scope.submitNode = function(treeid) {
        loading(true)
        var params = {
            sensorid: $scope.nodelist.sensorname[0]['sensorid'],
            name: $scope.nodelist.sensorname[0]['name'],
            parent: $scope.nodelist.parent,
            readingtypeid: $scope.nodelist.readingtypeid,
            treeid: treeid,
            order: 3,
            showalerts: $scope.nodelist.showalert
        }
        apiService.create_node(params).then(function(response) {
            loading(false)
            $scope.getTreeNodes(treeid);
            $scope.nodelist = {
                sensorname: [],
                nodename: '',
                parent: '',
                readingtypeid: '',
                showalert: ''
            };
        }, function() {
            loading(false);
        });
    }

    $scope.getTreeNodes = function(treeid) {
        loading(true);
        apiService.get_tree_nodes(treeid).then(function(response) {
            loading(false);
            for (var i = 0; i < response.data.data.length; i++) {
                for (var x = 0; x < $scope.sensorlist.length; x++) {
                    if (response.data.data[i].sensorid == $scope.sensorlist[x].sensorid) {
                        $scope.sensorlist.splice(x, 1);
                    };
                };
            }
            $scope.originalData = response.data.data;
            $scope.parentData = []
            angular.forEach($scope.originalData, function(k,v) {
                $scope.parentData.push({
                    text: k.name,
                    id: k.id,
                })
            })
            for (var i = 0; i < $scope.originalData.length; i++) {
                $scope.originalData[i].text = $scope.originalData[i].name + ' : ' + $scope.originalData[i].readingtypeid.readingtypename;
                delete $scope.originalData[i].name;
                if($scope.originalData[i].parent == null) {
                    $scope.originalData[i].parent = '#'
                }
                $scope.originalData[i].state = {
                    opened : true
                }
                // if($scope.originalData[i].showalerts == true) {
                //     $scope.originalData[i].icon = "fa fa-exclamation-triangle",
                //     $scope.originalData[i].a_attr = {
                //         title: "alerts: yes"
                //     }
                // }

                angular.forEach($scope.localData.sensorHealth.sensor_health_details, function(k,v) {
                    if (k.sensor_id == $scope.originalData[i].sensorid) {
                        $('#tree').on('mouseenter', '.jstree-anchor', function () {
                            $('[data-toggle="tooltip"]').tooltip({
                                template: '<div class="tooltip tooltip-custom"><h3 class="title">Sensor Health</h3><div class="tooltip-arrow"></div><div class="content">Status: <span>'+ k.sensor_status +'</span></div><div class="tooltip-inner"></div></div>'
                            });
                        });
                        $scope.originalData[i].icon = "fa fa-exclamation-triangle",
                        $scope.originalData[i].a_attr = {
                            "class": "show_tooltip",
                            "data-toggle": "tooltip",
                            "data-placement": "right",
                            "title": "Last Communicated:" + k.last_communicated
                        }

                    };

                })
                $scope.originalData[i].li_attr = {
                    readingtypeid: $scope.originalData[i].readingtypeid
                }
                // $scope.originalData[i].children = ["text","abc"]
            }
            $scope.treeData = [];
            angular.copy($scope.originalData,$scope.treeData);
            $scope.readyCB();
            $scope.reCreateTree();
        }, function() {
            loading(false);
        });
    }

    $scope.updateNode = function(treeid) {
        loading(true);
        var params = {
            sensorid: $scope.nodelist.sensorname[0]['sensorid'],
            name: $scope.nodelist.sensorname[0]['name'],
            parent: $scope.nodelist.parent,
            readingtypeid: $scope.nodelist.readingtypeid,
            treeid: treeid,
            order: 3,
            showalerts: $scope.nodelist.showalert,
            id: $scope.nodelist.id
        }
        apiService.edit_node(params).then(function(response) {
            loading(false);
            $scope.getTreeNodes(treeid)
            $scope.updateBtn = false;
            $scope.saveBtn = true;
            $scope.nodelist = {
                sensorname: [],
                nodename: '',
                parent: '',
                readingtypeid: '',
                showalert: ''
            };
        })
    }

    $scope.ignoreChanges = false;

    $scope.readyCB = function() {
        // $timeout(function() {
        //     $scope.ignoreChanges = false;
        //     // toaster.pop('success', 'JS Tree Ready', 'Js Tree issued the ready event')
        // });
    };

    $scope.createCB  = function(e,item) {
        // $timeout(function() {toaster.pop('success', 'Node Added', 'Added new node with the text ' + item.node.text)});
    };

    $scope.applyModelChanges = function() {
        return !$scope.ignoreChanges;
    };
}

smartsenseApp.directive('widgetFormula', ["RecursionHelper", function(RecursionHelper) {
    return {
        restrict: 'AE',
        scope: {
            formula: '=',
            types: '=',
            operators: '=',
            locations: '=',
            readingtypes: '=',
            sensortypeids: '=',
            onTypeChange: '&',
            addOperator: '&',
            removeOperator: '&'
        },
        templateUrl: 'components/widgetBuilder/templates/computed_parameters/formula.tpl.html',
        replace: true,
        compile: function(element) {
            // Use the compile function from the RecursionHelper,
            // And return the linking function(s) which it returns
            return RecursionHelper.compile(element);
        }
    };
}]);

smartsenseApp.directive('computedParameter', ["RecursionHelper", function(RecursionHelper) {
    return {
        restrict: 'AE',
        scope: {
            parameter: '=',
            types: '=',
            operators: '=',
            locations: '=',
            readingtypes: '=',
            sensortypeids: '=',
            onTypeChange: '&',
            isParent: '='
        },
        templateUrl: 'components/widgetBuilder/templates/table/formula.tpl.html',
        replace: true,
        compile: function(element) {
            // Use the compile function from the RecursionHelper,
            // And return the linking function(s) which it returns
            return RecursionHelper.compile(element, function(scope, element, attrs) {
                var alphabets = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
                var alphabet_prefix = "df.";
                var alphabet_counter = 0;

                scope.addOperator = function(ngModel) {
                    ngModel.push({
                        type: 'operator',
                        value: '+'
                    });
                    ngModel.push({
                        type: 'parameter',
                        parameter: {}
                    });
                };

                scope.removeOperator = function(parameters, parameter) {
                    var index = parameters.indexOf(parameter);
                    if (index > 1) {
                        parameters.splice(index - 1, 2);
                    }
                }

                scope.makeEquation = function(formula) {
                    var formulaText = '';
                    if (formula instanceof Array) {
                        angular.forEach(formula, function(value) {
                            if (value.type == 'formula') {
                                formulaText += " ( " + scope.makeEquation(value.formula) + " ) ";
                            } else {
                                var text = '';
                                if (value.type == 'operator') {
                                    text = value.value;
                                } else if (value.type == 'parameter') {
                                    var alphabet = alphabet_prefix + alphabets[alphabet_counter];
                                    scope.parameter.parameters[alphabet] = value.parameter;
                                    text = alphabet;
                                    alphabet_counter++;
                                } else if (value.type == 'value') {
                                    text = value.value;
                                }
                                if (text) {
                                    formulaText += text + ' ';
                                }
                            }
                        });
                    }
                    return formulaText;
                };
                scope.createEquation = function(formula) {
                    var formulaText = '';
                    if (formula instanceof Array) {
                        angular.forEach(formula, function(value, index) {
                            if (value.type == 'formula') {
                                formulaText += " ( " + scope.createEquation(value.formula) + " ) ";
                            } else {
                                var text = '';
                                if (value.type == 'operator') {
                                    text = value.value;
                                } else if (value.type == 'parameter') {
                                    if (value.parameter.locationid) {
                                        text = scope.locations[value.parameter.locationid].name;
                                    }
                                    if (value.parameter.readingtypeid) {
                                        text += "_" + scope.readingtypes[value.parameter.readingtypeid].readingtypename;
                                    }
                                } else if (value.type == 'value') {
                                    text = value.value;
                                }
                                if (text) {
                                    formulaText += text + ' ';
                                }
                            }
                        });
                    }
                    return formulaText;
                }
                scope.$watch('parameter', function(newVal, oldVal) {
                    if (scope.isParent && newVal && newVal != oldVal) {
                        alphabet_counter = 0;
                        scope.parameter.formulaText = scope.createEquation(newVal.formula);
                        scope.parameter.parameters = {};
                        scope.parameter.formulaToParse = scope.makeEquation(newVal.formula, alphabet_counter);
                    }
                }, true);
            });
        }
    };
}]);
smartsenseApp.controller("widgetBuilderController", widgetBuilderController);

widgetBuilderController.$inject = ['$scope', '$state', 'loading', 'apiService', 'widgetBuilderService', 'local', '$stateParams', 'widgetTypes', 'widgets'];

function widgetBuilderController($scope, $state, loading, apiService, widgetBuilderService, local, $stateParams, widgetTypes, widgets) {

    /* Set local data to use in other components */
    $scope.localData = local.data;
    $scope.locations = angular.copy($scope.localData.locations);
    $scope.widgets = widgets.data;
    $scope.settings = {};
    $scope.widget = {};

    // Complex Parameter
    $scope.operandtypes = widgetBuilderService.operandtypes;
    $scope.operators = widgetBuilderService.operators;
    $scope.chartTypes = widgetBuilderService.chartTypes;

    $scope.types = {}
    angular.forEach(widgetTypes.data.types, function(k, v) {
        $scope.types[k.value] = k;
    });

    $scope.searchByValue = function(arrayOfObjects, key, value) {
        var obj = {};
        if (arrayOfObjects instanceof Array) {
            for (var i = 0; i < arrayOfObjects.length; i++) {
                if (typeof arrayOfObjects[i][key] != "undefined" && arrayOfObjects[i][key] == value) {
                    obj = arrayOfObjects[i];
                }
            }
        }
        return obj;
    }

    $scope.ordinal_suffix_of = function(i) {
        return utils.ordinal_suffix_of(i);
    }

    $scope.getWidget = function(widgetid) {
        apiService.widget_get(widgetid).then(function(response) {
            $scope.widget = response.data;
        }, function(error) {});
    }

    $scope.$watch('widget.type', function(newVal, oldVal) {
        if (newVal != oldVal && newVal) {
            $scope.settings = angular.copy(widgetBuilderService.getSettings(newVal));
            if (!$scope.widget.widgetid) {
                $scope.widget = angular.copy(widgetBuilderService.getObject(newVal));
            }
        }
    });

    $scope.changeType = function(value) {
        if (!$scope.widget.widgetid) {
            $scope.widget.type = value;
        }
        setTimeout(function() {
            $(window).scrollTop($('#widgetAddContainer').offset().top - 70);
        }, 100);
    }

    $scope.addParameter = function() {
        $scope.widget.config.parameters.push({
            alias: '',
            readingtypeid: null,
            locationid: null,
            sensortypeid: null
        });
    }

    $scope.addComplexParameter = function() {
        $scope.widget.config.computed_parameters.push({
            formula: [{
                type: 'parameter',
                parameter: {}
            }]
        });
    }

    $scope.saveWidget = function(widget) {
        apiService.widget_save(widget).then(function(response) {
            $state.go('home.widgetBuilder', {}, { reload: true });
        }, function(error) {});
    }

    $scope.deleteWidget = function(widget) {
        bootbox.confirm("Are you sure you want to delete widget?", function(result) {
            if (result) {
                apiService.widget_delete(widget).then(function(response) {
                    $state.go('home.widgetBuilder', {}, { reload: true });
                }, function(error) {});
            }
        });
    }

    $scope.clone = function(widget) {
        var widget = angular.copy(widget);
        bootbox.confirm("Are you sure you want to clone this widget?", function(result) {
            if (result) {
                delete widget.widgetid;
                delete widget.order;
                delete widget.createdat;
                delete widget.modifiedat;
                if ('dateRange' in widget.config) {
                    delete widget.config.dateRange;
                };
                widget.config.meta.name = widget.config.meta.name + ' - copy';
                loading(true);
                apiService.widget_save(widget)
                    .success(function(data) {
                        loading(false);
                        $state.go('home.widgetBuilder', {}, { reload: true });
                    })
                    .error(function(err) {
                        loading(false);
                    });
            }
        });
    }

    $scope.initWidgetForm = function() {
        if ($stateParams.widgetid) {
            $scope.widget = {
                widgetid: $stateParams.widgetid
            }
            $scope.getWidget($stateParams.widgetid);
        } else {
            $scope.widget = {};
            $scope.settings = {};
        }
    }

    // Pie Chart Widget
    $scope.updateParameter = function(key) {
        angular.forEach($scope.widget.config.parameters, function(value, key) {
            if (key) {
                $scope.widget.config.parameters[key].readingtypeid = $scope.widget.config.parameters[0].readingtypeid;
            }
        });
    }

    // Copy frequency to compare_frequency
    $scope.copyFrequency = function() {
        $scope.widget.config.dateRuleToCompare.freq = $scope.widget.config.dateRule.freq;
    }

    // Pie Chart Widget Ends 
    $scope.changeOrder = function(widget1, widget2) {
        var reordered_widgets = [{
            'widgetid': widget1.widgetid,
            'order': widget2.order,
        }, {
            'widgetid': widget2.widgetid,
            'order': widget1.order,
        }];
        loading(true);
        apiService.widget_changeorder(reordered_widgets)
            .success(function(data) {
                $scope.widgets = data;
            })
            .catch(function(error) {})
            .finally(function() {
                loading(false);
            });
    }

    $scope.removeParameter = function(parameters, parameterToRemove) {
        var index = parameters.indexOf(parameterToRemove);
        if (index > -1) {
            parameters.splice(index, 1);
        }
    }

    $scope.locationLatLong = function() {
        apiService.get_location_with_geo().then(function(response) {
            for (var i = response.data.length - 1; i >= 0; --i) {
                if (response.data[i].latitude == null || response.data.latitude == '') {
                    response.data.splice(i, 1);
                }
            }
            $scope.locationlist = response.data;
        });
    }

    $scope.locationLatLong();


    $scope.onTypeChange = function(type, ngModel) {
        if (type == 'parameter') {
            ngModel.parameter = {};
            delete ngModel.value;
            delete ngModel.formula;
        } else if (type == 'value') {
            ngModel.value = null;
            delete ngModel.parameter;
            delete ngModel.formula;
        } else if (type == 'formula') {
            ngModel.formula = [{
                type: 'parameter',
                parameter: {}
            }];
            delete ngModel.value;
            delete ngModel.parameter;
        }
    }

    $scope.addOperator = function(ngModel) {
        ngModel.push({
            type: 'operator',
            value: '+'
        });
        ngModel.push({
            type: 'parameter',
            parameter: {}
        });
    }

    $scope.removeOperator = function(parameters, parameter) {
        var index = parameters.indexOf(parameter);
        if (index > 1) {
            parameters.splice(index - 1, 2);
        }
    }

    $scope.createEquation = function(formula) {
        var formulaText = '';
        if (formula instanceof Array) {
            angular.forEach(formula, function(value, index) {
                if (value.type == 'formula') {
                    formulaText += " ( " + $scope.createEquation(value.formula) + " ) ";
                } else {
                    var text = '';
                    if (value.type == 'operator') {
                        text = value.value;
                    } else if (value.type == 'parameter') {
                        if (value.parameter.locationid) {
                            text = $scope.locations[value.parameter.locationid].name;
                        }
                        if (value.parameter.readingtypeid) {
                            text += "_" + $scope.localData.readingtypes[value.parameter.readingtypeid].readingtypename;
                        }
                    } else if (value.type == 'value') {
                        text = value.value;
                    }
                    if (text) {
                        formulaText += text + ' ';
                    }
                }
            });
        }
        return formulaText;
    }

    var alphabets = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
    var alphabet_prefix = "df.";
    var alphabet_counter = 0;
    $scope.makeEquation = function(formula, index) {
        var formulaText = '';
        if (formula instanceof Array) {
            angular.forEach(formula, function(value) {
                if (value.type == 'formula') {
                    formulaText += " ( " + $scope.makeEquation(value.formula, index) + " ) ";
                } else {
                    var text = '';
                    if (value.type == 'operator') {
                        text = value.value;
                    } else if (value.type == 'parameter') {
                        var alphabet = alphabet_prefix + alphabets[alphabet_counter];
                        $scope.widget.config.computed_parameters[index].parameters[alphabet] = value.parameter;
                        text = alphabet;
                        alphabet_counter++;
                    } else if (value.type == 'value') {
                        text = value.value;
                    }
                    if (text) {
                        formulaText += text + ' ';
                    }
                }
            });
        }
        return formulaText;
    }

    $scope.$watch('widget.config.computed_parameters', function(newVal, oldVal) {
        if (newVal && newVal != oldVal) {
            angular.forEach(newVal, function(parameter, index) {
                alphabet_counter = 0;
                $scope.widget.config.computed_parameters[index].formulaText = $scope.createEquation(parameter.formula);
                $scope.widget.config.computed_parameters[index].parameters = {};
                $scope.widget.config.computed_parameters[index].formulaToParse = $scope.makeEquation(parameter.formula, index);
            });
        }
    }, true);

    // Value Alias
    $scope.addValueAlias = function() {
        if (!($scope.widget.config.value_aliases instanceof Array)) {
            $scope.widget.config.value_aliases = [];
        }
        $scope.widget.config.value_aliases.push({
            value: null,
            alias: ''
        });
    }

    $scope.removeValueAlias = function(alias) {
        var index = $scope.widget.config.value_aliases.indexOf(alias);
        if (index > -1) {
            $scope.widget.config.value_aliases.splice(index, 1);
        }
    }

}
smartsenseApp.controller("widgetBuilderTableController", widgetBuilderTableController);

widgetBuilderTableController.$inject = ['$scope', '$state', 'apiService', 'widgetBuilderService', 'local'];

function widgetBuilderTableController($scope, $state, apiService, widgetBuilderService, local) {


    $scope.addParameter = function() {
        $scope.widget.config.cells.push({
            alias: '',
            is_computed: false,
            parameter: {
                readingtypeid: null,
                locationid: null,
                sensortypeid: null
            },
            computed_parameter: {
                formula: [{
                    type: 'parameter',
                    parameter: {}
                }],
                parameters: {}
            },
            col: null,
            row: null
        })
    };

    var getCellPosition = function(cell) {
        return cell.row.toSting() + cell.col.toString();
    }

    $scope.cellPositions = {};


    $scope.selectCell = function(cell, row, col) {
        var index = $scope.widget.config.cells.indexOf(cell);
        if (index > -1) {
            $scope.widget.config.cells[index].row = row;
            $scope.widget.config.cells[index].col = col;
        }
    }

    $scope.removeParameter = function(cell) {
        var index = $scope.widget.config.cells.indexOf(cell);
        if (index > -1) {
            $scope.widget.config.cells.splice(index, 1);
        }
    }

    $scope.addTableRow = function() {
        $scope.widget.config.rows = $scope.widget.config.rows || [];
        $scope.widget.config.rows.push({
            label: ''
        })
    };

    $scope.deleteTableRow = function(row) {
        var index = $scope.widget.config.rows.indexOf(row);
        if (index > -1) {
            $scope.widget.config.rows.splice(index, 1);
        }
    }

    $scope.addTableColumn = function() {
        $scope.widget.config.cols = $scope.widget.config.cols || [];
        $scope.widget.config.cols.push({
            label: ''
        })
    };

    $scope.deleteTableColumn = function(col) {
        var index = $scope.widget.config.cols.indexOf(col);
        console.log(index, col);
        if (index > -1) {
            $scope.widget.config.cols.splice(index, 1);
        }
    }

    $scope.mapCellPositions = function() {
        $scope.cellPositions = {};
        angular.forEach($scope.widget.config.cells, function(cell) {
            $scope.cellPositions[cell.row] = $scope.cellPositions[cell.row] || {};
            $scope.cellPositions[cell.row][cell.col] = cell;
        });
    }

    $scope.$watch('widget.config.cells', function(newVal, oldVal) {
        if (newVal) {
            $scope.mapCellPositions();
        }
    }, true);


}
smartsenseApp.controller("widgetBuilderTreeController", widgetBuilderTreeController);

widgetBuilderTreeController.$inject = ['$scope', '$state', 'apiService', 'widgetBuilderService', 'local'];

function widgetBuilderTreeController($scope, $state, apiService, widgetBuilderService, local) {

    $scope.sensors = $scope.localData.sensorlist;
    $scope.readingtypes = $scope.localData.readingtypeslist
    $scope.locations = $scope.localData.locations;
    $scope.tree = {};
    $scope.sensorlist = [];
    $scope.saveBtn = true;
    angular.forEach($scope.sensors, function(k, v) {
        $scope.sensorlist.push({
            name: k.name,
            sensorid: k.sensorid
        })
    })

    $scope.tagTransform = function(newTag) {
        var item = {
            name: newTag,
            sensorid: ''
        };
        return item;
    };

    $scope.disabled = undefined;

    $scope.treeConfig = {
        core: {
            multiple: false,
            animation: true,
            error: function(error) {
                $log.error('treeCtrl: error from js tree - ' + angular.toJson(error));
            },
            check_callback: true,
            worker: true
        },
        types: {
            default: {
                icon: 'fa fa-info-circle'
            }
        },
        version: 1,
        plugins: ['types', 'contextmenu', 'conditionalselect'],
        contextmenu: {
            items: function(node) {
                return {
                    "Rename": {
                        "separator_before": false,
                        "separator_after": false,
                        "label": "Edit",
                        "icon": "fa fa-pencil",
                        "action": function(obj) {
                            apiService.get_single_node(node.id).then(function(response) {
                                $scope.updateBtn = true;
                                $scope.saveBtn = false;
                                $scope.nodelist = {
                                    sensorname: [{
                                        name: response.data.name,
                                        sensorid: response.data.sensorid
                                    }],
                                    nodename: response.data.name,
                                    parent: response.data.parent,
                                    readingtypeid: response.data.readingtypeid,
                                    showalert: response.data.showalerts,
                                    id: response.data.id
                                };
                            })
                        }
                    },
                    "Remove": {
                        "separator_before": false,
                        "separator_after": false,
                        "label": "Remove",
                        "icon": "fa fa-trash",
                        "action": function(obj) {
                            var tree = $("#tree").jstree(true);
                            var id = tree._model.data[node.id].id;
                            apiService.delete_node(id).then(function(response) {
                                tree.delete_node(node);
                            })
                        }
                    }
                };
            }
        }
    };

    $scope.reCreateTree = function() {
        $scope.treeConfig.version++;
    }

    $scope.createTree = {
        treename: ''
    };

    $scope.createTree = function() {
        var params = {
            memberid: $scope.localData.memberId,
            name: $scope.createTree.treename
        }
        apiService.create_tree(params).then(function(response) {
            bootbox.alert("Tree has been Created.")
            $scope.getTreeList();
        }, function() {});
        $scope.createTree = {
            treename: '',
        };
    }

    $scope.getTreeList = function() {
        apiService.retrieve_tree().then(function(response) {
            $scope.treeList = response.data;
            if($scope.widget.config.tree.id != undefined) {
                $scope.getTreeNodes($scope.widget.config.tree.id)
            } else {
                $scope.widget.config.tree = $scope.treeList[0];
                $scope.getTreeNodes($scope.treeList[0].id);
            }
        }, function() {
        });
    }

    $scope.getTreeList();

    $scope.nodelist = {
        sensorname: [],
        nodename: '',
        parent: '',
        readingtypeid: '',
        showalert: ''
    };

    $scope.submitNode = function(treeid) {
        var params = {
            sensorid: $scope.nodelist.sensorname[0]['sensorid'],
            name: $scope.nodelist.sensorname[0]['name'],
            parent: $scope.nodelist.parent,
            readingtypeid: $scope.nodelist.readingtypeid,
            treeid: treeid,
            order: 3,
            showalerts: $scope.nodelist.showalert
        }
        apiService.create_node(params).then(function(response) {
            $scope.getTreeNodes(treeid);
            $scope.nodelist = {
                sensorname: [],
                nodename: '',
                parent: '',
                readingtypeid: '',
                showalert: ''
            };
        }, function() {});
    }

    $scope.getTreeNodes = function(treeid) {
        apiService.sensors().then(function(response) {
            $scope.sensorlist = response.data;
        })
        apiService.get_tree_nodes(treeid).then(function(response) {
            for (var i = 0; i < response.data.data.length; i++) {
                for (var x = 0; x < $scope.sensorlist.length; x++) {
                    if (response.data.data[i].sensorid == $scope.sensorlist[x].sensorid) {
                        $scope.sensorlist.splice(x, 1);
                    };
                };
            }
            $scope.originalData = response.data.data;
            $scope.parentData = []
            angular.forEach($scope.originalData, function(k, v) {
                $scope.parentData.push({
                    text: k.name,
                    id: k.id,
                })
            })
            for (var i = 0; i < $scope.originalData.length; i++) {
                $scope.originalData[i].text = $scope.originalData[i].name + ' : ' + $scope.originalData[i].readingtypeid.readingtypename;
                delete $scope.originalData[i].name;
                if ($scope.originalData[i].parent == null) {
                    $scope.originalData[i].parent = '#'
                }
                $scope.originalData[i].state = {
                    opened: true
                }
                $scope.originalData[i].li_attr = {
                    readingtypeid: $scope.originalData[i].readingtypeid
                }
            }
            $scope.treeData = [];
            angular.copy($scope.originalData, $scope.treeData);
            $scope.reCreateTree();
        }, function() {});
    }

    $scope.updateNode = function(treeid) {
        var params = {
            sensorid: $scope.nodelist.sensorname[0]['sensorid'],
            name: $scope.nodelist.sensorname[0]['name'],
            parent: $scope.nodelist.parent,
            readingtypeid: $scope.nodelist.readingtypeid,
            treeid: treeid,
            order: 3,
            showalerts: $scope.nodelist.showalert,
            id: $scope.nodelist.id
        }
        apiService.edit_node(params).then(function(response) {
            $scope.getTreeNodes(treeid)
            $scope.updateBtn = false;
            $scope.saveBtn = true;
            $scope.nodelist = {
                sensorname: [],
                nodename: '',
                parent: '',
                readingtypeid: '',
                showalert: ''
            };
        })
    }

    $scope.ignoreChanges = false;

    $scope.applyModelChanges = function() {
        return !$scope.ignoreChanges;
    };

}
smartsenseApp.controller("widgetBuilderImageController", widgetBuilderImageController);

widgetBuilderImageController.$inject = ['$scope', '$state', 'apiService', 'widgetBuilderService', 'local', 'loading'];

function widgetBuilderImageController($scope, $state, apiService, widgetBuilderService, local, loading) {

    $scope.addParameter = function() {
        $scope.widget.config.parameters.push({
            alias: '',
            readingtypeid: null,
            locationid: null,
            sensortypeid: null,
            style: {
                fontsize:'',
                bordercolor: '',
                bgcolor:'',
                fontcolor:'',
                fontweight: ''
            },
            position: {
                X:'',
                Y:''
            }
        });
    }

    $scope.addComplexParameter = function() {
        $scope.widget.config.computed_parameters.push({
            formula: [{
                type: 'parameter',
                parameter: {}
            }],
            style: {
                fontsize:'',
                bordercolor: '',
                bgcolor:'',
                fontcolor:'',
                fontweight: ''
            },
            position: {
                X:'',
                Y:''
            }
        });
    }

    $scope.removeParameter = function(parameters, parameterToRemove) {
        var index = parameters.indexOf(parameterToRemove);
        if (index > -1) {
            parameters.splice(index, 1);
        }
    }

    $scope.uploadFile = function(file){
        loading(true)
        $scope.widget.config.image_id = '';
        if (file) {
            var myFormData = new FormData();
            myFormData.append('file', file);
            apiService.media_handler(myFormData).then(function(response) {
                $scope.widget.config.url = response.data.url;
                $scope.url = $scope.widget.config.url;
                loading(false)
            })
        }
    };

    $scope.url = $scope.widget.config.url;

}
smartsenseApp.controller("widgetBuilderDialController", widgetBuilderDialController);

widgetBuilderDialController.$inject = ['$scope', '$state', 'apiService', 'widgetBuilderService', 'local'];

function widgetBuilderDialController($scope, $state, apiService, widgetBuilderService, local) {

    $scope.addSolidThreshold = function() {
        $scope.widget.config.solid_thresholds = $scope.widget.config.solid_thresholds || [];
        $scope.widget.config.solid_thresholds.push({
            label: '',
            value: ''
        })
    };

    $scope.addSpeedometerThreshold = function() {
        $scope.widget.config.speedometer_thresholds = $scope.widget.config.speedometer_thresholds || [];
        $scope.widget.config.speedometer_thresholds.push({
            from: '',
            to: '',
            color: ''
        })
    };

    $scope.deleteThreshold = function(thresholds, thresholdToRemove) {
        var index = thresholds.indexOf(thresholdToRemove);
        if (index > -1) {
            thresholds.splice(index, 1);
        }
    }

}
smartsenseApp.controller("widgetBuilderHTMLController", widgetBuilderHTMLController);


widgetBuilderHTMLController.$inject = ['$scope', '$state', 'apiService', 'widgetBuilderService', 'local', 'loading'];

function widgetBuilderHTMLController($scope, $state, apiService, widgetBuilderService, local, loading) {

    // angular-summernote toolbar options 
    $scope.options = {
        height: 150,
        toolbar: [
            ['style', ['style']],
            ['font', ['bold', 'italic', 'underline', 'clear']],
            ['fontname', ['fontname']],
            ['color', ['color']],
            ['para', ['ul', 'ol', 'paragraph']],
            ['height', ['height']],
            ['table', ['table']],
            ['insert', ['link', 'picture', 'hr']],
            ['view', ['fullscreen', 'codeview']],
            ['help', ['help']]
        ]
    };

    // overwriting the onImageUpload functionality to store image on the server first
    $scope.imageUpload = function(files) {
        loading(true);

        if (files[0]) {
            var myFormData = new FormData();
            myFormData.append('file', files[0]);
            apiService.media_handler(myFormData).success(function(data) {
                    $scope.getImage(data);
                })
                .error(function() {})
                .finally(function() {
                    loading(false);
                })
        }
    }

    // get image URL by passing the media_handler_id 
    $scope.getImage = function(id) {
        loading(true);

        var params = {
            media_handler_id: id
        }
        apiService.media_handler_img(params).success(function(data) {
                $scope.url = data;
                // adding image inside the editor
                $('.summernote').summernote('editor.insertImage', $scope.url);
            })
            .error(function() {})
            .finally(function() {
                loading(false);
            })
    }

}
smartsenseApp.factory('widgetBuilderService', widgetBuilderService);

widgetBuilderService.$inject = [];

function widgetBuilderService() {

    var sizes = {
        'full' :{
            'label':'Large - Full Width',
            'value':'col-lg-12 col-md-12 col-sm-12 col-xs-12'
        },
        'half' :{
            'label':'Medium - Half Width',
            'value':'col-lg-6 col-md-6 col-sm-12 col-xs-12'
        },
        'medium' : {
            'label':'Medium - 1/3th Width',
            'value':'col-lg-4 col-md-4 col-sm-12 col-xs-12'
        },
        'small' :{
            'label':'Small - 1/4th Width',
            'value':'col-lg-3 col-md-3 col-sm-4 col-xs-12'
        },
        'xsmall': {
            'label':'Extra Small - 1/6th Width',
            'value':'col-lg-2 col-md-3 col-sm-4 col-xs-12'
        }
    }

    var sensortypeids = [
    {id: null, label: "All"},
    {id: "1001", label: "Consumption"},
    {id: "1002,1003", label: "Generation"},
    {id: "1004", label: "Appliance Only"}
    ];

    var grains = [{
        label: "1 mins",
        value:1
    },{
        label: "15 mins",
        value:15
    }, {
        label: "30 mins",
        value:30
    }, {
        label: "1 hour",
        value:60
    }, {
        label: "1 day",
        value:1440
    }];

    var frequencies = [{
        id: 'DAILY', label: 'Day', unit:'Day'
    },{
        id: 'WEEKLY', label: 'Week', unit:'Week'
    },{
        id: 'MONTHLY', label: 'Month', unit:'Month'
    }];

    var currencies = [{
        label: "Indian Rupees",
        symbol:"â¹"
    },{
        label: "United Arab Emirates Dirham",
        symbol:"AED"
    }];

    var meta = {
        name:'',
        description:'',
        refreshtime:5
    }

    var operandtypes = [{
        label:'Parameter',
        value:'parameter'
    },{
        label:'Constant Value',
        value:'value'
    },{
        label:'Formula',
        value:'formula'
    }];

    var operators = [{
        label:'Add',
        value:'+',
        type:'Mathematical'
    },{
        label:'Substract',
        value:'-',
        type:'Mathematical'
    },{
        label:'Multiply',
        value:'*',
        type:'Mathematical'
    },{
        label:'Power',
        value:'**',
        type:'Mathematical'
    },{
        label:'Divide',
        value:'/',
        type:'Mathematical'
    },{
        label:'And',
        value:'and',
        type:'Logical'
    },{
        label:'Or',
        value:'or',
        type:'Logical'
    },{
        label:'>',
        value:'>',
        type:'Logical'
    },{
        label:'<',
        value:'<',
        type:'Logical'
    },{
        label:'==',
        value:'==',
        type:'Logical'
    },{
        label:'!=',
        value:'!=',
        type:'Logical'
    }];

    var chartTypes = [{
        label:'Bar Graph',
        value:'column'
    },{
        label:'Line Graph',
        value:'line'
    },{
        label:'Area Graph',
        value:'area'
    }];

    var assetTypes = [{
        label:'Motor Insight',
        value:'motor'
    },{
        label:'Transformer Insight',
        value:'transformer'
    },{
        label:'Chiller Insight',
        value:'chiller'
    }];

    var dialTypes = [{
        label:'Solid Gauge',
        value:'solidgauge'
    }, {
        label:'Speedometer',
        value:'gauge'
    }];

    var fontweights = [{
        label:'100',
        value:'100'
    }, {
        label:'200',
        value:'200'
    }, {
        label:'300',
        value:'300'
    }, {
        label:'400',
        value:'400'
    }, {
        label:'500',
        value:'500'
    }, {
        label:'600',
        value:'600'
    }, {
        label:'700',
        value:'700'
    }, {
        label:'800',
        value:'800'
    }, {
        label:'900',
        value:'900'
    }];

    var default_readingtypeid = 2001;
    var default_load_readingtypeid = 2002;

    var service = {
        operandtypes:operandtypes,
        operators:operators,
        chartTypes:chartTypes,
        // Initialization
        getObject:getObject,
        getSettings:getSettings,
    };

    return service;

    ////////////

    function Table() {
        this.config = {
            cells:[{
                alias:'',
                is_computed:false,
                parameter:{
                    readingtypeid:null,
                    locationid:null,
                    sensortypeid:null
                },
                computed_parameter:{
                    formula:[{
                        type:'parameter',
                        parameter:{}
                    }],
                    parameters:{}
                },
                col:null,
                row:null
            }],
            rows:[{
                label:'Raw 1'
            }],
            cols:[{
                label:'Column 1'
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:meta,
            type:'table',
            order:0,
            class:sizes['full'].value
        };
        this.order=0;
        this.status='draft';
        this.type='table';
    }

    function TableSettings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = frequencies;
        this.grains = grains;
        this.parameterLimit = 20;
        this.sizes = sizes;
    }

    function Digit() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:null,
                locationid:null,
                sensortypeid:null
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:meta,
            type:'digit',
            order:0,
            class:sizes['small'].value
        };
        this.order=0;
        this.status='draft';
        this.type='digit';
    }


    function DigitSettings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = frequencies;
        this.sizes = [sizes['small'],sizes['xsmall']];
        this.parameterLimit = 3;
    }


    function Digit2() {
        this.config = {
            parameters:{
                'value':{
                    alias:'',
                    readingtypeid:default_readingtypeid,
                    locationid:null,
                    sensortypeid:null
                },
                'live':{
                    alias:'',
                    readingtypeid:default_load_readingtypeid,
                    locationid:null,
                    sensortypeid:null
                },
                'trend':{
                    alias:'',
                    readingtypeid:default_readingtypeid,
                    locationid:null,
                    sensortypeid:null
                }
            },
            cost:{
                enabled:false,
                currency:currencies[0].value,
                unitrate:null
            },
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:meta,
            type:'digit2',
            order:0,
            class:sizes['small'].value
        };
        this.order=0;
        this.status='draft';
        this.type='digit2';
    }


    function Digit2Settings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = frequencies;
        this.currencies = currencies;
        this.sizes = [sizes['small'],sizes['xsmall']];
        this.parameterLimit = 1;
    }

    function Digit3() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:default_load_readingtypeid,
                locationid:null,
                sensortypeid:null
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:{name:'Demand',description:'Shows demand aggregated over 15 min fixed window'},
            type:'digit3',
            order:0,
            class:sizes['small'].value
        };
        this.order=0;
        this.status='draft';
        this.type='digit3';
    }


    function Digit3Settings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = frequencies;
        this.sizes = [sizes['small'],sizes['xsmall']];
        this.parameterLimit = 1;
    }


    function Health() {
        this.config = {
            meta:{
                name:'Sensor Health',
                description:'Shows node Health. A node is termed as Inactive only if it fails to communicate with the SmartSense server for last 6 Hrs.'
            },
            type:'health',
            order:0,
            class:sizes['small'].value
        };
        this.order=0;
        this.status='draft';
        this.type='health';
    }


    function HealthSettings() {
        this.sizes = [sizes['small'],sizes['xsmall']];
    }


    function Trend() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:null,
                locationid:null,
                sensortypeid:"1001"
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            dateRuleToCompare:{
                freq:null,
                reference:null,
                start:3,
                end:1
            },
            meta:meta,
            tocompare:3,
            class:sizes['full'].value
        };
        this.status='draft';
        this.type='trend';
    }

    function TrendSettings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = angular.copy(frequencies).splice(2,2);
        this.grains = [{
            label: "1 Day",
            value:1440
        }];
        this.parameterLimit = 1;
        this.sizes = [sizes['full']];
    }


    function Graph() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:null,
                locationid:null,
                sensortypeid:"1001"
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:meta,
            class:sizes['full'].value,
            is_computed:true,
            computed_parameters:[{
                formula:[{
                    type:'parameter',
                    parameter:{}
                }],
                parameters:{}
            }]
        };
        this.status='draft';
        this.type='graph';
    }

    function GraphSettings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = frequencies;
        this.grains = grains;
        this.parameterLimit = 8;
        this.sizes = [sizes['full'],sizes['half']];
    }

    function Heatmap() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:null,
                locationid:null,
                sensortypeid:null
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:meta,
            class:sizes['full'].value,
            heatmap:{
                min:null,
                max:null
            }
        };
        this.status='draft';
        this.type='heatmap';

    }

    function HeatmapSettings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = frequencies;
        this.grains = grains.splice(1,1);
        this.parameterLimit = 1;
        this.sizes = [sizes['full']];
    }

    function Pie() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:null,
                locationid:null,
                sensortypeid:null
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:meta,
            class:sizes['small'].value
        };
        this.status='draft';
        this.type='pie';

    }

    function PieSettings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = frequencies;
        this.parameterLimit = 8;
        this.sizes = [sizes['small'],sizes['xsmall'],sizes['half']];
    }

    function LiveTable() {
        this.config = {
            parameters:[],
            sensors:[],
            is_all_sensors:false,
            meta:{
                name:'Live Data',
                description:'Shows most recently recorded values of the parameters for the respective locations.',
                refreshtime:1
            },
            class:sizes['full'].value
        };
        this.status='draft';
        this.type='livetable';

    }

    function LiveTableSettings() {
        this.parameterLimit = 10;
        this.sensorLimit = 100;
        this.sizes = [sizes['half'],sizes['full']];
    }

    function LiveTable2() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:null,
                locationid:null,
                sensortypeid:null
            }],
            meta:{
                name:'Live Data',
                description:'Shows most recently recorded values of the parameters for the respective locations.',
                refreshtime:1
            },
            value_aliases:[],
            class:sizes['half'].value
        };
        this.status='draft';
        this.type='livetable2';

    }

    function LiveTable2Settings() {
        this.parameterLimit = 8;
        this.sizes = [sizes['half'],sizes['full']];
    }

    function LiveTable3() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:null,
                locationid:null,
                sensortypeid:null
            }],
            meta:{
                name:'Live Data',
                description:'It has different styling from other data tables.Shows most recently recorded values of the parameters for the respective sensors/locations.',
                refreshtime:1
            },
            value_aliases:[],
            class:sizes['medium'].value
        };
        this.status='draft';
        this.type='livetable3';

    }

    function LiveTable3Settings() {
        this.parameterLimit = 8;
        this.sizes = [sizes['medium'],sizes['half'],sizes['full']];
    }

    function Overview() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:default_readingtypeid,
                locationid:null,
                sensortypeid:null
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            grain:1,
            meta:{
                name:'Overview',
                description:'Overview of location with option to select multi parameters.',
                refreshtime:5
            },
            class:sizes['full'].value
        };
        this.status='draft';
        this.type='overview';
    }

    function OverviewSettings() {
        this.frequencies = frequencies;
        this.grains = grains;
        this.sensortypeids = sensortypeids;
        this.parameterLimit = 1;
        this.sizes = [sizes['full']];
    }

    function SLD() {
        this.config = {
            parameters:[{
                readingtypeid:default_readingtypeid,
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:{
                name:'SLD',
                description:'Shows SLD of the sensors as defined in Pre-Installation sheet. User may configure the Asset info in âsettingsâ.'
            },
            class:sizes['full'].value
        };
        this.status='draft';
        this.type='sld';
    }

    function SLDSettings() {
        this.frequencies = frequencies;
        this.parameterLimit = 1;
        this.sizes = [sizes['full']];
    }

    function Insight() {
        this.config = {
            meta:{
                name:'Insight',
                description:'Shows insight of Assets.'
            },
            assets:{
                type:'motor',
                total:null,
                critical:null,
                potential:null
            },
            class:sizes['small'].value
        };
        this.status='draft';
        this.type='insight';
    }

    function InsightSettings() {
        this.assetTypes = assetTypes;
        this.sizes = [sizes['small'],sizes['xsmall']];
    }

    function Onoff() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:null,
                locationid:null,
                sensortypeid:null
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:{
                name:'On/Off Status',
                description:'Shows On/Off status on parameter value or based on the condition.',
                refreshtime:5
            },
            class:sizes['full'].value,
            is_computed:true,
            computed_parameters:[{
                formula:[{
                    type:'parameter',
                    parameter:{}
                }],
                parameters:{}
            }],
            grain:15
        };
        this.status='draft';
        this.type='onoff';
    }

    function OnoffSettings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = frequencies;
        this.grains = grains;
        this.parameterLimit = 8;
        this.sizes = [sizes['full'],sizes['half']];
    }

    function OnoffDigit() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:null,
                locationid:null,
                sensortypeid:null
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:{
                name:'On/Off Status',
                description:'Shows Live On/Off status with running time.',
                refreshtime:5
            },
            class:sizes['small'].value,
            is_computed:true,
            computed_parameters:[{
                formula:[{
                    type:'parameter',
                    parameter:{}
                }],
                parameters:{}
            }],
            grain:15
        };
        this.status='draft';
        this.type='onoffdigit';
    }

    function OnoffDigitSettings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = frequencies;
        this.grains = grains;
        this.parameterLimit = 1;
        this.sizes = [sizes['small'],sizes['xsmall']];
    }

    function OEE() {
        this.config = {
            parameters:[{
                locationid:null
            }],
            dateRule:{
                freq:'WEEKLY',
                reference:null,
                start:0,
                end:0
            },
            grain:1440,
            meta:{
                name:'Overall Equipment Effectiveness',
                description:'Shows Overall Equipment Effectiveness with Metrics and Time Distribution.',
                refreshtime:5
            },
            class:sizes['full'].value
        };
        this.status='draft';
        this.type='oee';
    }

    function OEESettings() {
        this.frequencies = frequencies;
        this.grains = grains;
        this.parameterLimit = 1;
        this.sizes = [sizes['full']];
    }

    function Cycle() {
        this.config = {
            parameters:[{
                locationid:null,
                readingtypeid:null,
                sensorid:null
            }],
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            time:{
                start:'00:00',
                end:'00:00'
            },
            grain:1,
            meta:{
                name:'Cycle Distribution',
                description:'Cycle Distribution.',
                refreshtime:5
            },
            class:sizes['full'].value
        };
        this.status='draft';
        this.type='cycle';
    }

    function CycleSettings() {
        this.frequencies = frequencies;
        this.sensortypeids = sensortypeids;
        this.grains = grains;
        this.parameterLimit = 1;
        this.sizes = [sizes['full']];
    }

    function Skyview() {
        this.config = {
            parameters:[],
            location:[],
            grain:15,
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            summaryName: '',
            meta:{
                name:'Skyview',
                description:'Skyview.',
                refreshtime:5
            },
            class:sizes['full'].value
        };
        this.status='draft';
        this.type='skyview';
    }

    function SkyviewSettings() {
        this.frequencies = frequencies;
        this.grains = grains;
        this.parameterLimit = 9;
        this.sizes = [sizes['full']];
    }

    function Gifimage() {
        this.config = {
            parameters:[{
                alias:'',
                readingtypeid:null,
                locationid:null,
                sensortypeid:null
            }],
            grain:15,
            order:0,
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:{
                name:'Gif Image',
                description:'Gif Image.',
                refreshtime:5
            },
            class:sizes['full'].value
        };
        this.status='draft';
        this.type='gifimage';
        this.order=0;
    }

    function GifimageSettings() {
        this.frequencies = frequencies;
        this.grains = grains;
        this.parameterLimit = 8;
        this.sizes = [sizes['full']];
    }

    function TreeBuilder() {
        this.config = {
            tree: {},
            grain:15,
            order:0,
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta:{
                name:'Tree Builder',
                description:'Tree Builder.',
                refreshtime:5
            },
            class:sizes['full'].value
        };
        this.status='draft';
        this.type='treebuilder';
        this.order=0;
    }

    function TreeBuilderSettings() {
        this.frequencies = frequencies;
        this.grains = grains;
        this.parameterLimit = 8;
        this.sizes = [sizes['full']];
    }

    function Dial() {
        this.config = {
            dateRule:{
                freq:'DAILY',
                reference:null,
                start:0,
                end:0
            },
            meta: {
                name:'Dial',
                description:'Dial Graph shows value of single location.',
                refreshtime:5
            },
            type:'dial',
            order:0,
            lower: '',
            upper: '',
            grain: 15,
            dial_type: 'solidgauge',
            solid_thresholds:[{
                label: 'Threshold',
                value: ''
            }],
            speedometer_thresholds:[{
                from: '',
                to: '',
                color: '',
            }],
            is_aggregated : false,
            class:sizes['small'].value,
            computed_parameters:[{
                formula:[{
                    type:'parameter',
                    parameter:{}
                }],
                parameters:{}
            }]
        };
        this.status='draft';
        this.type='dial';
        this.order=0;
    }

    function DialSettings() {
        this.frequencies = frequencies;
        this.grains = grains;
        this.parameterLimit = 8;
        this.thresholdLimit = 10;
        this.dialTypes = dialTypes;
        this.sizes = [sizes['small'],sizes['xsmall']];
    }

    function ImageUpload() { 
        this.config = { 
            dateRule:{ 
                freq:'DAILY', 
                reference:null, 
                start:0, 
                end:0 
            }, 
            computed_parameters:[{ 
                formula:[{ 
                    type:'parameter', 
                    parameter:{} 
                }], 
                parameters:{},
                threshold: '',
                threshold_color: '',
                style: { 
                    fontsize:'',
                    bordercolor: '',
                    bgcolor:'',
                    fontcolor:'',
                    fontweight: ''
                }, 
                position: { 
                    X:'', 
                    Y:'' 
                }
            }], 
            parameters:[{ 
                alias:'', 
                readingtypeid:null, 
                locationid:null, 
                sensortypeid:null,
                threshold: '',
                threshold_color: '',
                style: { 
                    fontsize:'', 
                    bordercolor: '', 
                    bgcolor:'', 
                    fontcolor:'',
                    fontweight: ''
                }, 
                position: { 
                    X:'', 
                    Y:'' 
                }
            }], 
            meta: { 
                name:'Image Upload', 
                description:'Shows Image with live parameters on it.', 
                refreshtime:5 
            }, 
            url: null,
            is_aggregated: false, 
            is_computed:false, 
            type:'imageupload', 
            order:0, 
            grain: 15, 
            class:sizes['full'].value 
        }; 
        this.status='draft'; 
        this.type='imageupload'; 
        this.order=0; 
 
    } 
 
    function ImageUploadSettings() { 
        this.sensortypeids = sensortypeids; 
        this.frequencies = frequencies; 
        this.grains = grains; 
        this.parameterLimit = 8; 
        this.sizes = [sizes['full']]; 
        this.fontweights = fontweights;
    }
    
    function HTML() {
        this.config = {
            meta: {
                name: 'HTML',
                description: '',
                refreshtime: 1
            },
            class: sizes['full'].value
        };
        this.status = 'draft';
        this.type = 'html';
    }


    function HTMLSettings() {
        this.sensortypeids = sensortypeids;
        this.frequencies = frequencies;
        this.sizes = [sizes['full'], sizes['small'], sizes['xsmall']];
        this.parameterLimit = 1;
    }


    function getObject(type) {
        if(type=='table') {
            return new Table();
        } else if(type=='digit') {
            return new Digit();
        } else if(type=='digit2') {
            return new Digit2();
        } else if(type=='digit3') {
            return new Digit3();
        } else if(type=='health') {
            return new Health();
        } else if(type=='trend') {
            return new Trend();
        } else if(type=='graph') {
            return new Graph();
        } else if(type=='heatmap') {
            return new Heatmap();
        } else if(type=='pie') {
            return new Pie();
        } else if(type=='livetable') {
            return new LiveTable();
        } else if(type=='livetable2') {
            return new LiveTable2();
        } else if(type=='livetable3') {
            return new LiveTable3();
        } else if(type=='overview') {
            return new Overview();
        } else if(type=='sld') {
            return new SLD();
        } else if(type=='insight') {
            return new Insight();
        } else if(type=='onoff') {
            return new Onoff();
        } else if(type=='onoffdigit') {
            return new OnoffDigit();
        } else if(type=='oee') {
            return new OEE();
        } else if(type=='cycle') {
            return new Cycle();
        } else if(type=='skyview') {
            return new Skyview();
        } else if(type=='gifimage') {
            return new Gifimage();
        } else if(type=='treebuilder') {
            return new TreeBuilder();
        } else if(type=='dial') {
            return new Dial();
        } else if(type=='imageupload') {
            return new ImageUpload();
        } else if (type == 'html') {
            return new HTML();
        }
    }

    function getSettings(type) {
        if(type=='table') {
            return new TableSettings();
        } else if(type=='digit') {
            return new DigitSettings();
        } else if(type=='digit2') {
            return new Digit2Settings();
        } else if(type=='digit3') {
            return new Digit3Settings();
        } else if(type=='health') {
            return new HealthSettings();
        } else if(type=='trend') {
            return new TrendSettings();
        } else if(type=='graph') {
            return new GraphSettings();
        } else if(type=='heatmap') {
            return new HeatmapSettings();
        } else if(type=='pie') {
            return new PieSettings();
        } else if(type=='livetable') {
            return new LiveTableSettings();
        } else if(type=='livetable2') {
            return new LiveTable2Settings();
        } else if(type=='livetable3') {
            return new LiveTable3Settings();
        } else if(type=='overview') {
            return new OverviewSettings();
        } else if(type=='sld') {
            return new SLDSettings();
        } else if(type=='insight') {
            return new InsightSettings();
        } else if(type=='onoff') {
            return new OnoffSettings();
        } else if(type=='onoffdigit') {
            return new OnoffDigitSettings();
        } else if(type=='oee') {
            return new OEESettings();
        } else if(type=='cycle') {
            return new CycleSettings();
        } else if(type=='skyview') {
            return new SkyviewSettings();
        } else if(type=='gifimage') {
            return new GifimageSettings();
        } else if(type=='treebuilder') {
            return new TreeBuilderSettings();
        } else if(type=='dial') {
            return new DialSettings();
        } else if(type=='imageupload') {
            return new ImageUploadSettings();
        } else if (type == 'html') {
            return new HTMLSettings();
        }

    }



}

smartsenseApp.controller("DMRCDashboardController", ['$scope', '$stateParams', '$interval', '$timeout', 'data', 'local', '$rootScope', 'loading', '$state', 'growl', 'Analytics', 'apiService',
    function($scope, $stateParams, $interval, $timeout, data, local, $rootScope, loading, $state, growl, Analytics, apiService) {

        $scope.localData = local.data;
        $scope.localData.dmrc = {};
        $scope.localData.dmrc.dateRange = {
            startDate: moment().startOf('day'),
            endDate: moment()
        }

        $scope.dateRangeOpts = {
            locale: {
                applyClass: 'btn-primary',
                applyLabel: "Apply",
                fromLabel: "From",
                format: 'DD/MM/YYYY',
                toLabel: "To",
                cancelLabel: 'Cancel',
            },
            opens: "up",
            autoApply: true,
            maxDate: moment(),
            eventHandlers: {
                'apply.daterangepicker': function(ev, picker) {
                    $scope.fetchLiftStatus();
                }
            }
        };

        $scope.widgetlist = [];
        $scope.localData.dmrcLiftData = undefined;

        $scope.$watch('localData.locateErrorsFilter', function(newVal) {
            if (typeof newVal != "undefined") {
                $scope.localData.dmrc.dateRange.startDate = moment($scope.localData.dashboardDateRange.startDate).format("YYYY-MM-DD");
                $scope.localData.dmrc.dateRange.endDate = moment($scope.localData.dashboardDateRange.endDate).format("YYYY-MM-DD");
                $scope.fetchLiftStatus();
            }
        });

        /*DMRC Lift widgets list and order*/
        $scope.widgetlist = [];

        $scope.widgetlist.push({
            type: "summary",
            size: "small",
            title: "Summary Status",
            widgetPath: "dmrc",
            prefix: "dmrcWidget",
            class: "col-lg-3 col-md-3 col-sm-4 col-xs-12"
        }, {
            type: "summaryOTIS",
            size: "small",
            title: "Summary Status-OTIS",
            widgetPath: "dmrc",
            prefix: "dmrcWidget",
            class: "col-lg-3 col-md-3 col-sm-4 col-xs-12"
        }, {
            type: "summaryJohnson",
            size: "small",
            title: "Summary Status-Johnson",
            widgetPath: "dmrc",
            prefix: "dmrcWidget",
            class: "col-lg-3 col-md-3 col-sm-4 col-xs-12"
        }, {
            type: "summaryKone",
            size: "small",
            title: "Summary Status-Kone",
            widgetPath: "dmrc",
            prefix: "dmrcWidget",
            class: "col-lg-3 col-md-3 col-sm-4 col-xs-12"
        }, {
            type: "reportedErrorsDonut",
            size: "small",
            title: "OEM-Wise No. of errors reported",
            widgetPath: "dmrc",
            prefix: "dmrcWidget",
            class: "col-lg-3 col-md-3 col-sm-4 col-xs-12"
        }, {
            type: "errorCategoriesBar",
            size: "small",
            title: "OEM-Wise error categories",
            widgetPath: "dmrc",
            prefix: "dmrcWidget",
            class: "col-lg-9 col-md-9"
        }, {
            type: "errorReport",
            size: "small",
            title: "Error Reporting Table",
            widgetPath: "dmrc",
            prefix: "dmrcWidget",
            class: "col-lg-12"
        });
        /*End : DMRC Lift widgets list and order*/

        /*DMRC GIS Widget */
        $scope.widgetlistGIS = {
            type: "skyview",
            size: "full",
            title: "Maps",
            widgetPath: "dmrc",
            prefix: "dmrcWidget",
            class: ''
        };
        $scope.widgetlistGIS.class = utils.bootstrapClass($scope.widgetlistGIS.size);

        $scope.widgetlistTree = {
            type: "sld",
            size: "full",
            title: "SLD",
            widgetPath: "dmrc",
            prefix: "dmrcWidget",
            parameter: {
                readingtypeid: 2846
            },
            class: ''
        };
        $scope.widgetlistTree.class = utils.bootstrapClass($scope.widgetlistTree.size);

        /*Data operations*/
        $scope.fetchLiftStatus = function() {
            $scope.refreshInProgress = true;
            loading(true);
            var startDate = moment($scope.localData.dmrc.dateRange.startDate).format("YYYY-MM-DD");
            var endDate = moment($scope.localData.dmrc.dateRange.endDate).format("YYYY-MM-DD");
            $scope.localData.dmrcDateRange = {
                start: startDate,
                end: endDate
            };
            apiService.getLiftDeftails(startDate, endDate)
            .success(function(data){
                $scope.localData.dmrcLiftData = data;
                $scope.$broadcast('dmrcLiftDataLoaded', data);
            })
            .error(function(err){
                 $scope.serverNotRecheable = true;
            })
            .finally(function(){
                loading(false);
                $scope.refreshInProgress = false;
            })
        }

        $scope.fetchLiftStatus();

        $scope.showDashboard = function() {
            $scope.$broadcast('dmrcShowDashboard');
        }

    }
]);
smartsenseApp.controller('DMRCAlertController', DMRCAlertController);

DMRCAlertController.$inject = ['$scope', '$filter', '$q', '$state', '$stateParams', 'apiService' ,'dmrcAlertService', 'sensors', 'loading', '$state', 'Analytics'];

function DMRCAlertController($scope, $filter, $q, $state, $stateParams, apiService, dmrcAlertService, sensors, loading, $state, Analytics) {

    $scope.daysOption = dmrcAlertService.daysOption;
    $scope.durationOption = dmrcAlertService.durationOption;
    $scope.repeatOption = dmrcAlertService.repeatOption;

    $scope.allowedMobiles = dmrcAlertService.allowedMobiles;
    $scope.allowedEmails = dmrcAlertService.allowedEmails;

    $scope.getOccurent = function(string) {
        if (!string || typeof string == 'undefined' || string == '') {
            return -1;
        }
        return string.split(',').length;
    }

    $scope.getCommaSeparated = function(str) {
        if(!str)
            return [];
        return str.split(',');
    }

    /* Variable declaration and method initialization */

    /* Raw sensor and readingtype list */
    $scope.sensors = sensors.data;
    $scope.readingTypeList = [];

    /* In simple alert, default standard readingtype list */
    $scope.readingTypeDefaultList = [];

    $scope.sensorReadingTypes = {};

    /* In simple alert, $scope.singleSensorReadingTypeList will contain readingtype list based on current selected sensor ( on sensor value change, readingtype list will change ) */
    $scope.singleSensorReadingTypeList = [];


    /* In simple alert this variable will keep track of which condition is currently selected, standard or custom */
    $scope.defaultReadingTypeListLength = 0;

    /* In complex alert, maximum number of condition and maximum number of sensor / condition value */
    $scope.allowedSensors = dmrcAlertService.allowedSensors;
    $scope.allowedConditions = dmrcAlertService.allowedConditions;

    /* In complex alert, this variable will contain readingtype list based on current selected sensors in particular condition */
    $scope.multipleSensorReadingTypeList = {};

    $scope.allowedHours = dmrcAlertService.getHours();
    $scope.allowedMinutes = dmrcAlertService.getMinutes();

    // Filter to get object using Id

    $scope.getAlertFromId = function(alertid) {
        return $filter('filter')($scope.alerts, function(alert) {
            return alert.alertid === alertid;
        })[0];
    };

    $scope.getEventFromId = function(eventid) {
        return $filter('filter')($scope.events, function(event) {
            return event.eventid === eventid;
        })[0];
    };

    $scope.getSensorNameFromId = function(sensorid) {
        return $filter('filter')($scope.sensors, function(sensor) {
            return sensor.sensorid === sensorid;
        })[0];
    };

    $scope.getReadingTypeFromId = function(readingtypeid) {
        return $filter('filter')($scope.readingTypeList, function(readingType) {
            return readingType.readingtypeid === readingtypeid;
        })[0];
    };

    /* Set default readingtype list for simple alert */
    $scope.initReadingTypeDefaultList = function() {

        var MDBreach = {
            readingtypeid: 2002,
            readingtypename: 'M.D. Breach (kW)',
            options: [{
                label: '>',
                value: 1
            }]
        };

        var PFPenalty = {
            readingtypeid: 2006,
            readingtypename: 'P.F. Penalty',
            options: [{
                label: '<',
                value: 2
            }]
        };

        $scope.readingTypeDefaultList = [MDBreach, PFPenalty];
        $scope.defaultReadingTypeListLength = $scope.readingTypeDefaultList.length;

    };

    /* Sensor and ReadingTypes operations */

    $scope.fetchSensorReadingTypes = function(sensorId) {

        var deferred = $q.defer();


        if (typeof $scope.sensorReadingTypes[sensorId] == 'undefined') {
            apiService.readingtype({sensorid:sensorId}).then(function(data) {
                if (data && typeof data.data != "undefined") {
                    $scope.addReadingTypes(data.data);
                    $scope.addReadingTypesToSensor(sensorId, data.data);
                    deferred.resolve();
                } else {
                    deferred.reject();
                }
            });
        } else {
            deferred.resolve();
        }

        return deferred.promise;

    };


    $scope.addReadingTypes = function(readingTypeList) {
        angular.forEach(readingTypeList, function(readingType, key) {
            if (!$scope.getReadingTypeFromId(readingType.readingtypeid)) {
                $scope.readingTypeList.push(readingType);
            }
        });

    };

    $scope.addReadingTypesToSensor = function(sensorid, readingTypeList) {
        $scope.sensorReadingTypes[sensorid] = [];
        angular.forEach(readingTypeList, function(readingType, key) {
            $scope.sensorReadingTypes[sensorid].push(readingType.readingtypeid);
        });
    };

    $scope.getSensorReadingTypes = function(sensorid) {
        var list = [];
        angular.forEach($scope.sensorReadingTypes[sensorid], function(readingType) {
            list.push($scope.getReadingTypeFromId(readingType));
        });
        return list;
    };



    $scope.init = function() {
        $scope.initAddOrEdit();
        loading(false);
    };

    $scope.isEditAlert = false;

    $scope.initAddOrEdit = function() {
        if ($stateParams.alertId) {
            $scope.initEditAlert();
        } else {
            $scope.initAddAlert();
        }
    }

    $scope.initAddAlert = function() {
        $scope.isEditAlert = false;
        $scope.alert = new dmrcAlertService.Alert();
    };

    /* Get set time for current date from colon seperated time ( 12:00 HH:mm format )*/
    $scope.setTime = function(time) {

        var day = moment();

        time = time.split(':');
        day.set({
            hours: time[0],
            minutes: time[1]
        });

        return day;

    }

    $scope.initEditAlert = function() {

        $scope.isEditAlert = true;
        loading(true);
        apiService.alert_get($stateParams.alertId).then(function(data) {

            var data = data.data;
            data.alertId = data.alertid;
            data.alertCategory = data.alertcategory;
            data.readingType = data.readingtypeid;
            data.thresholdValue = data.thresholdvalue;
            data.thresholdDuration = data.thresholdduration;
            data.mobileNum = data.mobilenum;
            data.startTime = data.starttime;
            data.endTime = data.endtime;
            data.expression = data.expression ? data.expression : '';
            if (data.alertCategory == 'complex') {
                data.thresholdValue = 0;
                data.readingType = null;
                data.sensor = null;
            }
            $scope.alert = new dmrcAlertService.Alert();
            angular.forEach($scope.alert, function(alertProperty, key) {
                if (typeof data[key] != 'undefined') {
                    $scope.alert[key] = data[key] ? data[key] : '';
                }
            });
            var startTime = data.startTime.split(':');
            $scope.alert.startHour = parseInt(startTime[0]);
            $scope.alert.startMin = parseInt(startTime[1]);
            var endTime = data.endTime.split(':');
            $scope.alert.endHour = parseInt(endTime[0]);
            $scope.alert.endMin = parseInt(endTime[1]);
            $scope.alert.sensor = data.sensorid;
            loading(false);
        }, function(error) {
            loading(false);
            $state.transitionTo('home.alert');
        });
    }

    $scope.initEvent = function() {

        $scope.isEditEvent = false;

        if ($stateParams.eventId) {
            $scope.initEditEvent($stateParams.eventId);

        } else {
            $scope.initAddEvent();
        }
    };

    $scope.initAddEvent = function() {
        $scope.event = new dmrcAlertService.Event();
        $scope.event.sensorId = $scope.sensors[0].sensorid;
    }

    $scope.initEditEvent = function(eventid) {

        loading(true);
        apiService.event_get(eventid).then(function(data) {
            $scope.event = data.data;
            $scope.event.eventId = $scope.event.eventid;
            $scope.event.eventName = $scope.event.eventname;
            $scope.event.eventDetails = $scope.event.eventdetails;
            $scope.event.sensorId = $scope.event.sensorid;
            $scope.event.dateOfEvent = moment($scope.event.timestamp);
            loading(false);
            $scope.isEditEvent = true;
        }, function() {
            loading(false);
            $scope.isEditEvent = false;
            $state.transitionTo('home.alert');
        });

    }

    $scope.deleteComplexCondition = function(conditionIndex) {
        if (typeof $scope.alert.complexConditions[conditionIndex] != "undefined") {
            $scope.alert.complexConditions.splice(conditionIndex, 1);
        }
    }

    $scope.deleteSensorFromComplexCondition = function(conditionIndex, sensorIndex) {
        if (typeof $scope.alert.complexConditions[conditionIndex] != "undefined" && typeof $scope.alert.complexConditions[conditionIndex].sensors[sensorIndex] != "undefined" ) {
            $scope.alert.complexConditions[conditionIndex].sensors.splice(sensorIndex, 1);
        }
    }

    $scope.resetAlert = function() {
        $scope.alert = new dmrcAlertService.Alert();
    };

    $scope.resetEvent = function() {
        $scope.event = new dmrcAlertService.Event();
    };

    $scope.loadAlerts = function() {
        loading(true);
        apiService.alert_list().then(function(data) {
            $scope.alerts = data.data.system_alerts;
            $scope.events = data.data.user_defined_alerts;
            setTimeout(function() {
                $('[data-toggle="tooltip"]').tooltip({
                    trigger : 'hover'
                }).on('click', function () {
                    $(this).tooltip('hide')
                });
                loading(false);
            }, 1000);
        });
    };

    /**
     * This function will be called on duration value change and it'll update thresholdDuration's value because we * have validation repeat option cannot be less than the duration value
     */
     $scope.$watch('alert.duration', function(newValue, oldValue) {
        if (newValue) {
            if ($scope.alert.thresholdDuration <= newValue) {
                for (var i = 0; i < $scope.repeatOption.length; i++) {
                    if ($scope.repeatOption[i].value > newValue) {
                        $scope.alert.thresholdDuration = $scope.repeatOption[i].value;
                        return;
                    }
                }
            }
        }
    });

     /* Initialize condition array for simple alert */
     $scope.initSimpleCondition = function() {

        $scope.initReadingTypeDefaultList();

        if (typeof $scope.alert.simpleConditions != 'undefined' && $scope.alert.simpleConditions.length > 0) {
            return;
        }
        if (!$scope.alert.sensor) {
            $scope.alert.sensor = $scope.sensors[0].sensorid;
        }

        if (!$scope.alert.readingType) {
            $scope.alert.readingType = dmrcAlertService.defaultReadingTypeId;
        }

        $scope.alert.selectedEvent = 0;

        angular.forEach($scope.readingTypeDefaultList, function(defaultReadingType, index) {
            if (typeof $scope.alert.simpleConditions[index] == 'undefined') {
                $scope.alert.simpleConditions[index] = {};
            }
            $scope.alert.simpleConditions[index].condition = defaultReadingType.options[0].value;
        });

        $scope.alert.simpleConditions[$scope.readingTypeDefaultList.length] = {
            readingType: dmrcAlertService.defaultReadingTypeId
        };

        /* If it's edit alert then set simpleConditions */
        if ($scope.alert.alertId > 0) {

            var isDefaultCondition = false;
            angular.forEach($scope.readingTypeDefaultList, function(defaultReadingType, index) {
                if (defaultReadingType.readingtypeid == $scope.alert.readingType && defaultReadingType.options[0].value == $scope.alert.condition) {
                    $scope.alert.selectedEvent = index;
                    $scope.alert.simpleConditions[index].thresholdValue = $scope.alert.thresholdValue;
                    isDefaultCondition = true;
                    $scope.alert.simpleConditions[$scope.defaultReadingTypeListLength].condition = '1';
                }
            });

            if (!isDefaultCondition) {
                $scope.alert.selectedEvent = 2;
                $scope.alert.simpleConditions[$scope.alert.selectedEvent] = {
                    readingType: $scope.alert.readingType,
                    condition: $scope.alert.condition.toString(),
                    thresholdValue: $scope.alert.thresholdValue || 0
                };
            }

        } else {
            $scope.alert.simpleConditions[$scope.defaultReadingTypeListLength].condition = '1';
        }

    };

    /* Initialize condition array for complex alert */
    $scope.initComplexCondition = function() {

        if ($scope.alert.alertId > 0 && $scope.alert.expression) {
            $scope.alert.complexConditions = dmrcAlertService.generateComplexConditions($scope.alert.expression);
            return;
        }
        /* Initialize only if not already exist */
        if (typeof $scope.alert.complexConditions === 'undefined' || !$scope.alert.complexConditions || $scope.alert.complexConditions.length === 0) {
            $scope.alert.complexConditions = [];
            $scope.addCondition();
        }
    };

    /* Add new complex condition */
    $scope.addCondition = function() {

        /* Check for complex condition limit , only $scop.allowedConditions number of conditions are allowed */
        if ($scope.alert.complexConditions.length >= $scope.allowedConditions) {
            return false;
        }

        /* Initialize new condition with default parameter and get index of pushed element */
        var conditionIndex = $scope.alert.complexConditions.push({
            sensors: [],
            readingType: dmrcAlertService.defaultReadingTypeId,
            condition: 1,
            thresholdValue: null
        }) - 1;

        /* Set default selected sensor in new condition */
        var defaultSelectedSensor = $scope.getFistAllowed(conditionIndex);
        $scope.alert.complexConditions[conditionIndex].sensors.push(defaultSelectedSensor);

    };

    /* ToggelSign to change '+' ( value:1) and '-' (value:0) sign in complex condition */
    $scope.toggleSign = function(conditionIndex, sensorIndex) {
        $scope.alert.complexConditions[conditionIndex].sensors[sensorIndex].type = -1 * ($scope.alert.complexConditions[conditionIndex].sensors[sensorIndex].type);
    };

    /* Only one sensor per condition allowed, following function will disable already added sensor in select list of sensor selection for current condition */
    $scope.isSensorExist = function(conditionIndex, sensorIndex, sensorToCheck) {
        var isFound = false;
        angular.forEach($scope.alert.complexConditions[conditionIndex].sensors, function(sensor, key) {
            if (sensor.data.sensorid == sensorToCheck.sensorid && sensorIndex != key) {
                isFound = true;
            }
        });
        return isFound;
    };


    /* On sensor add, set default sensor value. Only one sensor per condition allowed, so following function will lookup for first available sensor value which are not in current condition */
    $scope.getFistAllowed = function(conditionIndex) {
        var AllowedSensor = {
            data: {},
            type: 1
        };
        for (var sensorIndex = 0; sensorIndex < $scope.sensors.length; sensorIndex++) {
            var isFound = false;
            for (var i = 0; i < $scope.alert.complexConditions[conditionIndex].sensors.length; i++) {
                if (!isFound && angular.equals($scope.sensors[sensorIndex].sensorid, $scope.alert.complexConditions[conditionIndex].sensors[i].data.sensorid)) {
                    isFound = true;
                }
            }
            if (!isFound) {
                AllowedSensor.data.sensorid = $scope.sensors[sensorIndex].sensorid;
                /* Set default '+' sign */
                AllowedSensor.type = 1;
                return AllowedSensor;
            }
        }
        return AllowedSensor;
    };


    /* Add new sensor for complex condition */
    $scope.addSensor = function(conditionIndex, location) {

        /* Check for sensor limit per complex condition , only $scop.allowedSensors number of sensors are allowed per condition */
        if ($scope.alert.complexConditions[conditionIndex].sensors.length >= $scope.allowedSensors) {
            return false;
        }

        var defaultSelectedSensor = $scope.getFistAllowed(conditionIndex);
        $scope.alert.complexConditions[conditionIndex].sensors.push(defaultSelectedSensor);

    };


    $scope.$watch('alert.alertCategory', function(newValue, oldValue) {
        if (newValue == 'complex') {
            /* Initialize complex condition structure */
            $scope.initComplexCondition();
            /* Update complexReadingTypeList based on selected sensors */
            // Code to generate complexReadingTypeList based on selected sensors
        } else if (newValue == 'simple') {
            $scope.initSimpleCondition();
        }
    });


    /* In simple alert on sensor value change, update the simpleSensorReadingTypeList */
    $scope.$watch('alert.sensor', function(newValue, oldValue) {
        if (newValue) {
            $scope.fetchSensorReadingTypes(newValue).then(function() {
                $scope.buildSingleSensorReadingTypeList(newValue);
            });
        }
    });


    $scope.updateSensorReadingTypes = function(sensorid, complexConditionKey, sensorKey) {
        $scope.fetchSensorReadingTypes(sensorid).then(function() {
            $scope.buildComplexSensorReadingTypeList(complexConditionKey, sensorid);
        });
    };

    $scope.buildSingleSensorReadingTypeList = function(sensorId) {
        $scope.singleSensorReadingTypeList = $scope.getSensorReadingTypes(sensorId);
        /* by default select first value */
        if ($scope.alert.simpleConditions.length>0 && !$scope.alert.simpleConditions[$scope.defaultReadingTypeListLength].readingType) {
            $scope.alert.simpleConditions[$scope.defaultReadingTypeListLength].readingType = $scope.singleSensorReadingTypeList[0].readingtypeid;
        }
    };

    function substract(a, b) {

        var onlyInA = a.filter(function(current) {
            return b.filter(function(current_b) {
                return current_b.readingtypeid == current.readingtypeid;
            }).length === 0;
        });

        var substract = a.filter(function(current) {
            return onlyInA.filter(function(current_onlyInA) {
                return current_onlyInA.readingtypeid == current.readingtypeid;
            }).length === 0;
        });
        return substract;
    }


    $scope.buildComplexSensorReadingTypeList = function(conditionKey, sensorId) {

        /* Code for sensor intersaction of complex sensor readingtype list */
        // $scope.multipleSensorReadingTypeList[conditionKey] = $scope.readingTypeList;
        $scope.multipleSensorReadingTypeList[conditionKey] = [];
        angular.forEach($scope.alert.complexConditions[conditionKey].sensors, function(sensor, key) {
            if (key) {
                $scope.multipleSensorReadingTypeList[conditionKey] = substract($scope.multipleSensorReadingTypeList[conditionKey], $scope.getSensorReadingTypes(sensor.data.sensorid));
            } else {
                $scope.multipleSensorReadingTypeList[conditionKey] = $scope.getSensorReadingTypes(sensor.data.sensorid);
            }
        });

        if (!$scope.alert.complexConditions[conditionKey].readingType && $scope.multipleSensorReadingTypeList[conditionKey][0]) {
            $scope.alert.complexConditions[conditionKey].readingType = $scope.multipleSensorReadingTypeList[conditionKey][0].readingtypeid;
        }

    };

    /* Save alert */
    $scope.addAlert = function(alert) {
        $scope.isSubmitting = true;
        alert = $scope.buildPayload(angular.copy(alert));
        apiService.alert_save(alert).then(function(response) {
            if(!alert.eventId)
                Analytics.trackEvent('Alerts', 'Alert Added', $state.current.name);
            else
                Analytics.trackEvent('Alerts', 'Alert Updated', $state.current.name);
            $scope.alert = new dmrcAlertService.Alert();
            $scope.isSubmitting = false;
            $state.go('home.alert');
        }, function() {
            if(!alert.eventId)
                Analytics.trackEvent('Alerts', 'Alert adding failed', $state.current.name);
            else
                Analytics.trackEvent('Alerts', 'Alert updating failed', $state.current.name);
            bootbox.alert('Some error occured while processing. Please try again after some time');
            $scope.isSubmitting = false;
        });
    };

    $scope.updateStatus = function(alert) {
        if (alert.enabled) {
            bootbox.confirm("Are you sure you want to Disable selected alert?", function(result) {
                if (result) {
                    alert.enabled = false;
                    continueUpdate(alert);
                    Analytics.trackEvent('Alerts', 'Alert Disabled', $state.current.name);
                }
            });
        } else {
            alert.enabled = true;
            continueUpdate(alert);
            Analytics.trackEvent('Alerts', 'Alert Enabled', $state.current.name);
        }

        function continueUpdate(alert) {
            var enableAlerts = $filter('filter')($scope.alerts, function(alert) {
                return alert.enabled == true;
            });
            var alertlist = '';
            for (var i = 0; i < $scope.alerts.length; i++) {
                if ($scope.alerts[i].enabled) {
                    if (alertlist != '') {
                        alertlist += ",";
                    }
                    alertlist += $scope.alerts[i].alertid;
                }
            }
            loading(true);
            apiService.alert_update_status(alertlist).then(function(data) {
                loading(false);
            }, function() {
                var index = $scope.alerts.indexOf(alert);
                $scope.alerts[index].enabled = !alert.enabled;
                loading(false);
            });
        }
    };

    $scope.deleteAlert = function(alertId) {

        loading(true);
        var isListPage = $state.current.name == 'home.alert';
        apiService.alert_delete(alertId).then(function(data) {
            Analytics.trackEvent('Alerts', 'Alert deleted', $state.current.name);
            loading(false);
            if (isListPage) {
                var alert = $scope.getAlertFromId(alertId);
                var index = $scope.alerts.indexOf(alert);
                $scope.alerts.splice(index, 1);
            } else {
                $state.transitionTo('home.alert', null, {
                    reload: true
                });
            }
        }, function(data) {
            Analytics.trackEvent('Alerts', 'Alert deleting failed', $state.current.name);
            loading(false);
            $state.transitionTo('home.alert', null, {
                reload: true
            });
        });
    }

    $scope.update_events = function(event) {
        event = angular.copy(event);
        event.dateOfEvent = moment(event.dateOfEvent).format('YYYY/MM/DD hh:mm:ss');
        loading(true);
        apiService.event_save(event).then(function(data) {
            loading(false);
            $state.transitionTo('home.alert');
            Analytics.trackEvent('Alerts', 'Event Updated', $state.current.name);
        }, function(data) {
            loading(false);
            Analytics.trackEvent('Alerts', 'Event updating failed', $state.current.name);
        });
    }

    $scope.deleteEvent = function(eventid) {
        loading(true);
        var isListPage = $state.current.name == 'home.alert';
        apiService.event_delete(eventid).then(function(data) {
            loading(false);
            if (isListPage) {
                var event = $scope.getEventFromId(eventid);
                var index = $scope.events.indexOf(event);
                $scope.events.splice(index, 1);
                Analytics.trackEvent('Alerts', 'Event Deleted', $state.current.name);
            } else {
                $state.transitionTo('home.alert', null, {
                    reload: true
                });
            }
        }, function() {
            loading(false);
            $state.transitionTo('home.alert', null, {
                reload: true
            });
            Analytics.trackEvent('Alerts', 'Event delete failed', $state.current.name);
        });
    }

    $scope.buildPayload = function(alert) {

        if (alert.alertCategory == 'simple') {
            alert.thresholdValue = alert.simpleConditions[alert.selectedEvent].thresholdValue;
            alert.readingType = alert.simpleConditions[alert.selectedEvent].readingType;
            alert.condition = alert.simpleConditions[alert.selectedEvent].condition;
            this.expression = '';
        }
        if (alert.alertCategory == 'complex') {
            alert.thresholdValue = alert.complexConditions[0].thresholdValue;
            alert.readingType = alert.complexConditions[0].readingType;
            alert.sensor = alert.complexConditions[0].sensors[0].data.sensorid;
            alert.expression = dmrcAlertService.generateExpression(alert.complexConditions);
            alert.condition = 1;
        }

        delete alert.simpleConditions;
        delete alert.complexConditions;

        return alert;

    };

}

smartsenseApp.factory('dmrcAlertService', dmrcAlertService);

dmrcAlertService.$inject = [];

function dmrcAlertService() {

    var allowedSensors = 5;
    var allowedConditions = 3;

    /* For alert add */
    var allowedMobiles = 3;
    var allowedEmails = 10;

    var daysOption = [{
        label: 'All',
        value: -1
    }, {
        label: 'Mon',
        value: 2
    }, {
        label: 'Tue',
        value: 3
    }, {
        label: 'Wed',
        value: 4
    }, {
        label: 'Thu',
        value: 5
    }, {
        label: 'Fri',
        value: 6
    }, {
        label: 'Sat',
        value: 7
    }, {
        label: 'Sun',
        value: 1
    }];

    var durationOption = [{
        label: '2 mins',
        value: 2
    },{
        label: '5 mins',
        value: 5
    }, {
        label: '15 mins',
        value: 15
    }, {
        label: '30 mins',
        value: 30
    }];

    var repeatOption = [{
        label: '15 mins',
        value: 15
    }, {
        label: '30 mins',
        value: 30
    }, {
        label: '1 hour',
        value: 60
    }, {
        label: '6 hours',
        value: 360
    }, {
        label: '1 day',
        value: 1440
    }];

    var defaultReadingTypeId = 2002;

    var service = {
        Alert: Alert,
        Event: Event,
        allowedSensors: allowedSensors,
        allowedConditions: allowedConditions,

        /* Allowed values for radio and select inputs */
        daysOption: daysOption,
        durationOption: durationOption,
        repeatOption: repeatOption,

        allowedMobiles: allowedMobiles,
        allowedEmails: allowedEmails,
        generateExpression: generateExpression,
        generateComplexConditions: generateComplexConditions,

        // Add, edit & detele events
        mapping: mapping,
        defaultReadingTypeId: defaultReadingTypeId,
        getHours: getHours,
        getMinutes: getMinutes
    };

    return service;

    ////////////

    function Event() {
        this.eventName = '';
        this.sensorId = null;
        this.eventDetails = '';
        this.dateOfEvent = '';
    }

    function Alert() {

        this.alertId = -1;
        this.alertCategory = 'simple';
        this.label = '';
        this.sensor = null;
        this.duration = 5;
        this.day = daysOption[0].value;

        this.startHour = 00;
        this.startMin = 00;
        this.endHour = 00;
        this.endMin = 00;
        // this.time = new Date();
        this.thresholdDuration = 15;
        this.mobileNum = '';
        this.email = '';

        /* Condition to trigger alert, this will change in case of advance alertCategory */
        this.readingType = defaultReadingTypeId;
        this.condition = 1;
        this.thresholdValue = 0;
        this.expression = '';

        /* Events for simple and complex category */
        this.complexConditions = [];
        this.simpleConditions = [];


        /* Sample edit complex alert data */
        // this.expression = "1173_2001 + 1175_2001 + 1174_2001 > 44444 AND 1173_2006 + 1176_2006 + 1178_2006 + 1179_2006 + 1171_2006 > 444444 AND 1171_2005 + 1172_2005 + 1173_2005 + 1174_2005 + 1175_2005 < 55555 ";
        // this.complexConditions = generateComplexConditions(this.expression);
    }


    /* Return expression based on value. Used in creating expression for complex condition */
    function getConditionRepresentation(val) {
        if (val == 1) {
            return ">";
        } else if (val == 2) {
            return "<";
        } else if (val === 0) {
            return "=";
        }
        return null;
    }

    function findInstances(inputStr, regex) {
        var result, indices = [];
        var str = inputStr;
        while ((result = regex.exec(str))) {
            indices.push(result.index);
        }
        return indices;
    }

    /*
      @abstract
      Create expression from complex conditions

      @example

      input : [{"sensors":[{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1175},"type":1},{"data":{"sensorid":1174},"type":1}],"readingType":2001,"condition":1,"thresholdValue":44444},{"sensors":[{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1176},"type":1},{"data":{"sensorid":1178},"type":1},{"data":{"sensorid":1179},"type":1},{"data":{"sensorid":1171},"type":1}],"readingType":2006,"condition":1,"thresholdValue":444444},{"sensors":[{"data":{"sensorid":1171},"type":1},{"data":{"sensorid":1172},"type":1},{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1174},"type":1},{"data":{"sensorid":1175},"type":1}],"readingType":2005,"condition":2,"thresholdValue":55555}]

      output:
      1173_2001 + 1175_2001 + 1174_2001 > 44444 AND 1173_2006 + 1176_2006 + 1178_2006 + 1179_2006 + 1171_2006 > 444444 AND 1171_2005 + 1172_2005 + 1173_2005 + 1174_2005 + 1175_2005 < 55555

     */
    function generateExpression(complexConditions) {
        for (var i = 0; i < complexConditions.length; i++) {
            if (isNaN(complexConditions[i].thresholdValue)) {
                bootbox.alert("Please enter a valid number for threshold value of the Condition " + (i + 1));
                return "";
            }
        }
        var expression = "";
        for (i = 0; i < complexConditions.length; i++) {
            if (i !== 0) {
                expression = expression + " AND ";
            }
            for (var j = 0; j < complexConditions[i].sensors.length; j++) {

                if (j) {
                    expression = expression + " " + (complexConditions[i].sensors[j].type == 1 ? "+" : "-") + " ";
                }

                expression = expression + complexConditions[i].sensors[j].data.sensorid + "_" + complexConditions[i].readingType;

            }
            expression = expression + " " + getConditionRepresentation(complexConditions[i].condition) + " " + complexConditions[i].thresholdValue + " ";
        }
        return expression;
    }

    /*

    @abstract
    Generate complexConditions from the given expression. Reverse function of generateExpression().
    Will be in use while editing complex alert

    @example

    input:
    1173_2001 + 1175_2001 + 1174_2001 > 44444 AND 1173_2006 + 1176_2006 + 1178_2006 + 1179_2006 + 1171_2006 > 444444 AND 1171_2005 + 1172_2005 + 1173_2005 + 1174_2005 + 1175_2005 < 55555

    output : [{"sensors":[{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1175},"type":1},{"data":{"sensorid":1174},"type":1}],"readingType":2001,"condition":1,"thresholdValue":44444},{"sensors":[{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1176},"type":1},{"data":{"sensorid":1178},"type":1},{"data":{"sensorid":1179},"type":1},{"data":{"sensorid":1171},"type":1}],"readingType":2006,"condition":1,"thresholdValue":444444},{"sensors":[{"data":{"sensorid":1171},"type":1},{"data":{"sensorid":1172},"type":1},{"data":{"sensorid":1173},"type":1},{"data":{"sensorid":1174},"type":1},{"data":{"sensorid":1175},"type":1}],"readingType":2005,"condition":2,"thresholdValue":55555}]

    */
    function generateComplexConditions(expression) {
        var complexConditions = [];
        // part 1 split by and
        var subExps = expression.split("AND");
        for (var i = 0; i < subExps.length; i++) {

            /* init complex condition */
            var complexCondition = {
                sensors: [],
                readingType: null,
                condition: 1,
                thresholdValue: 0
            };

            // set condition assignment
            if (subExps[i].indexOf(">") > 0) {
                complexCondition.condition = 1;
            } else if (subExps[i].indexOf("<") > 0) {
                complexCondition.condition = 2;
            } else if (subExps[i].indexOf("=") > 0) {
                complexCondition.condition = 0;
            }

            /* split sub expression by '<' or '>' */
            var parts = subExps[i].split(/[\>\<=]/);

            // set threshold value
            complexCondition.thresholdValue = Number(parts[1].trim());


            var SensorReadingTypeList = parts[0].split(/[+-]/);

            // set readingType
            complexCondition.readingType = Number(SensorReadingTypeList[0].trim().split("_")[1]);

            // set sensorids
            for (var j = 0; j < SensorReadingTypeList.length; j++) {
                var sid = SensorReadingTypeList[j].trim().split("_")[0];
                complexCondition.sensors[j] = {
                    data: {},
                    type: 1
                };
                complexCondition.sensors[j].data.sensorid = Number(sid);
            }
            //For sensorSigns '+' or '-'
            expSigns = findInstances(parts[0], /[+-]/gi);
            for (j = 0; j < expSigns.length; j++) {
                if (parts[0][expSigns[j]] == "+") {
                    complexCondition.sensors[j].type = 1;
                } else {
                    complexCondition.sensors[j].type = -1;
                }
            }
            complexConditions.push(complexCondition);
        }
        return complexConditions;
    }


    function mapping(reverse) {
        var map = {
            alertid: "alertId",
            alertId: "alertid",
            alertCategory: "alertcategory",
            readingType: "readingtypeid",
            thresholdValue: "thresholdvalue",
            thresholdDuration: "thresholdduration",
            mobileNum: "mobilenum",
            startTime: "starttime",
            endTime: "endtime"
        }
    }

    function getHours() {
        var hours = [];
        for (var i = 0; i < 24; i++) {
            var label = i < 10 ? '0' + i : i + '';
            hours.push({
                label: label,
                value: i
            });
        }
        return hours
    }

    function getMinutes() {
        var minutes = [{
            label: '00',
            value: 0
        }, {
            label: '30',
            value: 30
        }];
        return minutes;
    }

}

smartsenseApp.controller("DMRCWidgetSummaryController", ['$scope',
    function($scope) {
        $scope.widget = {};
        $scope.widget.title = $scope.options.title;
        $scope.widget.type = $scope.options.type;
        $scope.widget.tooltip = $scope.options.tooltip;
        $scope.$on('dmrcLiftDataLoaded', function(events, data) {
            $scope.dmrcLiftData = data;
            $scope.summary = $scope.dmrcLiftData.summary_status || {};
            if ($scope.summary.total_appliance) {
                $scope.summary.perc = (100 * $scope.summary.number_of_appliance_reported_error) / $scope.summary.total_appliance;
            } else {
                $scope.summary.perc = 0;
            }
            $scope.summary.total_appliance = $scope.summary.total_appliance || 0;
            $scope.summary.number_of_appliance_reported_error = $scope.summary.number_of_appliance_reported_error || 0;
            $scope.summary.total_errors_reported = $scope.summary.total_errors_reported || 0;
        });
    }
]);
smartsenseApp.controller("DMRCWidgetErrorCategoriesController", ['$scope', '$timeout', 'local', 'apiService', function($scope, $timeout, local, apiService) {
    $scope.localData = local.data;
    $scope.refreshInProgress = true;
    $scope.widget = {};
    $scope.widget.title = $scope.options.title;
    $scope.widget.type = $scope.options.type;
    $scope.widget.tooltip = $scope.options.tooltip;
    $scope.errorCategories = [];
    $scope.errorCategoriesOptions = [];
    $scope.errorData = {};

    $scope.graphOptions = {
        legend: {
            visible: true,
            enabled: true
        },
        plotOptions: {
            column: {
                stacking: false
            }
        },
        tooltip: {
            formatter: function() {
                var s = [];
                $.each(this.points, function(i, point) {
                    s.push('<span style="color:' + point.color + ';font-weight:bold;">' + point.series.name + ' <br/> ' +
                        point.key + ':' + point.y + '<span>');
                });
                return s.join(' and ');
            },
            shared: true
        },
        xAxis: {
            type: "category",
            labels: {
                rotation: -45
            }
        },
        responsive: true,
        yAxis: {
            min: 0,
            gridLineWidth: 0,
            minorGridLineWidth: 0,
            title: {
                text: null
            },
            visible: true,
            stackLabels: {
                enabled: true,
                verticalAlign: 'top',
                align: 'center',
                style: {
                    fontWeight: 'normal',
                    color: (Highcharts.theme && Highcharts.theme.textColor) || 'gray'
                },
                formatter: function() {
                    return Highcharts.numberFormat(this.total, 0, ',');
                }
            }
        }
    };

    $scope.init = function() {
        $scope.refreshInProgress = true;
        apiService.getLiftErrorStats($scope.localData.dmrc.dateRange.startDate, $scope.localData.dmrc.dateRange.endDate).then(function(response) {
            $scope.errorCategoriesOptions = [];
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = false;
            if (response && response.data) {
                $scope.errorData = $scope.preocessData(response.data.data);
                $scope.errorCategories = $scope.errorCategories.sort();
                $scope.errorCategories.forEach(function(error) {
                    $scope.errorCategoriesOptions.push({
                        key: error,
                        value: error
                    });
                })
                $scope.widget.selectedCategory = $scope.errorCategories[0];
                $scope.renderGraphs();
            }
        }, function(error) {
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });
    };

    $scope.renderGraphs = function(category) {
        $scope.graphOptions.series = []
        category = category || $scope.widget.selectedCategory;
        for (var key in eval($scope.errorData[category])) {
            var records = $scope.errorData[category][key] || [];
            records = records.sort(function(val, val2) {
                var a = val.error_code;
                var b = val2.error_code;
                if (a === b) {
                    return 0;
                }
                if (typeof a === typeof b) {
                    return a < b ? -1 : 1;
                }
                return typeof a < typeof b ? -1 : 1;
            });
            var data = [];
            for (var i = 0; i < records.length; i++) {
                var curRecord = records[i];
                data.push([curRecord.error_code, curRecord.error_count, curRecord.error_name]);
            }
            if (key == "OTIS") {
                color = '#dc773e';
            } else if (key == "Johnson") {
                color = '#0196c9';
            } else {
                color = '#bdd82b';
            }
            $scope.graphOptions.series.push({ name: key, data: data, pointWidth: 25, color: color });
        }
    };

    // Make a categorized list of error records
    $scope.preocessData = function(data) {
        if (!data || data.length == 0)
            return false;
        var records = {};
        for (var i = 0; i < data.length; i++) {
            var curRecord = data[i];
            ////Hardcoded logic for Lift's and Escalator - by Naitik
            if (curRecord.manufacturer_name == "OTIS") {
                errorCategory = "Escalator";
            } else {
                errorCategory = "Lift";
            }
            // Converting array of records to key value pair with OEM name as a key
            curRecord.manufacturer_name = curRecord.manufacturer_name || "-";
            records[errorCategory] = records[errorCategory] || {};
            records[errorCategory][curRecord.manufacturer_name] = records[errorCategory][curRecord.manufacturer_name] || [];
            records[errorCategory][curRecord.manufacturer_name].push(curRecord);
            if (!$scope.errorCategories.has(errorCategory)) {
                $scope.errorCategories.push(errorCategory);
            }
        }
        return records;
    }

    $scope.$watch('localData.dmrc.dateRange', function(newVal, oldVal) {
        if (newVal && newVal != oldVal) {
            $scope.init();
        }
    }, true);

    $scope.init();

}]);
smartsenseApp.controller("DMRCWidgetErrorReportController", ['$scope', '$rootScope', 'data', 'local', 'config', '$timeout',
    function($scope, $rootScope, data, local, config, $timeout) {
        $scope.localData = local.data;
        $scope.widget = {};
        $scope.widget.title = $scope.options.title;
        $scope.widget.type = $scope.options.type;
        $scope.widget.tooltip = $scope.options.tooltip;

        $scope.sortType = "starttime";
        $scope.sortReverse = true;
        $scope.filterType = "";

        $scope.$watch('localData.locateDMRCErrors', function(newVal) {
            if (newVal) {
                $('html, body').animate({
                    scrollTop: $("#DMRCErrorReportTable").offset().top - 140
                }, 1000);
                $scope.localData.locateDMRCErrors = false;
            }
        });

        $scope.$watch('localData.locateErrorsFilter', function(newVal) {
            if (typeof newVal != "undefined") {
                $scope.filterType = "error";
                $scope.searchSensors = newVal.split("|")[0];
                $scope.searchSensorsFilter = newVal.split("|")[1];
            }
        });

        $scope.filterErrorsForSensor = function(row) {
            if ($scope.searchSensorsFilter) {
                var sensors = $scope.searchSensors ? $scope.searchSensors.split(",") : [];
                if (sensors.has(row.sensorid.sensorid + ""))
                    return row;
            } else
                return row;
        };

        $scope.clearFilter = function() {
            $scope.filterType = "";
            $scope.searchSensors = "";
            $scope.searchSensorsFilter = "";
        };

        $scope.formatDate = function(date) {
            if (moment(date).isValid())
                return moment(date).format("DD MMM YYYY hh:mm:ss A");
            else
                return "-";
        }

        $scope.$on('dmrcLiftDataLoaded', function(events, data) {
            $scope.dmrcLiftData = data;
            $scope.mappingData = $scope.dmrcLiftData.event_data_mapping;
            $scope.locationMappingData = $scope.dmrcLiftData.sensor_param_data;
            $scope.reportData = $scope.dmrcLiftData.error_reporting_table || [];
            if (!$.isArray($scope.reportData)) {
                $scope.reportData = [];
            }
            $scope.reportData.forEach(function(row) {
                row = angular.extend(row, $scope.mapErrorCodes(row.eventnstatustypeid));
                row.oem = $scope.getOEMInfo(row.sensorid.sensorid);
                row.dateFormatted = $scope.formatDate(row.starttime);
                row.dateFormatted_end = $scope.formatDate(row.endtime);
                var starttime_a = moment(row.starttime); //now
                var endtime_b = moment(row.endtime);
                if (utils.isValidDate(row.endtime)) {
                    var diff = starttime_a.diff(endtime_b, 'minutes');
                    row.downtime = moment.duration(diff, 'minutes').humanize();
                } else {
                    row.downtime = "-";
                }
                if (row.iserror) {
                    row.sublabel = "-";
                } else {
                    row.sublabel = row.value_range[row.value];
                }
            });
        });

        $scope.getOEMInfo = function(sensorId) {
            if (!$scope.locationMappingData || !sensorId)
                return false;

            for (var i = 0; i < $scope.locationMappingData.length; i++) {
                var map = $scope.locationMappingData[i];
                if (map.sensorid == sensorId)
                    return map.parametervalue || "-";
            }
            return "-";
        };

        $scope.mapErrorCodes = function(id) {
            if (!$scope.mappingData || !id)
                return false;

            for (var i = 0; i < $scope.mappingData.length; i++) {
                var map = $scope.mappingData[i];
                if (map.eventnstatustypeid == id)
                    return map;
            }
        }

        $scope.downloadReport = function() {
            var rows = [
                ['Parent Location', 'Location', 'Equipment OEM', 'Code', 'Type', 'Label', 'Sub Label', 'Reported At', 'Rectified At']
            ];
            $scope.widget.liftErrors.forEach(function(row) {
                rows.push([
                    row.sensorid.parent_location,
                    row.sensorid.name,
                    row.oem,
                    row.code,
                    row.iserror ? "Error" : "Status",
                    row.label,
                    row.sublabel,
                    row.starttime,
                    row.dateFormatted,
                ]);
            });
            var postfix = $scope.dmrcLiftData.startDate + "_" + $scope.dmrcLiftData.endDate;
            utils.exportToCsv('LiftStatus_' + postfix + '.csv', rows);
        }

        $scope.setFilterType = function(type) {
            $scope.filterType = type;
        }

        $scope.filterErrors = function(row) {
            if ($scope.filterType == "error" && row.iserror)
                return row;
            else if ($scope.filterType == "status" && !row.iserror)
                return row;
            else if ($scope.filterType == "")
                return row;
        }
    }
]);
smartsenseApp.controller("DMRCWidgetErrorAlertPanelController", ['$scope', '$rootScope', 'data', 'local', 'config', 'apiService', '$timeout', '$state',
    function($scope, $rootScope, data, local, config, apiService, $timeout, $state) {
        $scope.localData = local.data;
        $scope.widget = {};
        $scope.widget.title = $scope.options.title;
        $scope.widget.type = $scope.options.type;
        $scope.widget.tooltip = $scope.options.tooltip;
        $scope.tableConfig = {
            itemsPerPage: 50,
            fillLastPage: true
        };

        $scope.sortType = "starttime";
        $scope.sortReverse = true;
        $scope.filterType = "";

        $scope.refreshData = function(){
            $scope.refreshInProgress = true;
            apiService.getLiftNotifications(moment().format("YYYY-MM-DD"), moment().format("YYYY-MM-DD")).then(function(response) {
                $scope.refreshInProgress = false;
                $scope.serverNotRecheable = false;
                if (response && response.data) {
                    $scope.dmrcLiftNotifData = response.data;
                    $scope.mappingData = $scope.dmrcLiftNotifData.event_data_mapping;
                    $scope.locationMappingData = $scope.dmrcLiftNotifData.sensor_param_data;
                    $scope.reportData = $.isArray($scope.dmrcLiftNotifData.error_reporting_table) ? $scope.dmrcLiftNotifData.error_reporting_table : [];
                    $scope.reportData.forEach(function(row){
                        row = angular.extend(row, $scope.mapErrorCodes(row.eventnstatustypeid));
                        row.oem = $scope.getOEMInfo(row.sensorid.sensorid);
                        row.dateFormatted = $scope.formatDate(row.starttime);
                        if(row.iserror){
                            row.sublabel = "-";
                        }
                        else{
                            row.sublabel = row.value_range[row.value];
                        }
                    });
                    $scope.localData.dmrcAlertCount = $scope.dmrcLiftNotifData.todays_count;
                    $timeout(function(){
                        $('[data-toggle="tooltip"]').tooltip();
                    }, 100);
                    $timeout(function(){
                        $scope.refreshData();
                    }, 60000);
                }
            }, function(error) {
                $scope.refreshInProgress = false;
                $scope.serverNotRecheable = true;
            });
        }

        $scope.formatDate = function(date){
            return moment(date).format("DD MMM YYYY hh:mm:ss A");
        }

        $scope.getOEMInfo = function(sensorId){
            if(!$scope.locationMappingData || !sensorId)
                return false;

            for (var i = 0; i < $scope.locationMappingData.length; i++) {
                var map = $scope.locationMappingData[i];
                if(map.sensorid == sensorId)
                    return map.parametervalue || "-";
            }
            return "-";
        };

        $scope.mapErrorCodes = function(id){
            if(!$scope.mappingData || !id)
                return false;

            for (var i = 0; i < $scope.mappingData.length; i++) {
                var map = $scope.mappingData[i];
                if(map.eventnstatustypeid == id)
                    return map;
            }
        }

        $scope.setFilterType = function(type){
            $scope.filterType = type;
        }

        $scope.filterErrors = function(row){
            if($scope.filterType == "error" && row.iserror)
                return row;
            else if($scope.filterType == "status" && !row.iserror)
                return row;
            else if($scope.filterType == "")
                return row;
        }

        $scope.showAllErrors = function(){
            $scope.localData.locateDMRCErrors = true;
            $scope.localData.locateErrorsFilter = "";
            $state.go("home.dmrcdashboard");
            $(document).trigger("click");
        };

        $('[data-toggle="popover"]').popover();
        $scope.refreshData();
        $(document).on('click', '.alert-panel', function(e) {
          e.stopPropagation()
        });
    }
]);

smartsenseApp.controller("DMRCWidgetReportedErrorsController", ['$scope',
    function($scope) {

        $scope.widget = {};
        $scope.widget.title = $scope.options.title;
        $scope.widget.type = $scope.options.type;
        $scope.widget.tooltip = $scope.options.tooltip;

        var getColor = {
            'OTIS': '#dc773e',
            'Johnson': '#0196c9',
            'KONE': '#bdd82b',
        }

        $scope.$on('dmrcLiftDataLoaded', function(events, data) {
            $scope.dmrcLiftData = data;
            var errors = $scope.dmrcLiftData.oem_wise_errors_reported || [];
            if (!$.isArray(errors))
                errors = [];
            $scope.donutData = {};
            errors.forEach(function(curItem) {
                if (curItem && curItem.length == 2) {
                    $scope.donutData[curItem[0]] = curItem[1];
                }
            });
            $scope.locationMappingData = $scope.dmrcLiftData.sensor_param_data;
            $scope.init();
        });

        $scope.getOEMInfo = function(sensorId) {
            if (!$scope.locationMappingData || !sensorId)
                return false;
            for (var i = 0; i < $scope.locationMappingData.length; i++) {
                var map = $scope.locationMappingData[i];
                if (map.sensorid == sensorId)
                    return map.parametervalue || "-";
            }
            return sensorId;
        };

        $scope.init = function() {
            $scope.errorChartOptions = {};
            var data = [];
            var total = 0;
            for (var lift in $scope.donutData) {
                data.push({
                    "name": lift + ' (' + $scope.donutData[lift] + ')',
                    "y": $scope.donutData[lift],
                    "color": getColor[lift.trim()]
                });
                total += $scope.donutData[lift];
            }
            $scope.errors = {
                tooltip: {
                    pointFormatter: function() {
                        return '<b>' + this.y + '</b> (' + parseFloat((100 * this.y) / total).toFixed(0) + '%)';
                    },
                    shared: true
                },
                colorByPoint: true,
                data: data
            }
        }

        $scope.init();

    }
]);
smartsenseApp.controller("DMRCWidgetsldController", ['$scope', '$rootScope', 'data', 'local', 'apiService',
    function($scope, $rootScope, data, local, apiService) {

        $scope.localData = local.data;
        $scope.dashboardLocationID = $scope.localData.dashboardLocationID;
        $scope.widget = {};
        $scope.widget.title = $scope.options.title;
        $scope.widget.type = $scope.options.type;
        $scope.widget.tooltip = $scope.options.tooltip;
        $scope.refreshInProgress = false;
        $scope.treeJson = {};

        $scope.listLoaded = false;
        $scope.sldLoaded = false;


        $scope.mapValues = function(location) {

            var values = {
                backup: 0,
                generation: 0,
                consumption: 0
            }

            if (location.sensors) {
                for (var i = 0; i < location.sensors.length; i++) {
                    value = parseFloat(location.sensors[i].value) || 0;
                    sensortypeid = location.sensors[i].sensortypeid;
                    if (sensortypeid == 1001) {
                        values.consumption = values.consumption + value;
                    } else if (sensortypeid == 1002) {
                        values.generation = values.generation + value;
                    } else if (sensortypeid == 1003) {
                        values.backup = values.backup + value;
                    }
                }
            }

            return values;
        }

        $scope.sumTreeValue = function(a, b) {

            var total = {
                backup: a.backup + b.backup,
                consumption: a.consumption + b.consumption,
                generation: a.generation + b.generation,
            };

            return total;
        }

        $scope.getVirtualValue = function(tree) {
            var amount = {
                backup: 0,
                generation: 0,
                consumption: 0
            };
            var child = tree.child;
            if (child) {
                for (var i = 0; i < child.length; i++) {
                    if (child[i].is_virtual) {
                        amount = $scope.sumTreeValue(amount, $scope.getVirtualValue(child[i]));
                    } else {
                        amount = $scope.sumTreeValue(amount, $scope.mapValues(child[i]));
                    }

                }
            }
            return amount;
        }

        $scope.createAssetLocation = function(location) {

            if (!location.isAssetLocationCreated && location.sensors) {
                for (var i = 0; i < location.sensors.length; i++) {
                    sensor = location.sensors[i];
                    value = parseFloat(sensor.value) || 0;
                    sensortypeid = sensor.sensortypeid;
                    if (sensortypeid == 1004) {
                        location.child = location.child || [];
                        sensor.consumption = value;
                        location.child.unshift(sensor);
                    }
                }
            }
            location.isAssetLocationCreated = true;
            return location;
        }

        $scope.traverseForest = function(forest) {
            for (var i = 0; i < forest.length; i++) {

                if (forest[i].is_virtual) {
                    var value = $scope.getVirtualValue(forest[i]);
                    forest[i] = utils.MergeRecursive(forest[i], value);
                }
                if (forest[i].child) {
                    $scope.traverseForest(forest[i].child);
                }
            }
            return forest;
        }

        var readingtypesToShowPercentage = [2001, 2002, 2004, 2008, 2022, 2117];

        $scope.treeOptions = {
            'showPercentage': true
        };

        $scope.readingtype = {};



        $scope.getTree = function() {

            $scope.serverNotRecheable = false;

            var readingtypeid = $scope.options.parameter.readingtypeid;

            if (readingtypesToShowPercentage.indexOf(readingtypeid) < 0) {
                $scope.treeOptions.showPercentage = false;
            }

            var params = {
                fromdate:$scope.localData.dmrc.dateRange.startDate,
                todate:$scope.localData.dmrc.dateRange.endDate,
                readingtypeid:readingtypeid
            }
            $scope.refreshInProgress = true;

            apiService.sld_treeview(params).then(function(response) {
                $scope.refreshInProgress = false;

                if (response) {
                    $scope.readingtype = response.data.readingtype;
                    response.data.data = $scope.traverseForest(response.data.data);
                    $scope.treeJson = utils.prepareTreeData(response.data);
                }

                var params = {
                    readingtypeid: "2846,2847,2848,2849,3010,2880"
                }
                
                apiService.get_sldfordmrc(params).then(function(response) {
                    $scope.readingValue = response.data.data;
                    angular.forEach($scope.readingValue, function(k, v) {
                        if (k[2846] > k[2847]) {
                            if (k[2848] > k[2849]){
                                var variable = "ON"+"&nbsp;&nbsp; <span class='fa fa-arrow-up'></span>";
                            }else{
                                var variable = "ON"+"&nbsp;&nbsp; <span class='fa fa-arrow-down'></span>";
                            }
                        } else {
                            var variable = "OFF";
                        }
                        $("networktreedmrc > div > #locationTreeview > li > ul.filetree > ul > li > div.sensor, networktreedmrc > div > #locationTreeview > li > ul.filetree > ul > li > ul > li >").each(function(key, value){
                            var sensorid = $(this).attr("sensorid").replace(/^,[ ]?|,$/g,'');
                            if(sensorid == v) { 
                                $(this).find(".name > .treeview-data").removeClass("invisible").addClass("consumption").html(variable);
                            }
                        });
                        
                        
                    });

                });

            }, function() {
                $scope.refreshInProgress = false;
                $scope.serverNotRecheable = true;
                
            });
            if(!$scope.localData.sensorHealth) {
                apiService.sensor_health().then(function(response) {
                    $scope.sensorHealth = response.data;
                    $scope.localData.sensorHealth = response.data;
                });
            }

        };


        $scope.$watch('localData.sensorHealth', function(sensorHealth) {
            $scope.sensorHealthData = sensorHealth;
        });


        $scope.showSearchPanel = false;

        $scope.callSerachShow = function(d) {
            $scope.showSearchPanel = true;
        }
        $scope.callSerachHide = function(d) {
            $scope.showSearchPanel = false;
        }



        var colors = {
            '1001': '#2288cc',
            '1002': '#55BF3B',
            '1003': '#807F83',
            '1004': '#22aa99',
            'multi': '#FF9655',
            'virtual': '#886DB3'
        };

        function getColor(point) {
            var color = '';


            if (typeof point.values == 'undefined') {
                return color;
            }
            if (point.is_virtual) {
                color = colors['virtual']
            } else if (Object.keys(point.values).length > 1) {
                color = colors['multi'];
            } else {
                for (key in point.values) {
                    color = colors[key];
                }
            }
            return color;
        }

        function getData(point, unit) {

            var value = null,
            data = '',
            prefix = '',
            suffix = unit,
            valueObject = {};

            if (angular.equals({}, point.values)) {
                data = '-';
            } else {
                for (key in point.values) {
                    value = point.values[key];
                    if (key == 1002) {
                        prefix = 'Green Generation: '
                    } else if (key == 1003) {
                        prefix = 'Backup Generation: ';
                    }
                    if (typeof value == 'undefined' || value === null) {
                        valueObject = {
                            value: '-',
                            unit: unit
                        };
                    } else {
                        valueObject = utils.formatValue(value, suffix);
                    }

                    data = data + prefix + '<b>' + valueObject.value + ' ' + valueObject.unit + '</b><br>';
                }
            }
            return data;
        }

        function formatData(points, unit) {

            points.forEach(function(value, index) {
                points[index].value = 1;
                points[index].color = getColor(value);
                points[index].data = getData(value, unit);
            });

            return points;
        }

        $scope.drawChart = function(points, unit) {

            Highcharts.chart('treeview', {
                tooltip: {
                    enabled: false,
                    // pointFormat: '{point.data}',
                    // valueSuffix: unit
                },
                series: [{
                    type: 'treemap',
                    layoutAlgorithm: 'squarified',
                    allowDrillToNode: true,
                    animationLimit: 1000,
                    dataLabels: {
                        enabled: false
                    },
                    levelIsConstant: false,
                    levels: [{
                        level: 1,
                        dataLabels: {
                            enabled: true,
                            color:'#fff'
                        },
                        borderWidth: 4,
                        color:'#e6e6e6'
                    },{
                        level:2,
                        borderWidth:0.3
                    }],
                    borderWidth:0.2,
                    data: points,
                    states: {
                        hover: {
                            enabled:true,
                            color:'#e6e6e6',
                            borderColor:'#666'
                        }
                    }
                }],
                plotOptions: {
                    treemap: {
                        dataLabels: {
                            style: {
                                lineHeight: '15px',
                                fontSize: '14px'
                            },
                            formatter: function() {
                                return '<b>' + this.point.name + '</b> ' +
                                '<br/>' +
                                '<b>' + this.point.data + '</b> ' +
                                '<br/>';
                            },
                        }
                    }
                },
                subtitle: {
                    text: 'Click points to drill down.'
                },
                title: {
                    text: ''
                }
            });
        }

        $scope.getSLD = function() {

            $scope.refreshInProgress = true;
            $scope.serverNotRecheable = false;

            var params = {
                fromdate:$scope.localData.dmrc.dateRange.startDate,
                todate:$scope.localData.dmrc.dateRange.endDate,
                readingtypeid:$scope.options.parameter.readingtypeid
            }
            apiService.sld_blockview(params).then(function(response) {
                $scope.refreshInProgress = false;
                var unit = response.data.readingtype.unit;
                var points = formatData(response.data.data, unit);
                $scope.drawChart(points);
            }, function() {
                $scope.refreshInProgress = false;
                $scope.serverNotRecheable = true;
            });

        }

        $scope.$watch('viewType', function(newVal, oldVal) {
            if (newVal == 'list' && !$scope.listLoaded) {
                $scope.listLoaded = true;
                $scope.getTree();
            } else if (newVal == 'block' && !$scope.sldLoaded) {
                $scope.sldLoaded = true;
                $scope.getSLD();
            }
        });

        $scope.viewType = 'list';

        $scope.$on('dashboardDateRangeUpdated',function(){
            if($scope.listLoaded) {
                $scope.getTree();
            } 
            if($scope.sldLoaded) {
                $scope.getSLD();
            } 
        });

    }
    ]);
smartsenseApp.controller("DMRCWidgetSummaryOTISController", ['$scope',
    function($scope) {
        $scope.widget = {};
        $scope.widget.title = $scope.options.title;
        $scope.widget.type = $scope.options.type;
        $scope.widget.tooltip = $scope.options.tooltip;
        $scope.$on('dmrcLiftDataLoaded', function(events, data) {
            $scope.dmrcLiftData = data;
            $scope.summary = $scope.dmrcLiftData.makewise.OTIS || {};
            if ($scope.summary.total_appliance) {
                $scope.summary.perc = (100 * $scope.summary.number_of_appliance_reported_error) / $scope.summary.total_appliance;
            } else {
                $scope.summary.perc = 0;
            }
            $scope.summary.total_appliance = $scope.summary.total_appliance || 0;
            $scope.summary.number_of_appliance_reported_error = $scope.summary.number_of_appliance_reported_error || 0;
            $scope.summary.total_errors_reported = $scope.summary.total_errors_reported || 0;
        });
    }
]);
smartsenseApp.controller("DMRCWidgetSummaryJohnsonController", ['$scope',
    function($scope) {
        $scope.widget = {};
        $scope.widget.title = $scope.options.title;
        $scope.widget.type = $scope.options.type;
        $scope.widget.tooltip = $scope.options.tooltip;
        $scope.$on('dmrcLiftDataLoaded', function(events, data) {
            $scope.dmrcLiftData = data;
            $scope.summary = $scope.dmrcLiftData.makewise.Johnson || {};
            if ($scope.summary.total_appliance) {
                $scope.summary.perc = (100 * $scope.summary.number_of_appliance_reported_error) / $scope.summary.total_appliance;
            } else {
                $scope.summary.perc = 0;
            }
            $scope.summary.total_appliance = $scope.summary.total_appliance || 0;
            $scope.summary.number_of_appliance_reported_error = $scope.summary.number_of_appliance_reported_error || 0;
            $scope.summary.total_errors_reported = $scope.summary.total_errors_reported || 0;
        });
    }
]);
smartsenseApp.controller("DMRCWidgetSummaryKoneController", ['$scope',
    function($scope) {
        $scope.widget = {};
        $scope.widget.title = $scope.options.title;
        $scope.widget.type = $scope.options.type;
        $scope.widget.tooltip = $scope.options.tooltip;
        $scope.$on('dmrcLiftDataLoaded', function(events, data) {
            $scope.dmrcLiftData = data;
            $scope.summary = $scope.dmrcLiftData.makewise.KONE || {};
            if ($scope.summary.total_appliance) {
                $scope.summary.perc = (100 * $scope.summary.number_of_appliance_reported_error) / $scope.summary.total_appliance;
            } else {
                $scope.summary.perc = 0;
            }
            $scope.summary.total_appliance = $scope.summary.total_appliance || 0;
            $scope.summary.number_of_appliance_reported_error = $scope.summary.number_of_appliance_reported_error || 0;
            $scope.summary.total_errors_reported = $scope.summary.total_errors_reported || 0;
        });
    }
]);
smartsenseApp.controller("DMRCWidgetSkyviewController", ['$scope', '$rootScope', '$filter', '$timeout', 'local', 'googleMapReady', 'apiService', 'data', '$location',
    function($scope, $rootScope, $filter, $timeout, local, googleMapReady, apiService, data, $location) {

        $scope.localData = local.data;

        $scope.widget = {};
        $scope.widget.title = $scope.options.title;
        $scope.widget.tooltip = $scope.options.tooltip;

        $scope.map = null;
        $scope.markers = [];
        $scope.currentMarker = {};
        $scope.scrollwheel = false;

        // Specify features and elements to define styles.
        var mapStyle = [{
            "featureType": "administrative",
            "elementType": "labels.text.fill",
            "stylers": [{
                "color": "#3e4a58"
            }]
        }, {
            "featureType": "landscape",
            "elementType": "all",
            "stylers": [{
                "color": "#f2f2f2"
            }]
        }, {
            "featureType": "poi",
            "elementType": "all",
            "stylers": [{
                "visibility": "off"
            }]
        }, {
            "featureType": "road",
            "elementType": "all",
            "stylers": [{
                "saturation": -100
            }, {
                "lightness": 45
            }]
        }, {
            "featureType": "road.highway",
            "elementType": "all",
            "stylers": [{
                "visibility": "simplified"
            }]
        }, {
            "featureType": "road.arterial",
            "elementType": "labels.icon",
            "stylers": [{
                "visibility": "off"
            }]
        }, {
            "featureType": "transit",
            "elementType": "all",
            "stylers": [{
                "visibility": "off"
            }]
        }, {
            "featureType": "water",
            "elementType": "all",
            "stylers": [{
                "color": "#437ede"
            }, {
                "visibility": "on"
            }]
        }];

        // http://jsfiddle.net/Wijmo/Rqcsj/
        $scope.refreshInProgress = true;

        $scope.selectLocation = function(locationids) {
            var startDate = $scope.localData.dmrc.startDate;
            var endDate = $scope.localData.dmrc.dateRange.endDate;
            apiService.gis_widget_dmrc(startDate, endDate, locationids)
                .success(function(data) {
                    $scope.list = data;
                })
                .error(function(error) {
                    $scope.serverNotRecheable = true;
                });
        }

        $scope.gmap_createMarkers = function() {
            var markers = [];
            angular.forEach($scope.localData.member_locations, function(location) {
                var pos = {
                    lat: location.clientid.addressid.latitude,
                    lng: location.clientid.addressid.longitude
                };
                pos = convertToDD(pos);
                var isMarkerExist = $scope.getByLatLng(pos.lat, pos.lng, markers);
                if (!isMarkerExist) {
                    markers.push({
                        pos: pos,
                        latlng: new google.maps.LatLng(pos.lat, pos.lng),
                        plants: [{
                            name: location.name,
                            client: location.clientid.clientname,
                            address: location.clientid.addressid.addressline1
                        }]
                    });
                } else {
                    var index = markers.indexOf(isMarkerExist);
                    markers[index].plants.push({
                        name: location.name,
                        client: location.clientid.clientname,
                        address: location.clientid.addressid.addressline1
                    });
                }
            });
            $scope.markers = markers;
            $scope.setBound();
        }

        $scope.init = function() {
            var options = {
                center: new google.maps.LatLng(28, 77),
                scrollwheel: false,
                zoom: 6,
                styles: mapStyle
            };
            // create the map
            $scope.map = new google.maps.Map(document.getElementById('map'), options);
            $scope.ctaLayer = new google.maps.KmlLayer({
                url: 'http://server2.smartsen.se/assets/kml/ecolibrium.kml',
                map: $scope.map
            });
            $scope.gmap_createMarkers();
            apiService.get_location_with_geo().then(function(response) {
                var locationids = [];
                angular.forEach(response.data, function(value, key) {
                    if (value.latitude != null && value.longitude != null) {
                        locationids.push(value.locationid)
                        var marker = new google.maps.Marker({
                            position: new google.maps.LatLng(value.latitude, value.longitude),
                            map: $scope.map,
                            location: value
                        });
                        google.maps.event.addListener(marker, 'click', function() {
                            $scope.selectLocation(value.locationid);
                        });
                    }
                });
                var locationids = locationids.toString();
                $scope.selectLocation(locationids)
            }, function() {
                $scope.refreshInProgress = false;
                $scope.serverNotRecheable = true;
            });
        }

        $scope.scrollwheelChange = function() {
            $scope.map.setOptions({
                scrollwheel: $scope.scrollwheel
            });
        }

        /* Get marker by latitude and longitude */
        $scope.getByLatLng = function(lat, lng, markers) {
            return $filter('filter')(markers, function(marker) {
                return marker.pos.lat == lat && marker.pos.lng == lng;
            })[0];
        }

        $scope.setBound = function() {
            var markers = $scope.markers;
            var bounds = new google.maps.LatLngBounds();
            angular.forEach(markers, function(marker, key) {
                bounds.extend(marker.latlng);
            });
            $scope.map.setCenter(bounds.getCenter());
            var numberOfMarkers = markers.length;
            if (numberOfMarkers == 1) {
                $scope.map.setZoom(11);
            } else {
                $scope.map.fitBounds(bounds);
            }
        }

        googleMapReady.ready().then(function() {
            $scope.init();
        });

        $scope.reset = function() {
            $scope.init();
        }

    }
]);
smartsenseApp.controller('AnalyseController', AnalyseController);
AnalyseController.$inject = ['$scope', 'apiService', 'local', 'grainService','highchartService', 'loading','$uibModalInstance'];

function AnalyseController($scope, apiService, local, grainService, highchartService, loading, $uibModalInstance) {

    $scope.localData = local.data;
    $scope.isLoading = {analyse:false};
    $scope.axises = [{
        label:'Y Axis',
        value:'y'
    },{
        label:'X Axis',
        value:'x'
    }];

    $scope.groups = [{
        label:'Day',
        unit:'days',
        startOf:'day',
        value:1,
    },{
        label:'Week',
        unit:'weeks',
        startOf:'week',
        value:1,
    },{
        label:'Month',
        unit:'months',
        startOf:'month',
        value:1,
    }];

    $scope.date_formats = {
        'hours':'LT',
        'days':'MMM Do',
        'weeks':'MMM Do',
        'months':'MMMM'
    }

    $scope.graphTypes = [{
        label:'Default',
        value:null
    },{
        label:'Line',
        value:'line'
    },{
        label:'Area',
        value:'area'
    },{
        label:'Bar',
        value:'column'
    },{
        label:'Scatter',
        value:'scatter'
    }];

    $scope.analyseTypes = [{
        label:'General',
        value:'general',
        parameterLimit:8
    },{
        label:'Parameter vs Parameter',
        value:'parameter',
        parameterLimit:2
    }
    ,{
        label:'Time vs Time',
        value:'time',
        parameterLimit:1
    }
    ];

    $scope.generalAnalyseParameterLimit = 8;

    $scope.grains = grainService.get();

    $scope.groupLocation = function (item){
        if (item.parentlocationid && $scope.localData.locations[item.parentlocationid]) {
            return $scope.localData.locations[item.parentlocationid].name;
        } else {
            return 'Main Locations';
        }
    };

    $scope.groupParameter = function (item){
        if (item.parentreadingtypeid && $scope.localData.readingtypes[item.parentreadingtypeid]) {
            return $scope.localData.readingtypes[item.parentreadingtypeid].readingtypename;
        } else {
            return undefined;
        }
    };

    $scope.dateRangeOpts = {
        locale: {
            fromLabel: "From",
            format: 'MMMM D, YYYY',
            toLabel: "To",
            customRangeLabel: 'Custom Range'
        },
        opens: "up",
        autoApply: true,
        maxDate: new Date(),
        ranges: {
            'Today': [moment().startOf('day'), moment()],
            'Last 7 Days': [moment().subtract(6, 'days'), moment()],
            'Last 30 Days': [moment().subtract(29, 'days'), moment()],
            'Last 3 months': [moment().subtract(2, 'months').startOf('month'), moment()],
            'Last 6 months': [moment().subtract(5, 'months').startOf('month'), moment()],
            'Last 12 Months': [moment().subtract(1, 'year').startOf('month'), moment()],
            'This Year': [moment([moment().year()]), moment()]
        }
    };

    // Graph Options for Vanilla graph ( Parameter vs Parameter & Time vs Time)
    var defaultGraphOptions = {
        chart: {
            height: 400,
            type:'scatter'
        },
        plotOptions: {
            series:{
                turboThreshold: 300000
            },
            scatter: {
                marker: {
                    radius: 2
                }
            }
        }
    }

    var subUnits = {
        'months':{unit:'Day',count:31,minutes:1440,dateTimeLabelFormats: {
            hour: '%H:%M',
            day: 'Day %e',
            week: '%e. %b',
            month: 'Day %e',
            year: 'Day %e'
        }},
        'weeks':{unit:'Day',count:6,minutes:1440,dateTimeLabelFormats: {
            hour: '%H:%M',
            day: 'Day %u',
            month: 'Day %u',
            year: 'Day %u'
        }},
        'days':{unit:'Hour',count:24,minutes:60,dateTimeLabelFormats: {
            day: '%H:%M',
            week: '%H:%M',
            month: '%H:%M',
            year: '%H:%M'
        }}
    };

    $scope.graphs = {
        'general':{
            data:[],
            options:{}
        },
        'time':highchartService.TimevsTimeConfig(),
        'parameter':highchartService.XvsYConfig(),
    }

    $scope.analyse = {
        grain:angular.copy($scope.grains[0]),
        group:angular.copy($scope.groups[0]),
        graphType:angular.copy($scope.graphTypes[0].value),
        analyseType:angular.copy($scope.analyseTypes[0]),
        dateRange:{
            startDate: moment().subtract(6, 'days').startOf('day'),
            endDate: moment()
        },
        parameters:{
            'general':[{
                location:null,
                readingtype:null,
                sensortypeid:'1001'
            }],
            'parameter':[{
                location:null,
                readingtype:null,
                sensortypeid:null
            },{
                location:null,
                readingtype:null,
                sensortypeid:null
            }],
            'time':[{
                location:null,
                readingtype:null,
                sensortypeid:null
            }]
        },
        resultParameters:new Array()
    }

    $scope.getNumber = function(num) {
        return new Array(num);   
    }

    $scope.addParameter = function() {
        $scope.analyse.parameters.general.push({
            location:null,
            readingtype:null,
            sensortypeid:null
        });
    }

    $scope.deleteParameter = function(parameter) {
        var index = $scope.analyse.parameters.general.indexOf(parameter);
        if(index > -1) {
            $scope.analyse.parameters.general.splice(index, 1);
        }
    }

    $scope.getReadingSeries = function(parameter) {
        var params = {
            fromdate:$scope.analyse.dateRange.startDate,
            todate:$scope.analyse.dateRange.endDate,
            grain:$scope.analyse.grain.value,
            readingtypeid:parameter.readingtype.readingtypeid,
            locationid:parameter.location.locationid
        }
        if((!parameter.location.locationid || parameter.location.virtual) && parameter.sensortypeid) {
            params.sensortypeid = parameter.sensortypeid;
        }
        return apiService.reading_series(params);
    }

    var graphCounter = 0;

    $scope.getData = function(parameter, index) {
        $scope.getReadingSeries(parameter).then(function(response) {
            data = response.data[0];
            $scope.analyse.resultParameters[index].timeseries = data.timeseries;
            $scope.analyse.resultParameters[index].id = graphCounter;
            $scope.updateCounter();
        }, function() {
            $scope.updateCounter();
        });
    }

    $scope.updateCounter = function() {
        graphCounter++;
        if(graphCounter && graphCounter==$scope.analyse.resultParameters.length) {
            $scope.showGraph = true;
            $scope.drawGraph();
            $scope.isLoading.analyse = false;
        } else {
            $scope.showGraph = false;
        }
    }

    $scope.drawGraph = function() {
        if($scope.analyse.analyseType.value == 'general') {
            $scope.drawGeneralGraph();
        } else if($scope.analyse.analyseType.value == 'parameter') {
            $scope.drawXvsYGraph();
        } else if ($scope.analyse.analyseType.value == 'time') {
            $scope.drawTimevsTimeGraph();
        }
    }

    function intersection(o1, o2) {
        return Object.keys(o1).filter({}.hasOwnProperty.bind(o2));
    }

    $scope.drawXvsYGraph = function() {
        $scope.graphs.parameter.series = [];
        $scope.graphs.parameter.loading = true;
        // Get grain in seconds
        var grain = $scope.analyse.grain.value*60;
        // Get group in seconds
        var group = $scope.analyse.group.value*60;
        var epoch = {
            start:$scope.analyse.dateRange.startDate.valueOf()/1000,
            end:$scope.analyse.dateRange.endDate.valueOf()/1000
        }
        var timeseries = {};
        for(var i=epoch.start;i<=epoch.end;i=i+grain) {
            timeseries[i] = {count:0}
        }
        angular.forEach($scope.analyse.resultParameters, function(parameter, index) {
            var axis = index ? 'y':'x';
            $scope.graphs.parameter.options[axis+"Axis"] = {
                title:{
                    text:parameter.readingtype.readingtypename
                }
            };
            angular.forEach(parameter.timeseries,function(item){
                try {
                    timeseries[item.timeStamp][axis] = item.value;
                    timeseries[item.timeStamp].count++;
                } catch(err){
                    console.log(err,item.timeStamp);
                }
            });
        });

        var dateRanges = [];
        // Form dataranges from daterange and group
        var d = $scope.analyse.dateRange.startDate.clone();
        for(;d<=$scope.analyse.dateRange.endDate;d.startOf($scope.analyse.group.startOf).add($scope.analyse.group.value,$scope.analyse.group.unit)) {
            dateRanges.push({
                start:d.clone().startOf($scope.analyse.group.startOf).valueOf()/1000,
                end:d.clone().endOf($scope.analyse.group.startOf).valueOf()/1000,
                label:d.format($scope.date_formats[$scope.analyse.group.unit])
            });
        }

        var serieses = [];
        dateRanges.forEach(function(dateRange){
            var data = [];
            for(var i=dateRange.start;i<dateRange.end;i=i+grain){
                if(timeseries.hasOwnProperty(i) && timeseries[i].count==2){
                    data.push([timeseries[i].x,timeseries[i].y]);
                }
            }
            data = data.sort(function(a,b) {
                if (a[0] < b[0])
                    return -1;
                if (a[0] > b[0])
                    return 1;
                return 0;
            })
            $scope.graphs.parameter.series.push({
                name:dateRange.label,
                data:data,
                marker:{
                    symbol:'circle'
                }
            });
        });
        $scope.graphs.parameter.options.chart.type = $scope.analyse.graphType?$scope.analyse.graphType:'scatter';
        $scope.graphs.parameter.loading = false;
    }

    

    $scope.drawTimevsTimeGraph = function() {
        $scope.graphs.time.series = [];
        $scope.graphs.time.loading = true;
        // Get grain in seconds
        var grain = $scope.analyse.grain.value*60;
        // Get group in seconds
        var group = $scope.analyse.group.value*60;
        var epoch = {
            start:$scope.analyse.dateRange.startDate.valueOf()/1000,
            end:$scope.analyse.dateRange.endDate.valueOf()/1000
        }
        var timeseries = {};
        for(var i=epoch.start;i<=epoch.end;i=i+grain) {
            timeseries[i] = null;
        }
        angular.forEach($scope.analyse.resultParameters[0].timeseries,function(item){
            try {
                timeseries[item.timeStamp] = item.value;
            } catch(err){
                console.log(err,item.timeStamp);
            }
        });
        var dateRanges = [];
        // Form dataranges from daterange and group
        var d = $scope.analyse.dateRange.startDate.clone();
        for(;d<$scope.analyse.dateRange.endDate;d.startOf($scope.analyse.group.startOf).add($scope.analyse.group.value,$scope.analyse.group.unit)) {
            dateRanges.push({
                start:d.clone().startOf($scope.analyse.group.startOf).valueOf()/1000,
                end:d.clone().endOf($scope.analyse.group.startOf).valueOf()/1000,
                label:d.format($scope.date_formats[$scope.analyse.group.unit])
            });
        }
        dateRanges.forEach(function(dateRange,index){
            var data = [];
            for(var i=dateRange.start;i<dateRange.end;i=i+grain){
                data.push({x:moment(i*1000).subtract(index,$scope.analyse.group.unit).valueOf(),y:timeseries[i]});
            }
            $scope.graphs.time.series.push({
                name:dateRange.label,
                data:data
            });
        });
        $scope.graphs.time.options.xAxis.dateTimeLabelFormats = subUnits[$scope.analyse.group.unit].dateTimeLabelFormats;
        $scope.graphs.time.options.tooltip.dateTimeLabelFormats = subUnits[$scope.analyse.group.unit].dateTimeLabelFormats;
        $scope.graphs.time.options.chart.type = $scope.analyse.graphType?$scope.analyse.graphType:'scatter';
        $scope.graphs.time.loading = false;
    }

    $scope.drawGeneralGraph = function() {
        $scope.graphs.general.data = [];
        angular.forEach($scope.analyse.resultParameters, function(parameter, index) {
            var readingtype = parameter.readingtype;
            var unit = readingtype.unit;
            var series = {
                name:parameter.readingtype.readingtypename+' - '+parameter.location.name,
                timeSeries: parameter.timeseries,
                readingtype: readingtype,
                id: index,
                type: $scope.analyse.graphType
            }
            if(unit.toLowerCase() != readingtype.readingtypename.toLowerCase()) {
                series.unit = readingtype.unit;
            }
            $scope.graphs.general.data.push(series);
        });
    }

    $scope.doAnalyse = function() {
        graphCounter = 0;
        $scope.isLoading.analyse = true;
        $scope.analyse.resultParameters = angular.copy($scope.analyse.parameters[$scope.analyse.analyseType.value]);
        if($scope.analyse.resultParameters.length>$scope.analyse.analyseType.parameterLimit) {
            $scope.analyse.resultParameters = $scope.analyse.resultParameters.slice(0,$scope.analyse.analyseType.parameterLimit);
        }
        angular.forEach($scope.analyse.resultParameters, function(parameter, index) {
            $scope.getData(parameter, index);
        });
    }

    $scope.cancel = function () {
        $uibModalInstance.dismiss('cancel');
    };

}
smartsenseApp.controller('TermsModalController', TermsModalController);

TermsModalController.$inject = ['$rootScope', '$scope', 'apiService', 'Session'];

function TermsModalController($rootScope, $scope, apiService, Session) {
    $scope.btn = {isselected: false};
    $scope.accept = function () {
        apiService.member_tc_accept().then(function(response) {
            var member = Session.get('member');
            member.isTcAccepted = true;
            Session.put('member',member);
            $rootScope.modalInstance.dismiss('cancel');
        });
    };

    $scope.cancel = function () {
        $rootScope.modalInstance.dismiss('cancel');
        $rootScope.$emit('doLogout');
    };

}
smartsenseApp.controller("DashboardWidgetDigitController", ['$scope', 'apiService', function($scope, apiService) {

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    }

    $scope.getValue = function(parameter, index) {
        var params = {
            locationid: parameter.locationid,
            readingtypeid: parameter.readingtypeid,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            sensortypeid: parameter.sensortypeid
        }
        $scope.options.config.parameters[index].isLoading = true;
        $scope.options.config.parameters[index].data = {};
        apiService.reading_value(params).then(function(data) {
            var unit = data.data.readingtype.unit;
            $scope.options.config.parameters[index].isLoading = false;
            $scope.options.config.parameters[index].data = utils.formatValue(data.data.value, unit);
        }, function(error) {});
    }

    $scope.init = function() {
        angular.forEach($scope.options.config.parameters, function(parameter, index) {
            $scope.getValue(parameter, index);
        });
    }

    $scope.init();

}]);
smartsenseApp.controller("DashboardWidgetDigit2Controller", ['$scope', 'apiService', function($scope, apiService) {

    $scope.config = $scope.options.config;

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    }

    $scope.isLoading = {
        value: false,
        trend: false,
        live: false,
        cost: false
    };

    $scope.parameters = $scope.config.parameters;
    $scope.cost_enabled = $scope.config.cost.enabled;

    $scope.getValue = function() {
        $scope.isLoading.value = true;
        $scope.value = {};
        var params = {
            locationid: $scope.parameters.value.locationid,
            readingtypeid: $scope.parameters.value.readingtypeid,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            sensortypeid: $scope.parameters.value.sensortypeid
        }
        apiService.reading_value(params).then(function(response) {
            $scope.isLoading.value = false;
            var unit = response.data.readingtype.unit;
            $scope.value = utils.formatValue(response.data.value, unit);
            if ($scope.config.cost.unitrate) {
                var cost = $scope.config.cost.unitrate * response.data.value;
                $scope.cost = utils.formatCurrency(cost.toFixed(2), false, false);
            }
        }, function(error) {
            $scope.isLoading.value = false;
        });
    }

    $scope.getLive = function() {
        $scope.isLoading.live = true;
        $scope.live = {};
        var params = {
            locationid: $scope.parameters.live.locationid,
            readingtypeid: $scope.parameters.live.readingtypeid,
            sensortypeid: $scope.parameters.live.sensortypeid
        }
        apiService.reading_live(params).then(function(response) {
            $scope.readingtype = response.data.readingtype;
            var unit = $scope.readingtype.unit;
            if ($scope.readingtype.timebased) {
                $scope.live = utils.formatNumber(response.data.value);
            } else {
                $scope.live = utils.formatValue(response.data.value, unit);
            }
            $scope.isLoading.live = false;
        }, function(error) {
            $scope.isLoading.live = false;
        });

    }

    $scope.getTrend = function() {
        $scope.graphData = [];
        $scope.isLoading.trend = true;
        var startDateTrend = moment().subtract(29, 'days').set({
                hour: 0,
                minute: 0,
                second: 0,
                millisecond: 0
            }),
            endDateTrend = moment();
        var params = {
            locationid: $scope.parameters.trend.locationid,
            readingtypeid: $scope.parameters.trend.readingtypeid,
            sensortypeid: $scope.parameters.trend.sensortypeid,
            fromdate: startDateTrend,
            todate: endDateTrend,
            grain: 1440
        }
        apiService.reading_series(params).then(function(response) {
            $scope.isLoading.trend = false;
            var series = response.data[0];
            var unit = series.readingtype.unit;
            angular.forEach(series.timeseries, function(point) {
                var value = utils.formatValue(point.value, unit);
                $scope.graphData.push({
                    y: point.value,
                    value: value.value,
                    suffix: value.unit,
                    x: point.timeStamp * 1000
                });
            });
            $('[data-toggle="tooltip"]').tooltip();
        }, function(error) {
            $scope.isLoading.trend = false;
        });
    }


    $scope.getCost = function() {
        $scope.isLoading.cost = true;

        var params = {
            locationid: $scope.parameters.value.locationid,
            readingtypeid: $scope.parameters.value.readingtypeid,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            sensortypeid: $scope.parameters.value.sensortypeid
        }
        apiService.unitcost(params).then(function(response) {
            $scope.isLoading.cost = false;
            $scope.cost = utils.formatCurrency(response.data.cost.toFixed(2), false, false);
        }, function(error) {
            $scope.isLoading.cost = false;
        });
    }

    $scope.getCostOrTrend = function() {
        if ($scope.cost_enabled) {
            if (!$scope.config.cost.unitrate) {
                $scope.getCost();
            }
        } else {
            $scope.getTrend();
        }
    }

    $scope.init = function() {
        $scope.isLoading = {
            value: false,
            trend: false,
            live: false,
            cost: false
        };
        $scope.getValue();
        $scope.getLive();
        $scope.getCostOrTrend();
    }

    $scope.init();

}]);
smartsenseApp.controller("DashboardWidgetDigit3Controller", ['$scope', 'apiService', function($scope, apiService) {

    $scope.config = $scope.options.config;

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    };

    $scope.isLoading = {
        value: false,
        minmax: false
    };

    $scope.parameter = $scope.config.parameters[0];

    $scope.getValue = function() {
        $scope.isLoading.value = true;
        $scope.value = {};
        var params = {
            locationid: $scope.parameter.locationid,
            readingtypeid: $scope.parameter.readingtypeid,
            sensortypeid: $scope.parameter.sensortypeid,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate
        }
        apiService.reading_value(params).then(function(response) {
            $scope.isLoading.value = false;
            var unit = response.data.readingtype.unit;
            $scope.value = utils.formatValue(response.data.value, unit);
        }, function(error) {
            $scope.isLoading.value = false;
        });
    }

    $scope.getMinMax = function() {
        $scope.maxDemand = null;
        $scope.minDemand = null;
        $scope.maxDemandDate = null;
        $scope.minDemandDate = null;
        $scope.isLoading.minmax = true;

        var startDate = moment($scope.dateRange.startDate);
        var endDateMinute = $scope.dateRange.endDate.minute();
        var endDateMinuteSlot = endDateMinute - endDateMinute % 15;
        var endDate = moment($scope.dateRange.endDate).minute(endDateMinuteSlot).seconds(0);

        var params = {
            locationid: $scope.parameter.locationid,
            readingtypeid: $scope.parameter.readingtypeid,
            sensortypeid: $scope.parameter.sensortypeid,
            fromdate: startDate,
            todate: endDate,
            grain: 15
        }

        apiService.reading_series(params).then(function(response) {
            $scope.isLoading.minmax = false;
            var series = response.data[0];
            var unit = series.readingtype.unit;
            series.timeseries.sort(function(a, b) {
                return (a.timeStamp > b.timeStamp) ? 1 : ((b.timeStamp > a.timeStamp) ? -1 : 0);
            });
            var max, min, maxOnDate, minOnDate;
            for (var i = 0; i < series.timeseries.length; i++) {
                var curData = series.timeseries[i];
                if (!max) {
                    max = curData.value;
                    maxOnDate = curData.timeStamp;
                }
                if (!min) {
                    min = curData.value;
                    minOnDate = curData.timeStamp;
                }
                if (curData.value > max) {
                    max = curData.value;
                    maxOnDate = curData.timeStamp;
                }
                if (curData.value < min) {
                    min = curData.value;
                    minOnDate = curData.timeStamp;
                }
            }
            $scope.maxDemand = utils.formatValue(max, unit);
            $scope.minDemand = utils.formatValue(min, unit);
            if (maxOnDate) {
                var maxDate = new Date(parseInt(maxOnDate + "000"));
                $scope.maxDemandDate = moment(maxDate).format("DD MMM, 'YY HH:mm");
            }
            if (minOnDate) {
                var minDate = new Date(parseInt(minOnDate + "000"));
                $scope.minDemandDate = moment(minDate).format("DD MMM, 'YY HH:mm");
            }
            $('[data-toggle="tooltip"]').tooltip();
        }, function(error) {
            $scope.isLoading.minmax = false;
        });
    }

    $scope.init = function() {
        $scope.isLoading = {
            value: false,
            minmax: false,
        };
        $scope.getValue();
        $scope.getMinMax();
    }

    $scope.init();

}]);
smartsenseApp.controller("DashboardWidgetGraphController", ['$scope', 'local', 'grainService', 'apiService', function($scope, local, grainService, apiService) {

        $scope.localData = local.data;

        $scope.dateRange = {
            startDate: moment($scope.options.config.dateRange.startDate),
            endDate: moment($scope.options.config.dateRange.endDate)
        };

        $scope.isFull = $scope.options.config.class == 'col-lg-12 col-md-12 col-sm-12 col-xs-12';

        $scope.graphOptions = {
            yAxisOptions: {}
        };

        if (!$scope.isFull) {
            $scope.graphOptions['chart'] = {
                'height': 220
            };
        }

        if ($scope.options.config.stacked) {
            $scope.graphOptions.plotOptions = {
                series: {
                    stacking: 'normal'
                }
            };
        }

        if (utils.isInt($scope.options.config.min)) {
            $scope.graphOptions.yAxisOptions.min = $scope.options.config.min;
        }

        if (utils.isInt($scope.options.config.max)) {
            $scope.graphOptions.yAxisOptions.max = $scope.options.config.max;
        }
        var grain = angular.copy($scope.options.config.grain);

        $scope.getGrain = function(startDate, endDate) {
            var grainObj = grainService.getFirst(moment(startDate), moment(endDate));
            if (grainObj.value <= grain) {
                return grain;
            }
            return grainObj.value;
        }

        $scope.getSeries = function(parameter, index) {
            var params = {
                locationid: parameter.locationid,
                readingtypeid: parameter.readingtypeid,
                grain: $scope.getGrain($scope.dateRange.startDate, $scope.dateRange.endDate),
                fromdate: $scope.dateRange.startDate,
                todate: $scope.dateRange.endDate,
                sensortypeid: parameter.sensortypeid
            }
            apiService.reading_series(params).then(function(response) {
                angular.forEach(response.data, function(seriesData) {
                    var readingtype = seriesData.readingtype;
                    var name = parameter.alias;
                    var series = {
                        name: parameter.alias,
                        timeSeries: seriesData.timeseries,
                        readingtype: readingtype,
                        _colorIndex: index,
                        stack: $scope.options.config.stacked ? readingtype.readingtypeid : index,
                        unit: readingtype.unit,
                        plotLines: []
                    }
                    if (utils.isNumeric(parameter['line_value'])) {
                        series.plotLines.push({
                            value: parameter['line_value'],
                            color: '#FF0000',
                            dashStyle: 'longdashdot',
                            width: 2,
                            label: {
                                text: parameter['line_label'] + " - " + parameter['line_value']
                            },
                            id: index,
                            zIndex: 5
                        });
                    }
                    $scope.graphData.push(series);
                });
            }, function(error) {});
        }

        $scope.getComputedSeries = function(computed_parameter, index) {
            var params = {
                grain: $scope.getGrain($scope.dateRange.startDate, $scope.dateRange.endDate),
                fromdate: $scope.dateRange.startDate,
                todate: $scope.dateRange.endDate,
                computed_parameter: computed_parameter
            }
            apiService.reading_computed(params).then(function(response) {
                var series = {
                    name: computed_parameter['alias'],
                    type: computed_parameter['type'] || 'area',
                    timeSeries: response.data,
                    _colorIndex: index,
                    stack: index,
                    unit: computed_parameter['unit'],
                    plotLines: []
                }
                if ($scope.options.config.stacked) {
                    series.stack = 1;
                    series.readingtype = {
                        readingtypeid: 1,
                        readingtypename: '',
                        unit: computed_parameter['unit']
                    }
                }
                if (['>', '<', '==', '!='].some(function(v) { return computed_parameter.formulaToParse.indexOf(v) >= 0; })) {
                    series.tooltip = {
                        pointFormatter: function() {
                            var name = this.series.name || "";
                            var value = parseInt(this.y);
                            if (value) {
                                value = 'On';
                            } else {
                                value = 'Off';
                            }
                            var color = this.series.options.color;
                            return '<span style="color:' + color + '">\u25CF</span> ' + name + ': <b>' + value + '</b> <br/>';
                        },
                        shared: true
                    }
                    if ($scope.options.config.stacked) {
                        series.readingtype.readingtypename = 'Count';
                    }
                }

                if (utils.isInt(computed_parameter['line_value'])) {
                    series.plotLines.push({
                        value: computed_parameter['line_value'],
                        color: '#FF0000',
                        dashStyle: 'longdashdot',
                        width: 2,
                        label: {
                            text: computed_parameter['line_label'] + " - " + computed_parameter['line_value']
                        },
                        zIndex: 5
                    });
                }
                $scope.graphData.push(series);
            }, function(error) {});
        }

        $scope.init = function() {
            $scope.graphData = [];
            if ($scope.options.config.is_computed) {
                angular.forEach($scope.options.config.computed_parameters, function(computed_parameter, index) {
                    $scope.getComputedSeries(computed_parameter, index);
                });
            } else {
                angular.forEach($scope.options.config.parameters, function(parameter, index) {
                    $scope.getSeries(parameter, index);
                });
            }
        }

        $scope.init();
    }

]);
smartsenseApp.controller("DashboardWidgetTableController", ['$scope', 'local', 'grainService', 'apiService', function($scope, local, grainService, apiService) {

    $scope.localData = local.data;
    $scope.isFull = $scope.options.config.class == 'col-lg-12 col-md-12 col-sm-12 col-xs-12';

    $scope.cells = {};

    angular.forEach($scope.options.config.cells, function(item, index) {
        $scope.cells[item.row] = $scope.cells[item.row] || {};
        $scope.cells[item.row][item.col] = item;
    });

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    }

    $scope.getReadingData = function(cell) {
        var params = {
            locationid: cell.parameter.locationid,
            readingtypeid: cell.parameter.readingtypeid,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            sensortypeid: cell.parameter.sensortypeid
        }
        $scope.cells[cell.row][cell.col].isLoading = true;
        apiService.reading_value(params)
            .success(function(data) {
                $scope.cells[cell.row][cell.col].value = data.value;
                var unit = cell.unit || $scope.localData.readingtypes[cell.parameter.readingtypeid].unit;
                $scope.cells[cell.row][cell.col].unit = unit;
            })
            .catch(function(error) {})
            .finally(function() {
                $scope.cells[cell.row][cell.col].isLoading = false;
            });
    }

    $scope.getReadingComputedData = function(cell) {
        var params = {
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            computed_parameter: cell.computed_parameter
        }
        $scope.cells[cell.row][cell.col].isLoading = true;
        apiService.reading_computed_data(params)
            .success(function(data) {
                $scope.cells[cell.row][cell.col].value = data;
            })
            .catch(function(error) {})
            .finally(function() {
                $scope.cells[cell.row][cell.col].isLoading = false;
            });
    }

    $scope.init = function() {
        angular.forEach($scope.cells, function(tr) {
            angular.forEach(tr, function(td) {
                if (td.is_computed) {
                    $scope.getReadingComputedData(td);
                } else {
                    $scope.getReadingData(td);
                }
            });
        });
    }

    $scope.init();

}]);
smartsenseApp.controller("DashboardWidgetHeatmapController", ['$scope', 'apiService', function($scope, apiService) {


    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    };

    $scope.unit = '';
    $scope.readingtypename = '';

    var grain = $scope.options.config.grain;
    $scope.highcharts = {
        options: {
            xAxis: {},
            yAxis: {
                min: 0,
                max: (60 * 24 / grain - 1)
            },
            colorAxis: {}
        },
        data: []
    }


    $scope.setColorAxis = function() {
        if ($scope.options.config.heatmap.min) {
            $scope.highcharts.options.colorAxis.min = $scope.options.config.heatmap.min;
        }
        if ($scope.options.config.heatmap.max) {
            $scope.highcharts.options.colorAxis.max = $scope.options.config.heatmap.max;
        }
    }

    $scope.setMinMax = function(colorAxis) {
        $scope.highcharts.options.colorAxis = angular.copy(colorAxis);
    }

    $scope.setColorAxis();

    $scope.formatData = function(fromdate, todate, grain, series, unit) {

        var dataArray = [],
            seriesObject = {},
            seriesLength = series.length,
            i, dayCounter = 0;

        for (i = 0; i < seriesLength; i++) {
            seriesObject[series[i].timeStamp * 1000] = series[i].value;
        }

        var dataPoint;
        // If you want an inclusive end date (fully-closed interval)
        for (var m = moment(fromdate); m <= todate; m.add(1, 'days')) {

            var start = moment(m).startOf('day');
            var end = moment(m).endOf('day');
            var slotCounter = 0;

            for (var i = moment(start); i < end; i.add(grain, 'minutes')) {

                var value = seriesObject[i.valueOf()];
                if (typeof value == 'undefined') {
                    value = null;
                }

                dataPoint = {
                    x: start.valueOf(),
                    y: slotCounter,
                    value: value,
                    original: value,
                    timestamp: i.valueOf(),
                    suffix: unit
                };

                if (value > 100000 || value < -1) {
                    dataPoint.value = null;
                    dataPoint.color = '#333';
                }

                dataArray.push(dataPoint);
                slotCounter = slotCounter + 1;

            }
            dayCounter = dayCounter + 1;
        }
        return dataArray;
    }


    $scope.init = function() {

        $scope.highcharts.data = [];
        $scope.highcharts.options.xAxis = {
            min: Date.UTC($scope.dateRange.startDate.year(), $scope.dateRange.startDate.month(), $scope.dateRange.startDate.date()),
            max: Date.UTC($scope.dateRange.endDate.year(), $scope.dateRange.endDate.month(), $scope.dateRange.endDate.date())
        };

        var parameter = $scope.options.config.parameters[0];

        $scope.refreshInProgress = true;

        var params = {
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            grain: grain,
            readingtypeid: parameter.readingtypeid,
            sensortypeid: parameter.sensortypeid,
            locationid: parameter.locationid
        }

        apiService.reading_series(params).then(function(data) {
            $scope.refreshInProgress = false;
            var series = data.data[0].timeseries;
            var readingtype = data.data[0].readingtype;
            $scope.unit = readingtype.unit;
            $scope.readingtypename = readingtype.readingtypename;
            $scope.highcharts.options.tooltip = {
                valueSuffix: ' ' + $scope.unit
            };
            $scope.highcharts.data = $scope.formatData($scope.dateRange.startDate, $scope.dateRange.endDate, grain, series, $scope.unit);
        }, function(error) {
            $scope.refreshInProgress = false;
        });
    }

    $scope.init();

}]);
smartsenseApp.controller("DashboardWidgetPieController", ['$scope', 'apiService', function($scope, apiService) {

    $scope.graphData = {
        name: $scope.options.config.meta.name,
        colorByPoint: true,
        data: []
    };

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    };

    var grain = angular.copy($scope.options.config.grain);

    $scope.getValue = function(parameter, index) {
        var params = {
            locationid: parameter.locationid,
            readingtypeid: parameter.readingtypeid,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            sensortypeid: parameter.sensortypeid
        }
        apiService.reading_value(params).then(function(response) {
            var unit = response.data.readingtype.unit;
            $scope.graphData.data.push({
                name: parameter.alias,
                unit: unit,
                y: response.data.value,
                value: response.data.value,
                selected: index == 0 ? true : false,
            });
        }, function(error) {});
    }

    $scope.init = function() {
        $scope.graphData.data = [];
        angular.forEach($scope.options.config.parameters, function(parameter, index) {
            $scope.getValue(parameter, index);
        });

    }

    $scope.init();

}]);
smartsenseApp.controller("DashboardWidgetLiveTableController", ['$scope', '$interval', 'local', 'NgTableParams', 'apiService', function($scope, $interval, local, NgTableParams, apiService) {

    $scope.localData = local.data;
    $scope.sensorids = $scope.options.config.sensors;
    $scope.readingtypeids = $scope.options.config.parameters;

    if ($scope.options.config.is_all_sensors) {
        $scope.sensorids = Object.keys($scope.localData.sensors);
    }

    $scope.isFull = $scope.options.config.class == 'col-lg-12 col-md-12 col-sm-12 col-xs-12';

    // Pagination Configuration
    var initialParams = {
        count: $scope.isFull ? 10 : 4, // initial page size,
    };

    var initialSettings = {
        // page size buttons (right set of buttons in demo)
        counts: [],
        // determines the pager buttons (left set of buttons in demo)
        paginationMaxBlocks: 5,
        paginationMinBlocks: 2,
        getData: function(params) {
            var page = params._params.page;
            var count = params._params.count;
            $scope.sensors = $scope.sensorids.slice((page - 1) * count, (page - 1) * count + count);
            return apiService.reading_live_multiple($scope.sensors, $scope.readingtypeids).then(function(response) {
                params.total($scope.sensorids.length);
                var dataset = [];
                angular.forEach($scope.sensors, function(sensorid) {
                    var sensor = $scope.localData.sensors[sensorid];
                    var row = {
                        sensor: sensor.name
                    };
                    angular.forEach(response.data.data[sensor.sensorid], function(value, key) {
                        row[key] = value;
                    })
                    dataset.push(row);
                });
                return dataset;
            });
        }
    };

    $scope.tableParams = new NgTableParams(initialParams, initialSettings);

    $scope.columns = [{
        field: "sensor",
        title: "Sensor",
        show: true
    }];

    angular.forEach($scope.readingtypeids, function(readingtypeid) {
        var readingtype = $scope.localData.readingtypes[readingtypeid];
        var col = {
            field: readingtype.readingtypeid,
            show: true,
            unit: readingtype.unit,
            readingtype: readingtype,
            title: readingtype.readingtypename
        };
        if (readingtype.timebased) {
            col.unit = 'Counter'
        }
        if (col.unit && col.title != col.unit) {
            col.title = col.title + ' (' + col.unit + ')';
        }
        $scope.columns.push(col);
    });

    if ($scope.options.config.meta.refreshtime) {
        var timer = $interval(function() {
            $scope.tableParams.reload()
        }, $scope.options.config.meta.refreshtime * 1000 * 60);
        $scope.$on('$destroy', function() {
            $interval.cancel(timer);
        });
    }

}]);
smartsenseApp.controller("DashboardWidgetLiveTable2Controller", ['$scope', '$interval' ,'NgTableParams','apiService', function($scope, $interval, NgTableParams, apiService) {

    $scope.isFull =  $scope.options.config.class =='col-lg-12 col-md-12 col-sm-12 col-xs-12';

    $scope.parameters = $scope.options.config.parameters;

    $scope.value_aliases_mapping = {};

    $scope.getValueAliases = function(value_aliases) {
        angular.forEach(value_aliases,function(item){
            $scope.value_aliases_mapping[item.value] = item;
        });
    }

    $scope.getValueAliases($scope.options.config.value_aliases);

    $scope.getLive = function(parameter,index) {
        $scope.parameters[index]['isLoading'] = true
        var params = {
            locationid:parameter.locationid,
            readingtypeid:parameter.readingtypeid,
            sensortypeid:parameter.sensortypeid
        }
        apiService.reading_live(params).then(function(response) {
            $scope.parameters[index]['readingtype'] = response.data.readingtype;
            $scope.parameters[index]['value'] = response.data.value;
            $scope.parameters[index]['isLoading'] = false;
        }, function(error) {
            $scope.parameters[index]['isLoading'] = false;
        });
    }

    $scope.init = function(){
        angular.forEach($scope.parameters,function(parameter,index){
            $scope.getLive(parameter,index);
        });
        var initialParams = {
            count: $scope.isFull ? 10:4, // initial page size,
        };
        var initialSettings = {
            // page size buttons (right set of buttons in demo)
            counts: [],
            // determines the pager buttons (left set of buttons in demo)
            paginationMaxBlocks: 13,
            paginationMinBlocks: 2,
            dataset: $scope.parameters
        };
        $scope.tableParams = new NgTableParams(initialParams, initialSettings);
    }

    $scope.init();


    if($scope.options.config.meta.refreshtime) {
        var timer = $interval(function() {
            $scope.init();
        }, $scope.options.config.meta.refreshtime*1000*60);
        $scope.$on('$destroy', function() {
            $interval.cancel(timer);
        });
    }

}]);

smartsenseApp.controller("DashboardWidgetTrendController", ['$scope', 'local', 'grainService', 'apiService', function($scope, local, grainService, apiService) {

    $scope.config = $scope.options.config;
    $scope.isFull =  $scope.options.config.class =='col-lg-12 col-md-12 col-sm-12 col-xs-12';
    $scope.unit = '';

    $scope.data = {
        'this':{
        },
        'baseline':{
        },
        'percentage':null
    }

    $scope.graphOptions = {
        xAxis:{
            dateTimeLabelFormats: {
                day: 'Day %e'
            }
        }
    };

    if (!$scope.isFull) {
        $scope.graphOptions['char']['height'] = 220;
    }

    var parameter = $scope.config.parameters[0];

    $scope.getTrend = function() {
        var params = {
            locationid:parameter.locationid,
            sensortypeid:parameter.sensortypeid,
            readingtypeid:parameter.readingtypeid,
            grain:$scope.config.grain,
            // Date Ranges
            fromdate:$scope.config.dateRange.startDate,
            todate:$scope.config.dateRange.endDate,
            fromdate_tocompare:$scope.config.dateRangeToCompare.startDate,
            todate_tocompare:$scope.config.dateRangeToCompare.endDate
        }
        apiService.reading_trend(params).then(function(response) {
            var readingtype = response.data.readingtype;
            $scope.unit= readingtype.unit;
            
            $scope.data['this']['value'] = utils.formatValue(response.data.data['this']['value'], $scope.unit);
            $scope.data['baseline']['value'] = utils.formatValue(response.data.data['baseline']['value'], $scope.unit);

            $scope.data['percentage'] =response.data.data['this']['value'] * 100 / parseFloat(response.data.data['baseline']['value']);
            var series = {
                name: $scope.data['this']['month'],
                timeSeries: response.data.data['this']['series'],
                readingtype: readingtype,
                id: 0,
                lineWidth: 5,
            }
            if($scope.unit.toLowerCase() != readingtype.readingtypename.toLowerCase()) {
                series.unit = $scope.unit;
            }
            $scope.graphData.push(series);
            var series = {
                name: $scope.data['baseline']['month'],
                timeSeries: response.data.data['baseline']['series'],
                readingtype: readingtype,
                id: 1,
                lineWidth: 2,
                dashStyle:'ShortDash'
            }
            if($scope.unit.toLowerCase() != readingtype.readingtypename.toLowerCase()) {
                series.unit = $scope.unit;
            }
            $scope.graphData.push(series);
        }, function(error) {});
    }

    $scope.getMonths = function(index,dateRange) {
        $scope.data[index]['month'] = moment(dateRange.startDate).format("MMM");
        if(moment(dateRange.startDate).month() != moment(dateRange.endDate).month()) {
            $scope.data[index]['month'] += ' to '+moment(dateRange.endDate).format("MMM");
        }
    }

    apiService.widget_daterule($scope.config.dateRuleToCompare).then(function(response){
        $scope.config.dateRangeToCompare = response.data;
        $scope.getMonths('this',$scope.config.dateRange);
        $scope.getMonths('baseline',$scope.config.dateRangeToCompare);
        $scope.init();
    });

    $scope.init = function(){
        $scope.graphData = [];
        $scope.getTrend();
    }

}]);

smartsenseApp.controller("DashboardWidgetOverviewController", ['$scope', 'local', 'grainService', 'apiService', '$interval', function($scope, local, grainService, apiService, $interval) {

    $scope.localData = local.data;
    $scope.config = $scope.options.config;

    $scope.value = {};
    $scope.live = {};
    $scope.graphData = [];
    $scope.graphConfig = {
        options: {
            chart: {
                zoomType: 'x',
                id: 'overviewWidget' + $scope.options.widgetid
            },
            xAxis: {
                type: 'datetime'
            },
            yAxis: {
                title: {
                    text: null
                }
            }
        },
        series: [],
        title: {
            text: ''
        },
        loading: false
    };

    $scope.locations = angular.copy($scope.localData.locationlist);
    $scope.locations.unshift($scope.localData.locations[0]);

    $scope.parameter = $scope.config.parameters[0];
    $scope.parameter.location = $scope.localData.locations[$scope.parameter.locationid || 0];
    $scope.parameter.readingtype = $scope.localData.readingtypes[$scope.parameter.readingtypeid];
    $scope.parameter.sensortypeid = $scope.parameter.sensortypeid ? $scope.parameter.sensortypeid : null;

    $scope.grain = angular.copy($scope.config.grain);
    $scope.readingtype = null;

    var indexCounter = 0;

    $scope.isLoading = {
        value: false,
        series: false,
        live: false
    };

    $scope.dateRange = {
        startDate: moment($scope.config.dateRange.startDate),
        endDate: moment($scope.config.dateRange.endDate),
    };

    $scope.getGrain = function() {
        $scope.grains = grainService.get($scope.dateRange.startDate, $scope.dateRange.endDate);
        if ($scope.grains[0].value > $scope.grain) {
            $scope.grain = $scope.grains[0].value;
        }
    }

    $scope.groupLocation = function(item) {
        if (item.parentlocationid && $scope.localData.locations[item.parentlocationid]) {
            return $scope.localData.locations[item.parentlocationid].name;
        } else {
            return 'Main Locations';
        }
    };

    $scope.groupParameter = function(item) {
        if (item.parentreadingtypeid && $scope.localData.readingtypes[item.parentreadingtypeid]) {
            return $scope.localData.readingtypes[item.parentreadingtypeid].readingtypename;
        } else {
            return undefined;
        }
    };

    $scope.getValue = function() {
        $scope.isLoading.value = true;
        $scope.value = {};
        var params = {
            locationid: $scope.parameter.location.locationid,
            readingtypeid: $scope.parameter.readingtype.readingtypeid,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            sensortypeid: $scope.parameter.sensortypeid
        }
        apiService.reading_value(params).then(function(response) {
            $scope.isLoading.value = false;
            var unit = response.data.readingtype.unit;
            $scope.value = utils.formatValue(response.data.value, unit);
        }, function(error) {
            $scope.isLoading.value = false;
        });
    }

    $scope.getLive = function() {
        $scope.isLoading.live = true;
        $scope.live = {};
        var params = {
            locationid: $scope.parameter.location.locationid,
            readingtypeid: $scope.parameter.readingtype.readingtypeid,
            sensortypeid: $scope.parameter.sensortypeid
        }
        apiService.reading_live(params).then(function(response) {
            $scope.readingtype = response.data.readingtype;
            if ($scope.readingtype.timebased) {
                $scope.live = utils.formatNumber(response.data.value);
                $scope.live.unit = $scope.live.unit + " ( counter )";
            } else {
                $scope.live = utils.formatValue(response.data.value, $scope.readingtype.unit);
            }
            $scope.isLoading.live = false;
        }, function(error) {
            $scope.isLoading.live = false;
        });

    }

    $scope.getSeries = function() {
        $scope.graphConfig.series = [];
        var params = {
            locationid: $scope.parameter.location.locationid,
            readingtypeid: $scope.parameter.readingtype.readingtypeid,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            sensortypeid: $scope.parameter.sensortypeid,
            grain: $scope.grain
        }
        $scope.graphConfig.loading = true;
        $scope.graphConfig.options.yAxis.title.text = $scope.parameter.readingtype.unit;
        apiService.reading_series(params).then(function(data) {
            $scope.graphConfig.loading = true;
            angular.forEach(data.data, function(value, index) {
                var series = {
                    name: value.readingtype.readingtypename,
                    data: value.timeseries || [],
                    type: value.readingtype.timebased ? 'column' : 'line',
                    _colorIndex: index
                }
                for (var i = 0; i < series.data.length; i++) {
                    series.data[i].x = series.data[i].timeStamp * 1000;
                    series.data[i].y = series.data[i].value;
                    delete series.data[i].timeStamp;
                    delete series.data[i].value;
                }
                $scope.graphConfig.series.push(series);
                $scope.graphConfig.loading = false;
            });
        }, function(error) {
            $scope.graphConfig.loading = false;
        });
    }

    $scope.init = function() {
        $scope.value = {};
        $scope.live = {};
        $scope.graphData = [];
        $scope.getGrain();
        $scope.getValue();
        $scope.getSeries();
        $scope.getLive();
    }

    $scope.init();

    $scope.dateRangeOpts = {
        locale: {
            applyClass: 'btn-green',
            applyLabel: "Apply",
            fromLabel: "From",
            format: 'Do MMM, h:mm a',
            toLabel: "To",
            cancelLabel: 'Cancel',
            customRangeLabel: 'Custom Range'
        },
        opens: "up",
        timePicker: true,
        autoApply: true,
        maxDate: moment().add(1, 'days').endOf('day'),
        ranges: {
            'Today': [moment().startOf('day'), moment()],
            'Yesterday': [moment().subtract(1, "days").startOf('day'), moment().subtract(1, "days").endOf('day')],
            'Last 7 Days': [moment().subtract(6, 'days'), moment()],
            'Last 30 Days': [moment().subtract(29, 'days'), moment()],
            'Last 3 months': [moment().subtract(2, 'months').startOf('month'), moment()]
        },
        eventHandlers: {
            'apply.daterangepicker': function(ev, picker) {
                $scope.init();
                $scope.cancelRefresh();
            }
        }
    };

    var refreshTime = utils.getWidgetRefreshTime($scope.options.config.meta.refreshtime);
    var timer = null;

    if ($scope.dateRange.endDate > moment()) {
        timer = $interval(function() {
            $scope.init();
        }, refreshTime);
    }

    $scope.cancelRefresh = function() {
        if (timer) {
            $interval.cancel(timer);
        }
    }

    $scope.$on('$destroy', function() {
        $scope.cancelRefresh();
    });

}]);
smartsenseApp.controller("DashboardWidgetHealthController", ['$scope', 'apiService', '$interval', function($scope, apiService, $interval) {

    $scope.config = $scope.options.config;
    $scope.isLoading = {
        health: false
    };
    $scope.showList = false;
    $scope.filterStatus = 'inactive';
    $scope.filterName = '';

    $scope.sensorHealth = [];

    $scope.init = function() {
        $scope.isLoading.health = true;
        apiService.sensor_health().then(function(response) {
            $scope.isLoading.health = false;
            $scope.sensorHealth = response.data;
        }, function() {
            $scope.isLoading.health = false;
        });
    }
    $scope.init();

    var refreshTime = utils.getWidgetRefreshTime($scope.options.config.meta.refreshtime);
    var timer = $interval(function() {
        $scope.init();
    }, refreshTime);
    $scope.$on('$destroy', function() {
        $interval.cancel(timer);
    });


}]);
smartsenseApp.controller("DashboardWidgetSldController", ['$scope', '$rootScope', 'data', 'local', 'apiService', function($scope, $rootScope, data, local, apiService) {

    $scope.localData = local.data;
    $scope.config = $scope.options.config;

    $scope.refreshInProgress = false;
    $scope.treeJson = {};

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    };

    $scope.listLoaded = false;

    $scope.mapValues = function(location) {
        var values = {
            backup: 0,
            generation: 0,
            consumption: 0
        }
        if (location.sensors) {
            for (var i = 0; i < location.sensors.length; i++) {
                value = parseFloat(location.sensors[i].value) || 0;
                sensortypeid = location.sensors[i].sensortypeid;
                if (sensortypeid == 1001) {
                    values.consumption = values.consumption + value;
                } else if (sensortypeid == 1002) {
                    values.generation = values.generation + value;
                } else if (sensortypeid == 1003) {
                    values.backup = values.backup + value;
                }
            }
        }
        return values;
    }

    $scope.sumTreeValue = function(a, b) {
        var total = {
            backup: a.backup + b.backup,
            consumption: a.consumption + b.consumption,
            generation: a.generation + b.generation,
        };
        return total;
    }

    $scope.getVirtualValue = function(tree) {
        var amount = {
            backup: 0,
            generation: 0,
            consumption: 0
        };
        var child = tree.child;
        if (child) {
            for (var i = 0; i < child.length; i++) {
                if (child[i].is_virtual) {
                    amount = $scope.sumTreeValue(amount, $scope.getVirtualValue(child[i]));
                } else {
                    amount = $scope.sumTreeValue(amount, $scope.mapValues(child[i]));
                }
            }
        }
        return amount;
    }

    $scope.createAssetLocation = function(location) {
        if (!location.isAssetLocationCreated && location.sensors) {
            for (var i = 0; i < location.sensors.length; i++) {
                sensor = location.sensors[i];
                value = parseFloat(sensor.value) || 0;
                sensortypeid = sensor.sensortypeid;
                if (sensortypeid == 1004) {
                    location.child = location.child || [];
                    sensor.consumption = value;
                    location.child.unshift(sensor);
                }
            }
        }
        location.isAssetLocationCreated = true;
        return location;
    }

    $scope.traverseForest = function(forest) {
        for (var i = 0; i < forest.length; i++) {
            if (forest[i].is_virtual) {
                var value = $scope.getVirtualValue(forest[i]);
                forest[i] = utils.MergeRecursive(forest[i], value);
            }
            if (forest[i].child) {
                $scope.traverseForest(forest[i].child);
            }
        }
        return forest;
    }

    var readingtypesToShowPercentage = [2001, 2002, 2004, 2008, 2022, 2117];

    $scope.treeOptions = {
        'showPercentage': true
    };

    $scope.readingtype = {};

    $scope.getTree = function() {
        $scope.serverNotRecheable = false;
        var readingtypeid = $scope.config.parameters[0].readingtypeid || parseInt(Object.keys($scope.localData.readingtypes)[0]);
        if (readingtypesToShowPercentage.indexOf(readingtypeid) < 0) {
            $scope.treeOptions.showPercentage = false;
        }
        var params = {
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            readingtypeid: readingtypeid
        }
        $scope.refreshInProgress = true;
        apiService.sld_treeview(params).then(function(response) {
            $scope.refreshInProgress = false;
            if (response) {
                $scope.readingtype = response.data.readingtype;
                response.data.data = $scope.traverseForest(response.data.data);
                $scope.treeJson = utils.prepareTreeData(response.data);
            }
        }, function() {
            $scope.refreshInProgress = false;
            $scope.serverNotRecheable = true;
        });
        if (!$scope.localData.sensorHealth) {
            apiService.sensor_health().then(function(response) {
                $scope.sensorHealth = response.data;
                $scope.localData.sensorHealth = response.data;
            });
        }
    };

    $scope.$watch('localData.sensorHealth', function(sensorHealth) {
        $scope.sensorHealthData = sensorHealth;
    });

    $scope.showSearchPanel = false;

    $scope.callSerachShow = function(d) {
        $scope.showSearchPanel = true;
    }
    $scope.callSerachHide = function(d) {
        $scope.showSearchPanel = false;
    }

    $scope.init = function() {
        $scope.getTree();
    }

    $scope.init();

}]);
smartsenseApp.controller("DashboardWidgetInsightController", ['$scope', 'local', 'grainService', 'apiService', function($scope, local, grainService, apiService) {

    $scope.localData = local.data;
    $scope.config = $scope.options.config;

}]);

smartsenseApp.controller("DashboardWidgetOnoffController", ['$scope', 'local', 'grainService', 'apiService', 'highchartService', function($scope, local, grainService, apiService, highchartService) {

    $scope.localData = local.data;

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    };

    $scope.isFull = $scope.options.config.class == 'col-lg-12 col-md-12 col-sm-12 col-xs-12';

    $scope.chartConfig = highchartService.OnOffConfig();

    if (!$scope.isFull) {
        $scope.chartConfig.options.chart.height = 220;
    }

    var grain = angular.copy($scope.options.config.grain);

    $scope.getSeries = function(parameter, index) {
        var params = {
            locationid: parameter.locationid,
            readingtypeid: parameter.readingtypeid,
            grain: $scope.options.config.grain,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            sensortypeid: parameter.sensortypeid
        }
        apiService.reading_series(params).then(function(response) {
            angular.forEach(response.data, function(seriesData) {
                $scope.drawGraph(seriesData.timeseries, parameter.alias, index);
            });
        }, function(error) {});
    }

    $scope.getComputedSeries = function(computed_parameter, index) {
        var params = {
            grain: $scope.options.config.grain,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            computed_parameter: computed_parameter
        }
        apiService.reading_computed(params).then(function(response) {
            $scope.drawGraph(response.data, computed_parameter.alias, index);
        }, function(error) {});
    }

    $scope.init = function() {
        $scope.chartConfig.series = [];
        if ($scope.options.config.is_computed) {
            angular.forEach($scope.options.config.computed_parameters, function(computed_parameter, index) {
                $scope.getComputedSeries(computed_parameter, index);
            });
        } else {
            angular.forEach($scope.options.config.parameters, function(parameter, index) {
                $scope.getSeries(parameter, index);
            });
        }
    }

    $scope.drawGraph = function(series, name, index) {
        var data = [],
            total = 0,
            up = 0;
        var y = 0;
        series.forEach(function(value) {
            y = value.value * 1
            up = up + y;
            total++;
            data.push({ x: value.timeStamp * 1000, y: y, color: y ? 'green' : 'red' })
        });
        var series = {
            name: name,
            suffix: parseInt(up / total * 100) + '% Uptime',
            data: data,
            id: index
        }
        $scope.chartConfig.series.push(series);
    }

    $scope.init();

}]);
smartsenseApp.controller("DashboardWidgetOnoffDigitController", ['$scope', 'local', 'grainService', 'apiService','highchartService' ,function($scope, local, grainService, apiService, highchartService) {

    $scope.localData = local.data;

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    };

    $scope.isFull =  $scope.options.config.class =='col-lg-12 col-md-12 col-sm-12 col-xs-12';

    $scope.chartConfig = highchartService.OnOffConfig();

    if (!$scope.isFull) {
        $scope.chartConfig.options.chart.height = 220;
    }

    var grain = angular.copy($scope.options.config.grain);

    $scope.getSeries = function(parameter,index) {
        $scope.isLoading = true;
        var params = {
            locationid:parameter.locationid,
            readingtypeid:parameter.readingtypeid,
            grain:$scope.options.config.grain,
            fromdate:$scope.dateRange.startDate,
            todate:$scope.dateRange.endDate,
            sensortypeid:parameter.sensortypeid
        }
        apiService.reading_series(params).then(function(response) {
            $scope.drawGraph(response.data[0].timeseries, parameter.alias,index);
            $scope.isLoading = false;
        }, function(error) {
            $scope.isLoading = false;
        });
    }

    $scope.getComputedSeries = function(computed_parameter, index) {
        $scope.isLoading = true;
        var params = {
            grain:$scope.options.config.grain,
            fromdate:$scope.dateRange.startDate,
            todate:$scope.dateRange.endDate,
            computed_parameter:computed_parameter
        }
        apiService.reading_computed(params).then(function(response) {
            $scope.drawGraph(response.data,computed_parameter.alias,index);
            $scope.isLoading = false;
        }, function(error) {
            $scope.isLoading = false;
        });
    }

    $scope.init = function(){
        $scope.graphData = [];
        if($scope.options.config.is_computed) {
            $scope.getComputedSeries($scope.options.config.computed_parameters[0],0);
        } else {
            $scope.getSeries($scope.options.config.parameters[0],0);
        }
    }

    $scope.drawGraph = function(series,name,index) {
        var data = [], total=0,up=0;
        var y = 0, suffix = '';
        var last = {};
        series.forEach(function(value){
            y = value.value*1
            up = up + y;
            total++;
            v = '';
            if(y>0 && y<1) {
                v = y.toFixed(2)*100;
                suffix = '% Up';
            } else if(y==1){
                v = '';
                suffix = 'On';
            } else {
                v = '';
                suffix = 'Off';
            }
            last = {x:value.timeStamp*1000,y:y,value:v,suffix:suffix,color:y?'green':'red'};
            data.push(last);

        });

        if(last.x<moment().subtract(5,'minutes').valueOf()) {
            $scope.status = last.y?'On':'Off';
        } else {

        }

        var duration = moment.duration($scope.dateRange.endDate.diff($scope.dateRange.startDate));
        var hours = duration.asHours();
        var uptime = duration.asHours()*up/total;
        var downtime = duration.asHours()*(1-up/total);
        $scope.uptime = {
            value:uptime.toFixed(2),
            unit:'Hours'
        }
        $scope.downtime = {
            value:downtime.toFixed(2),
            unit:'Hours'
        }
        $scope.graphData = data;

    }

    $scope.init();

}]);

smartsenseApp.controller("DashboardWidgetOeeController", ['$scope', 'local', 'highchartService' ,'apiService', function($scope, local, highchartService, apiService) {

    $scope.localData = local.data;
    $scope.config = $scope.options.config;

    $scope.data = {};
    $scope.parameter = $scope.config.parameters[0];
    $scope.oeeGraphConfig = highchartService.OEEMetricsConfig();
    $scope.timeDistributionConfig = highchartService.OEETimeDistributionConfig();
    $scope.gaugeGraphConfigs = {
        performance:highchartService.gaugeConfig(),
        availability:highchartService.gaugeConfig(),
        quality:highchartService.gaugeConfig(),
        oee:highchartService.gaugeConfig()
    };

    $scope.gaugeGraphConfigs.performance.title.text = 'Performance';
    $scope.gaugeGraphConfigs.availability.title.text = 'Availability';
    $scope.gaugeGraphConfigs.quality.title.text = 'Quality';
    $scope.gaugeGraphConfigs.oee.title.text = 'OEE';

    $scope.endDateBeforeRender = endDateBeforeRender
    $scope.endDateOnSetTime = endDateOnSetTime
    $scope.startDateBeforeRender = startDateBeforeRender
    $scope.startDateOnSetTime = startDateOnSetTime

    function startDateOnSetTime(newDate, oldDate) {
        $scope.onDateSet(newDate, oldDate);
        $scope.$broadcast('start-date-changed');
    }

    function endDateOnSetTime(newDate, oldDate) {
        $scope.onDateSet(newDate, oldDate);
        $scope.$broadcast('end-date-changed');
    }

    function startDateBeforeRender($dates) {
        var activeDate = null;
        var currentDate = new moment();
        if ($scope.dateRange.endDate) {
            activeDate = moment($scope.dateRange.endDate);
        }
        $dates.filter(function(date) {
            return date.localDateValue() >= currentDate.valueOf() || (activeDate && date.localDateValue() > activeDate.valueOf())
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    function endDateBeforeRender($dates, $view) {
        var activeDate = null;
        var currentDate = new moment();
        if ($scope.dateRange.startDate) {
            activeDate = moment($scope.dateRange.startDate);
        }
        $dates.filter(function(date) {
            if ($view == 'minute') {
                return date.localDateValue() >= currentDate.valueOf() || (activeDate && date.localDateValue() <= activeDate.valueOf())
            } else {
                return date.localDateValue() >= currentDate.valueOf() || (activeDate && activeDate.clone().subtract(1, $view).valueOf() >= date.localDateValue())
            }
        }).forEach(function(date) {
            date.selectable = false;
        });
    }

    $scope.setDateRange = function(dateRange) {
        $scope.dateRange = {
            startDate : moment(angular.copy(dateRange.startDate)),
            endDate : moment(angular.copy(dateRange.endDate)),
        }
    };

    $scope.setDateRange($scope.config.dateRange);

    $scope.onDateSet = function(newDate, oldDate) {
        if(newDate != oldDate && newDate) {
            $scope.doMagic();
        }
    }

    function calculate_OEE(point) {

        var oee = {
            performance:null,
            availability:null,
            oee:null
        };

        if(utils.isNumeric(point["ideal_time"]) && utils.isNumeric(point["active_P"])) {
            oee.performance = point["ideal_time"]/point["active_P"];
            oee.performance = Number.isFinite(oee.performance) ? oee.performance*100 : null;
        }
        if(utils.isNumeric(point["active_A"]) && utils.isNumeric(point["unplanned_D"]) && utils.isNumeric(point["planned_D"])) {
            oee.availability = point["active_A"]/(point["active_A"]+point["unplanned_D"]+point["planned_D"]);
            oee.availability = Number.isFinite(oee.availability) ? oee.availability*100 : null
        }
        if(utils.isNumeric(oee.performance) && utils.isNumeric(oee.availability) && utils.isNumeric(point["quality"])) {
            oee.oee = oee.performance*oee.availability*point["quality"]/10000;
        }

        return oee;

    }

    $scope.doMagic = function() {
        $scope.oeeGraphConfig.series = [];
        var series = [];
        var agg_point = {
            ideal_time:0,
            active_P:0,
            active_A:0,
            unplanned_D:0,
            planned_D:0
        };
        $scope.oee = {
            performance:0,
            availability:0,
            quality:1,
            oee:0
        };
        var seriess = {
            'availability':{
                name:'Availability',
                data:[],
                type:'bar',
                yAxis:0,
                color:'#01b8aa'
            },
            'performance':{
                name:'Performance',
                data:[],
                type:'bar',
                yAxis:0,
                color:'#7d4f73'
            },
            'quality':{
                name:'Quality',
                data:[],
                type:'bar',
                yAxis:0,
                color:'#fd625e'
            },
            'oee':{
                name:'OEE',
                data:[],
                type:'line',
                yAxis:0,
                color:'#f2c80f',
                marker: {
                    enabled: true,
                    symbol : 'square',
                    radius : 6
                }
            }
        }
        $scope.locationData = $scope.data[$scope.parameter.locationid];
        var count = 0;
        var performance=null,availability=null,quality=1,oee=null;
        var validPoints = [];
        $scope.locationData.forEach(function(point,key) {
            var d = moment(point["date"]);
            var epoch = d.valueOf();
            if(d>=$scope.dateRange.startDate && d<=$scope.dateRange.endDate) {
                var oee = calculate_OEE(point);
                agg_point.ideal_time += point['ideal_time'];
                agg_point.active_P += point['active_P'];
                agg_point.active_A += point['active_A'];
                agg_point.unplanned_D += point['unplanned_D'];
                agg_point.planned_D += point['planned_D'];
                seriess['performance'].data.push([epoch,oee.performance]);
                seriess['availability'].data.push([epoch,oee.availability]);
                seriess['quality'].data.push([epoch,point.quality]);
                seriess['oee'].data.push([epoch,oee.oee]);
            }
        });
        Object.values(seriess).forEach(function(series){
            $scope.oeeGraphConfig.series.push(series);
        });
        $scope.timeDistributionConfig.series = [{
            name:'Planned Downtime',
            data:[agg_point.unplanned_D],
            color:'#55BF3B'
        },{
            name:'Unplanned Downtime',
            data:[agg_point.planned_D],
            color:'#DF5353'
        }];

        $scope.agg_point = agg_point;
        $scope.agg_point.quality = 100;
        $scope.oee = calculate_OEE(agg_point);
        $scope.oee.quality = 100;
        Object.keys($scope.oee).forEach(function(key){
            $scope.writeToGauge(key,$scope.oee[key])
        });

    }

    $scope.writeToGauge = function(key,item) {
        $scope.gaugeGraphConfigs[key].series = [{
            name: key,
            data: [item]
        }];
    }

    $scope.init = function() {
        var slug = "oee";
        apiService.jsondata(slug).success(function(data){
            $scope.data = data.data;
            $scope.doMagic();
        })
        
    }

    $scope.init();

}]);
smartsenseApp.controller("DashboardWidgetCycleController", ['$scope', 'local', 'apiService', function($scope, local, apiService) {

    $scope.data = [];
    $scope.localData = local.data;
    $scope.parameter = $scope.options.config.parameters[0];

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    }

    $scope.getData = function() {
        $scope.data = [];
        var params = {
            locationid: $scope.parameter.locationid,
            sensorid: $scope.parameter.sensorid,
            readingtypeid: $scope.parameter.readingtypeid,
            sensortypeid: $scope.parameter.sensortypeid,
            // Date and Grain
            grain: $scope.options.config.grain,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
        }
        apiService.cycle_get_distribution(params).then(function(response) {
            angular.forEach(response.data.CycleData, function(val, index) {
                if (val.changetime && val.starttime) {
                    var diff = val.changetime - val.starttime;
                    val.duration = moment.duration(diff, 's').asMinutes() + " mins";
                }
                $scope.data.push(val);
            });
        });
    }

    $scope.init = function() {
        $scope.getData();
    }
    $scope.init();

}]);
smartsenseApp.controller("DashboardWidgetSkyviewController", ['$scope', '$rootScope', '$filter', '$timeout', 'local', 'googleMapReady', 'apiService', 'data', '$location', '$interval', 'loading',
    function($scope, $rootScope, $filter, $timeout, local, googleMapReady, apiService, data, $location, $interval, loading) {

        $scope.localData = local.data;
        $scope.widget = {};
        $scope.widget.title = $scope.options.title;
        $scope.widget.type = $scope.options.type;
        $scope.widget.tooltip = $scope.options.tooltip;

        var grain = $scope.options.config.grain;

        $scope.dateRange = {
            startDate: moment($scope.options.config.dateRange.startDate),
            endDate: moment($scope.options.config.dateRange.endDate)
        };

        $scope.init = function() {
            var startDate = moment($scope.dateRange.startDate);
            var endDate = moment($scope.dateRange.endDate);
            var options = {
                center: new google.maps.LatLng(40, -73),
                // scrollwheel: true,
                zoom: 9,
                mapTypeControl: false,
                // zoomControl : true,
                streetViewControl: false,
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                panControl: false,
                fullscreenControl: false
            };

            $scope.readingtype = $scope.options.config.parameters;
            var readingtypeid = [];
            angular.forEach($scope.options.config.parameters, function(parameter, index) {
                readingtypeid.push(parameter.readingtypeid)
            });
            var readingtypeid = readingtypeid.toString();

            var locationlist = []
            angular.forEach($scope.options.config.locations, function(key, value) {
                locationlist.push($scope.localData.locations[key])
            })
            var locationid = $scope.options.config.locations.toString();

            // create the map
            $scope.map = new google.maps.Map(document.getElementById('plantmap'), options);
            $scope.oms = new OverlappingMarkerSpiderfier($scope.map, {
                keepSpiderfied: true,
                markersWontMove: true,
                markersWontHide: true
            });

            $scope.iw = new google.maps.InfoWindow({
                maxWidth: 350
            });

            $scope.getLocations(locationlist);

            var params = {
                locationid: locationid,
                readingtypeid: readingtypeid,
                startdate: startDate,
                enddate: endDate,
                grain: grain
            }
            apiService.gis_widget(params).then(function(response) {
                var list = response.data;
                $scope.names = list[0];
                list.splice(0, 1);
                $scope.parameters = list;
            }, function() {
                $scope.refreshInProgress = false;
                $scope.serverNotRecheable = true;
            });

            var markers = [];
            angular.forEach(locationlist, function(value, key) {
                var marker = new google.maps.Marker({
                    position: new google.maps.LatLng(value.latitude, value.longitude),
                    map: $scope.map,
                    desc: value.name,
                    defaultIcon: 'https://www.google.com/mapfiles/marker_black.png',
                    icon: '../../../../assets/images/marker.png',
                });

                marker.addListener('click', function() {
                    this.setAnimation(null);
                    $scope.iw.close();
                    $scope.iw.setContent("<div class='loading-chart'>Loading....<div class='loading-indicator'></div></div>")
                    var locationid = value.locationid;
                    var params = {
                        locationid: locationid,
                        readingtypeid: readingtypeid,
                        startdate: startDate,
                        enddate: endDate,
                        grain: grain
                    }
                    apiService.gis_widget(params).then(function(response) {
                        var list = response.data;
                        $scope.name = list[0];
                        list.splice(0, 1);
                        $scope.parameter = list;
                        var markerVal = "<div class='col-md-9 padding0'><table class='table table-sm markerValue'>";
                        angular.forEach($scope.parameter, function(k, v) {
                            if (k.value != null) {
                                $scope.readingtypename = '<td>' + k.readingtype.readingtypename + '</td>';
                                $scope.value = '<td>:</td><td>' + k.value.toFixed(2) + '</td> <td>| </td><td><i class="fa fa-plug"></i><b>' + k.livevalue.toFixed(2) + '</b></td>';
                                markerVal += "<tr>" + $scope.readingtypename + $scope.value + "</tr>"
                            }
                        })
                        markerVal += '</table></div>'
                        $scope.iw.setContent("<div class='desc'><span class='iw'>" + marker.desc + "</span><div class='col-md-12 padding0'><div class='col-md-3 padding0'><img src='../../../../assets/images/machine.gif'></div>" + markerVal + "</div><div>");
                    }, function(error) {
                        $scope.serverNotRecheable = true;
                    });
                    for (var j = 0; j < markers.length; j++) {
                        markers[j].setIcon('../../../../assets/images/marker.png');
                        markers[j].setAnimation(null);
                    }
                    marker.setIcon(marker.defaultIcon);
                    marker.setAnimation(google.maps.Animation.BOUNCE);
                    $scope.iw.open($scope.map, this);
                });

                markers.push(marker)

                $scope.oms.addListener('spiderfy', function(markers) {
                    $scope.iw.close();
                    marker.setIcon('../../../../assets/images/marker.png');
                    marker.setAnimation(null);
                });
                $scope.oms.addListener('unspiderfy', function() {
                    $scope.iw.close();
                    marker.setIcon('../../../../assets/images/marker.png');
                    marker.setAnimation(null);
                });
                google.maps.event.addListener($scope.iw, 'closeclick', function() {
                    $scope.oms.unspiderfy();
                    marker.setAnimation(null);
                    marker.setIcon('../../../../assets/images/marker.png')
                });
            });
            //add the markers to the oms
            for (var i = 0; i < markers.length; ++i) {
                markers[i].setMap($scope.map);
                $scope.oms.addMarker(markers[i]);
            }

            $(".draggable").draggable({ containment: "#containment-wrapper", scroll: false });
            $(".close-tab").on("click", function() {
                $(this).parents(".draggable").hide();
            })
            $(".floating-tab").on("click", function() {
                $(".skyview .draggable").show();
            })

        }

        googleMapReady.ready().then(function() {
            $scope.init();
        });

        $scope.scrollwheel = false;

        $scope.scrollwheelChange = function() {
            $scope.map.setOptions({
                scrollwheel: $scope.scrollwheel
            });
        }

        /* Fetch main locations of logged in user */
        $scope.getLocations = function(locationlist) {
            $scope.createMarkers(locationlist);
        }

        /* Get marker by latitude and longitude */
        $scope.getByLatLng = function(lat, lng, markers) {
            return $filter('filter')(markers, function(marker) {
                return marker.pos.lat == lat && marker.pos.lng == lng;
            })[0];
        }

        $scope.markers = [];
        $scope.currentMarker = {};

        $scope.createMarkers = function(locationlist) {

            var markers = [];

            angular.forEach(locationlist, function(location) {
                var pos = {
                    lat: location.latitude,
                    lng: location.longitude
                };

                pos = convertToDD(pos);
                var isMarkerExist = $scope.getByLatLng(pos.lat, pos.lng, markers);
                if (!isMarkerExist) {
                    markers.push({
                        pos: pos,
                        latlng: new google.maps.LatLng(pos.lat, pos.lng),
                        plants: [{
                            name: location.name,
                            client: location.clientid,
                            address: location.label
                        }]
                    });
                } else {
                    var index = markers.indexOf(isMarkerExist);
                    markers[index].plants.push({
                        name: location.name,
                        client: location.clientid,
                        address: location.label
                    });
                }
            });


            $scope.markers = markers;



            $scope.setBound();
        }

        $scope.setBound = function() {
            var markers = $scope.markers;
            var bounds = new google.maps.LatLngBounds();
            angular.forEach(markers, function(marker, key) {
                bounds.extend(marker.latlng);
            });
            $scope.map.setCenter(bounds.getCenter());
            var numberOfMarkers = markers.length;
            if (numberOfMarkers == 1) {
                $scope.map.setZoom(11);
            } else {
                $scope.map.fitBounds(bounds);
            }
        }

        $scope.resetbtn = function() {
            $scope.init();
            $scope.scrollwheel = false;
            $scope.scrollwheelChange();
        }

    }
]);
smartsenseApp.controller("DashboardWidgetGifimageController", ['$scope', '$rootScope', '$filter', '$timeout', 'local', 'apiService', 'data', '$location',
    function($scope, $rootScope, $filter, $timeout, local, apiService, data, $location) {
        $scope.localData = local.data;
        $scope.parameters = $scope.options.config.parameters;
    }
]);
smartsenseApp.controller("DashboardWidgetLiveTable3Controller", ['$scope', '$interval' ,'NgTableParams','apiService', function($scope, $interval, NgTableParams, apiService) {

    $scope.isFull =  $scope.options.config.class =='col-lg-12 col-md-12 col-sm-12 col-xs-12';

    $scope.parameters = $scope.options.config.parameters;

    $scope.value_aliases_mapping = {};

    $scope.getValueAliases = function(value_aliases) {
        angular.forEach(value_aliases,function(item){
            $scope.value_aliases_mapping[item.value] = item;
        });
    }

    $scope.getValueAliases($scope.options.config.value_aliases);

    $scope.getLive = function(parameter,index) {
        $scope.parameters[index]['isLoading'] = true
        var params = {
            locationid:parameter.locationid,
            readingtypeid:parameter.readingtypeid,
            sensortypeid:parameter.sensortypeid
        }
        apiService.reading_live(params).then(function(response) {
            $scope.parameters[index]['readingtype'] = response.data.readingtype;
            $scope.parameters[index]['value'] = response.data.value;
            $scope.parameters[index]['isLoading'] = false;
        }, function(error) {
            $scope.parameters[index]['isLoading'] = false;
        });
    }

    $scope.init = function(){
        angular.forEach($scope.parameters,function(parameter,index){
            $scope.getLive(parameter,index);
        });
        var initialParams = {
            // count: $scope.isFull ? 10:4, // initial page size,
        };
        var initialSettings = {
            // page size buttons (right set of buttons in demo)
            counts: [],
            // determines the pager buttons (left set of buttons in demo)
            paginationMaxBlocks: 13,
            paginationMinBlocks: 2,
            dataset: $scope.parameters
        };
        $scope.tableParams = new NgTableParams(initialParams, initialSettings);
    }

    $scope.init();


    if($scope.options.config.meta.refreshtime) {
        var timer = $interval(function() {
            $scope.init();
        }, $scope.options.config.meta.refreshtime*1000*60);
        $scope.$on('$destroy', function() {
            $interval.cancel(timer);
        });
    }

}]);

smartsenseApp.controller("DashboardWidgetTreeBuilderController", ['$scope', '$rootScope', '$filter', '$timeout', 'local', 'apiService', 'data', '$location', 'loading', '$interval',
    function($scope, $rootScope, $filter, $timeout, local, apiService, data, $location, loading, $interval) {

        $scope.localData = local.data;
        $scope.sensors = $scope.localData.sensorlist;
        $scope.readingtypes = $scope.localData.readingtypeslist
        $scope.locations = $scope.localData.locations;
        $scope.config = $scope.options.config;

        var treeid = $scope.options.config.tree.id;

        $scope.tree = {};
        $scope.sensorlist = [];

        $scope.init = function() { 
            angular.forEach($scope.sensors, function(k,v) { 
                $scope.sensorlist.push({ 
                    name: k.name, 
                    sensorid: k.sensorid 
                }) 
            }) 

            $scope.treeConfig = {
                core : {
                    multiple : false,
                    animation: true,
                    error : function(error) {
                        $log.error('treeCtrl: error from js tree - ' + angular.toJson(error));
                    },
                    check_callback : true,
                    worker : true
                },
                types : {
                    default : {
                        icon : 'fa fa-info-circle'
                    }
                },
                version : 1,
                plugins : ['types','conditionalselect']
            };

            $scope.reCreateTree = function() {
                $scope.treeConfig.version++;
            }

            $scope.getTreeNodes = function(treeid) {
                $scope.config.isLoading = true;
                apiService.sensor_health().then(function(response) {
                    $scope.sensorHealth = response.data;
                    $scope.localData.sensorHealth = response.data;
                    apiService.get_tree_nodes(treeid).then(function(response) {
                        $scope.config.isLoading = false;
                        for (var i = 0; i < response.data.data.length; i++) {
                            for (var x = 0; x < $scope.sensorlist.length; x++) {
                                if (response.data.data[i].sensorid == $scope.sensorlist[x].sensorid) {
                                    $scope.sensorlist.splice(x, 1);
                                };
                            };
                        }
                        $scope.originalData = response.data.data;
                        $scope.parentData = []
                        angular.forEach($scope.originalData, function(k,v) {
                            $scope.parentData.push({
                                text: k.name,
                                id: k.id,
                            })
                        })
                        for (var i = 0; i < $scope.originalData.length; i++) {
                            if($scope.originalData[i].value !== '-' && $scope.originalData[i].value !== '') {
                                var val = utils.formatValue($scope.originalData[i].value, $scope.originalData[i].readingtypeid.unit);
                                $scope.originalData[i].text = $scope.originalData[i].name + ' <span class="valConsumed"> ' + val.value + ' ' + val.unit + '</span>';
                            } else if($scope.originalData[i].value == '-') {
                                $scope.originalData[i].text = $scope.originalData[i].name + ' <span class="valConsumed"> ' + $scope.originalData[i].value + '-' + '</span>';
                            } else {
                                $scope.originalData[i].text = $scope.originalData[i].name;
                            }
                            
                            delete $scope.originalData[i].name;
                            if($scope.originalData[i].parent == null) {
                                $scope.originalData[i].parent = '#'
                            }
                            $scope.originalData[i].state = {
                                opened : false
                            }
                            // if($scope.originalData[i].showalerts == true) {
                            //     $scope.originalData[i].icon = "fa fa-exclamation-triangle",
                            //     $scope.originalData[i].a_attr = {
                            //         title: "alerts: yes"
                            //     }
                            // }

                            angular.forEach($scope.localData.sensorHealth.sensor_health_details, function(k,v) {
                                if(k.sensor_status != "active") {
                                    if (k.sensor_id == $scope.originalData[i].sensorid) {
                                        if(k.last_communicated != null) {
                                            var timestamp = moment(k.last_communicated).format("DD/MM/YYYY HH:mm:ss a");
                                        } else {
                                            var timestamp = '---'
                                        }
                                        
                                        $('#tree').on('mouseover', '.jstree-anchor .jstree-icon', function () {
                                            $('[data-toggle="tooltip"]').tooltip({
                                                template: '<div class="tooltip tooltip-custom"><h3 class="title">Sensor Health</h3><div class="tooltip-arrow"></div><div class="content">Status: <span>'+ k.sensor_status +'</span></div><div class="tooltip-inner"></div></div>'
                                            });
                                        });
                                        $scope.originalData[i].icon = "fa fa-exclamation-triangle",
                                        $scope.originalData[i].a_attr = {
                                            "class": "show_tooltip",
                                            "data-toggle": "tooltip",
                                            "data-placement": "right",
                                            "title": "Last Communicated: " + timestamp,
                                            "onclick":"return false;"
                                        }
                                    };
                                }
                            })
                            $scope.originalData[i].li_attr = {
                                readingtypeid: $scope.originalData[i].readingtypeid
                            }
                        }
                        $scope.treeData = [];
                        angular.copy($scope.originalData,$scope.treeData);
                        $scope.reCreateTree();
                    }, function() {
                        $scope.config.isLoading = false;
                    });
                });
            }

            $scope.$watch('localData.sensorHealth', function(sensorHealth) {
                $scope.sensorHealthData = sensorHealth;
            });

            $scope.getTreeNodes(treeid);

            $scope.ignoreChanges = false;

            $scope.applyModelChanges = function() {
                return !$scope.ignoreChanges;
            };
        }

        $scope.init();

        if($scope.options.config.meta.refreshtime) {
            var timer = $interval(function() {
                $scope.init();
            }, $scope.options.config.meta.refreshtime*1000*60);
            $scope.$on('$destroy', function() {
                $interval.cancel(timer);
            });
        }

    }

]);

smartsenseApp.controller("DashboardWidgetImageUploadController", ['$scope', 'local', 'grainService', 'apiService', '$interval', function($scope, local, grainService, apiService, $interval) {

    $scope.localData = local.data;
    $scope.config = $scope.options.config;

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    }

    $scope.getAggregatedData = function(computed_parameter, index) {
        var params = {
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            grain: $scope.config.grain,
            computed_parameter: computed_parameter
        }
        $scope.config.computed_parameters[index].isLoading = true;
        apiService.reading_computed_data(params).then(function(response) {
            angular.forEach($scope.localData.readingtypes, function(value,key) {
                if(key == computed_parameter.formula[0].parameter.readingtypeid) {
                    var val = utils.formatValue(response.data, $scope.localData.readingtypes[key].unit)
                    $scope.config.computed_parameters[index].value = val;
                    if(computed_parameter.threshold != null && $scope.config.computed_parameters[index].value.value >= computed_parameter.threshold) {
                        $scope.config.computed_parameters[index].style.fontcolor = computed_parameter.threshold_color
                    }
                    $scope.config.computed_parameters[index].isLoading = false;
                }
            }) 
        }, function(error) {})
    }

    $scope.getReadingData = function(parameter, index) {
        var params = {
            locationid: parameter.locationid,
            readingtypeid: parameter.readingtypeid,
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            sensortypeid: parameter.sensortypeid
        }
        $scope.config.parameters[index].isLoading = true;
        apiService.reading_value(params).then(function(response) {
            var val = utils.formatValue(response.data.value, response.data.readingtype.unit);
            $scope.config.parameters[index].value = val;
            if(parameter.threshold != null && $scope.config.parameters[index].value.value >= parameter.threshold) {
                $scope.config.parameters[index].style.fontcolor = parameter.threshold_color
            }
            $scope.config.parameters[index].isLoading = false;
        }, function(error) {})
    }

    $scope.getLiveData = function(computed_parameter, index) {
        var params = {
            computed_parameter: computed_parameter
        }
        $scope.config.computed_parameters[index].isLoading = true;
         apiService.reading_computed_live(params).then(function(response) {
            angular.forEach($scope.localData.readingtypes, function(value,key) {
                if(key == computed_parameter.formula[0].parameter.readingtypeid) {
                    var data = utils.isNumeric(response.data) ? response.data : null;
                    var val = utils.formatValue(data, $scope.localData.readingtypes[key].unit)
                    $scope.config.computed_parameters[index].value = val;
                    if(computed_parameter.threshold != null && $scope.config.computed_parameters[index].value.value >= computed_parameter.threshold) {
                        $scope.config.computed_parameters[index].style.fontcolor = computed_parameter.threshold_color
                    }
                    $scope.config.computed_parameters[index].isLoading = false;
                }
            }) 
        }, function(error) {})
    }

    $scope.getData = function(parameter, index) {
        var params = {
            readingtypeid: parameter.readingtypeid,
            sensortypeid: parameter.sensortypeid,
            locationid: parameter.locationid
        }
        $scope.config.parameters[index].isLoading = true;
        apiService.reading_live(params).then(function(response) {
            if(response.data.value != null || response.data.value != undefined) {
                var val = utils.formatValue(response.data.value[0], response.data.readingtype.unit);
                $scope.config.parameters[index].value = val;
                if(parameter.threshold != null && $scope.config.parameters[index].value.value >= parameter.threshold) {
                    $scope.config.parameters[index].style.fontcolor = parameter.threshold_color
                }
            } else {
                var val = utils.formatValue(response.data.value, response.data.readingtype.unit);
                $scope.config.parameters[index].value = val;
            }
            $scope.config.parameters[index].isLoading = false;
        }, function(error) {})
    }

    $scope.init = function() {
        $scope.url = $scope.config.url;
        if($scope.config.is_aggregated) {
            if ($scope.options.config.is_computed) {
                angular.forEach($scope.options.config.computed_parameters, function(computed_parameter, index) {
                    $scope.getAggregatedData(computed_parameter, index);
                });
            } else {
                angular.forEach($scope.options.config.parameters, function(parameter, index) {
                    $scope.getReadingData(parameter, index);
                });
            }
        } else {
            if ($scope.options.config.is_computed) {
                angular.forEach($scope.options.config.computed_parameters, function(computed_parameter, index) {
                    $scope.getLiveData(computed_parameter, index);
                });
            } else {
                angular.forEach($scope.options.config.parameters, function(parameter, index) {
                    $scope.getData(parameter, index);
                });
            }
        }
    }

    $scope.init();

    if($scope.options.config.meta.refreshtime) {
        var timer = $interval(function() {
            $scope.init();
        }, $scope.options.config.meta.refreshtime*1000*60);
        $scope.$on('$destroy', function() {
            $interval.cancel(timer);
        });
    }

}]);
smartsenseApp.controller("DashboardWidgetDialController", ['$scope', 'local', 'apiService', 'highchartService', '$interval', function($scope, local, apiService, highchartService, $interval) {

    $scope.localData = local.data;
    $scope.config = $scope.options.config;

    $scope.dateRange = {
        startDate: moment($scope.options.config.dateRange.startDate),
        endDate: moment($scope.options.config.dateRange.endDate)
    }

    var tickPositions = []
    angular.forEach($scope.config.solid_thresholds, function(k,v) {
        tickPositions.push(k.value);
    })
    tickPositions.push($scope.config.lower);
    tickPositions.push($scope.config.upper);

    $scope.solidgaugeOptions = highchartService.solidgaugeConfig();
    $scope.solidgaugeOptions.options.yAxis.min = $scope.config.lower;
    $scope.solidgaugeOptions.options.yAxis.max = $scope.config.upper;
    $scope.solidgaugeOptions.options.yAxis.tickPositions = tickPositions,
    $scope.solidgaugeOptions.series.push({
        name: $scope.config.computed_parameters[0].alias,
        data: [],
        dataLabels: {
            format: '<div style="text-align:center"><span style="font-size:16px;color:' +
                ((Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black') + '">{y}</span>' +
                   '<span style="font-size:12px;color:#000;font-weight:500;"> '+ $scope.config.computed_parameters[0].unit +'</span></div>'
        },
        tooltip: {
            valueSuffix: ' '+ $scope.config.computed_parameters[0].unit
        }
    })
    $scope.solidgaugeOptions.title.text = $scope.config.computed_parameters[0].alias;

    $scope.gaugeOptions = highchartService.speedometerConfig();
    $scope.gaugeOptions.options.yAxis.min = $scope.config.lower;
    $scope.gaugeOptions.options.yAxis.max = $scope.config.upper;
    $scope.gaugeOptions.options.yAxis.title.text = $scope.config.computed_parameters[0].unit;
    angular.forEach($scope.config.speedometer_thresholds, function(k, v) {
        $scope.gaugeOptions.options.yAxis.plotBands.push({
            from: k.from,
            to: k.to,
            color: k.color
        })
    })
    
    $scope.gaugeOptions.series.push({
        name: $scope.config.computed_parameters[0].alias,
        data: [],
        tooltip: {
            valueSuffix: ' ' + $scope.config.computed_parameters[0].unit
        },
        dataLabels : {
            style: {
                fontSize: '18px',
                fontWeight: 'bold'
            }
        },
        overshoot: 0
    })

    $scope.getAggregateData = function(computed_parameter, index) {
        var params = {
            fromdate: $scope.dateRange.startDate,
            todate: $scope.dateRange.endDate,
            grain: $scope.config.grain,
            computed_parameter: computed_parameter
        }
        apiService.reading_computed_data(params).then(function(response) {
            if(response.data != '-' || response.data != undefined || response.data != null) {
                if($scope.config.dial_type == "solidgauge") {
                    $scope.solidgaugeOptions.series[0].data.push(parseFloat(response.data.toFixed(2)));
                } else {
                    $scope.gaugeOptions.series[0].data.push(parseFloat(response.data.toFixed(2)));
                }
            } else {
                if($scope.config.dial_type == "solidgauge") {
                    $scope.solidgaugeOptions.series[0].data.push(0);
                } else {
                    $scope.gaugeOptions.series[0].data.push(0);
                }
            }
        }, function(error) {})
    }

    $scope.getLiveData = function(computed_parameter, index) {
        var params = {
            computed_parameter: computed_parameter
        }
        apiService.reading_computed_live(params).then(function(response) {
            if(response.data != "") {
                if($scope.config.dial_type == "solidgauge") {
                    $scope.solidgaugeOptions.series[0].data.push(parseFloat(response.data.toFixed(2)));
                } else {
                    $scope.gaugeOptions.series[0].data.push(parseFloat(response.data.toFixed(2)));
                }
            } else {
                if($scope.config.dial_type == "solidgauge") {
                    $scope.solidgaugeOptions.series[0].data.push(0);
                } else {
                    $scope.gaugeOptions.series[0].data.push(0);
                }
            }
            
        }, function(error) {})
    }

    function setDivHeight() {
        var div = $('#solidgaugechart');
        div.height(div.width() * 0.75);
        div = $('#gaugechart');
        div.height(div.width() * 0.75);
    }

    $scope.init = function() {
        setDivHeight();
        $(window).on('load resize', function(){
            setDivHeight();
        });
        $scope.solidgaugeOptions.series[0].data = [];
        $scope.gaugeOptions.series[0].data = [];
        angular.forEach($scope.options.config.computed_parameters, function(computed_parameter, index) {
            if($scope.config.is_aggregated) {
                $scope.getAggregateData(computed_parameter, index);
            } else {
                $scope.getLiveData(computed_parameter, index);
            }
        });
    }

    $scope.init();

    if($scope.options.config.meta.refreshtime) {
        var timer = $interval(function() {
            $scope.init();
        }, $scope.options.config.meta.refreshtime*1000*60);
        $scope.$on('$destroy', function() {
            $interval.cancel(timer);
        });
    }

}]);
smartsenseApp.controller("DashboardWidgetHtmlController", DashboardWidgetHtmlController);


DashboardWidgetHtmlController.$inject = ['$scope', '$sce'];

function DashboardWidgetHtmlController($scope, $sce) {

    $scope.trustAsHtml = function (htmlCode) {
        return $sce.trustAsHtml(htmlCode);
    }
}
smartsenseApp.controller("BillingWidgetBillController", ['$scope', '$rootScope', 'data', 'local', 'config',
    function($scope, $rootScope, data, local, config) {
        $scope.localData = local.data;
        $scope.refreshInProgress = true;
        $scope.$watch('localData.billingData', function(newVal) {
            $scope.refreshInProgress = false;
            $scope.billData = newVal;
        });

        $scope.$watch('localData.billingDataLoading', function(newVal) {
            $scope.refreshInProgress = newVal;
        });
        $('[data-toggle="popover"]').popover();
    }
]);

smartsenseApp.controller("BillingWidgetBillSimulatorController", ['$scope', '$rootScope', 'data', 'local', 'config', 'loading', '$state', 'Analytics', 'apiService',
    function($scope, $rootScope, data, local, config, loading, $state, Analytics, apiService) {
        /* Set local data to use in other components */
        $scope.localData = local.data;
        $scope.refreshInProgress = false;
        $scope.pfDetails = {};
        $scope.simulatedBill = 0;
        $scope.isSimulated = false;

        function getPercentages(total, item) {
            if (total == 0)
                return 0;
            return parseFloat(Math.round((100 * item) / total));
        };

        $scope.initValues = function(){
            $scope.values = {
                formatter: function(val, type, unit) {
                    if (!val)
                        return 0;
                    else {
                        var _val = parseFloat(parseFloat(val).toFixed(2));
                        var perc = "";
                        // if(type && $scope.values.consumption && $scope.values.consumption.currentValue)
                        // {
                        //     var peak = parseFloat($scope.values.peak.currentValue);
                        //     var offpeak = parseFloat($scope.values.offpeak.currentValue);
                        //     var night = parseFloat($scope.values.night.currentValue);
                        //     var total = peak + offpeak + night;
                        //     if(type=="peak"){
                        //         perc =  " (" + getPercentages(total, peak) + "%)";
                        //     }
                        //     else if(type=="offpeak"){
                        //         perc = " (" + getPercentages(total, offpeak) + "%)";
                        //     }
                        //     else if(type=="night"){
                        //         perc = " (" + getPercentages(total, night) + "%)";
                        //     }
                        // }
                        unit = unit || "kWH";
                        return _val + " " + unit + perc;
                    }
                },
                demand: {},
                pf: {
                    value: undefined,
                    min: 80,
                    max: 100,
                    formatter: function(val) {
                        if (!val)
                            return 0;
                        else
                            return val / 100;
                    },
                    onChange: function(evt, val, input) {
                        if (input) {
                            if ($scope.values.pf.currentValue) {
                                if ($scope.values.pf.currentValue > 1)
                                    $scope.values.pf.currentValue_pseudo = 100;
                                else if ($scope.values.pf.currentValue < -1)
                                    $scope.values.pf.currentValue_pseudo = -100;
                                else
                                    $scope.values.pf.currentValue_pseudo = $scope.values.pf.currentValue * 100;
                            }
                        } else
                            $scope.values.pf.currentValue = val / 100;
                    }
                },
                consumption: {},
                peak: {},
                offpeak: {},
                night: {},
                bill: {
                    provisional: undefined,
                    projected: undefined,
                    previous: undefined
                }
            }
        }

        $scope.initValues();

        $scope.getBillDetails = function(params) {
            $scope.refreshInProgress = true;
            loading(true);
            params = params || {};
            params.locationid = $scope.localData.selectedBillingLocation;
            apiService.billing_simulator_widgets(params).then(function(data) {
                $scope.refreshInProgress = false;
                loading(false);
                if (data && data.data) {
                    var data = data.data;
                    var billingData = data.BILLING;
                    //console.log(billingData);

                    function getValue(val) {
                        if (val != undefined && val != null) {
                            return parseFloat(parseFloat(val).toFixed(2));
                        } else
                            return val;
                    }

                    $scope.values.pf.value = billingData.PF;
                    if ($scope.values.pf.value) {
                        $scope.values.pf.value = parseFloat($scope.values.pf.value);
                        $scope.values.pf.original_value = utils.roundAbs($scope.values.pf.value);
                        $scope.values.pf.currentValue = utils.roundAbs($scope.values.pf.value);
                        $scope.values.pf.currentValue_pseudo = utils.roundAbs($scope.values.pf.value * 100);
                    }

                    $scope.values.demand.value =
                        $scope.values.demand.currentValue = getValue(billingData.RECORDED_DEMAND);
                    if ($scope.values.demand.value != undefined || $scope.values.demand.value != null) {
                        if (!params.recordeddemand) {
                            $scope.values.demand.original_value = utils.roundAbs($scope.values.demand.value);
                            $scope.values.demand.min = utils.roundAbs($scope.values.demand.value - ($scope.values.demand.value / 2));
                            $scope.values.demand.max = utils.roundAbs($scope.values.demand.value + ($scope.values.demand.value / 2));
                            $scope.values.demand.up = true;
                            $scope.values.demand.perc = 0;
                        }
                    }

                    $scope.values.consumption.value =
                        $scope.values.consumption.currentValue = getValue(billingData.PROJECTED_UNITS);
                    if ($scope.values.consumption.value != undefined || $scope.values.consumption.value != null) {
                        $scope.values.consumption.original_value = utils.roundAbs($scope.values.consumption.value);
                        $scope.values.consumption.min = utils.roundAbs($scope.values.consumption.value - ($scope.values.consumption.value / 2));
                        $scope.values.consumption.max = utils.roundAbs($scope.values.consumption.value + ($scope.values.consumption.value / 2));
                    }

                    if (billingData.PROJECTED_PEAK_HOUR_UNITS || billingData.PROJECTED_PEAK_UNITS) {
                        var val = billingData.PROJECTED_PEAK_HOUR_UNITS || billingData.PROJECTED_PEAK_UNITS;
                        $scope.values.peak.value =
                            $scope.values.peak.currentValue = getValue(val);
                        if (!params.peakunits) {
                            if ($scope.values.peak.value != undefined || $scope.values.peak.value != null) {
                                $scope.values.peak.original_value = utils.roundAbs($scope.values.peak.value);
                                $scope.values.peak.min = utils.roundAbs($scope.values.peak.value - ($scope.values.peak.value / 2));
                                $scope.values.peak.max = utils.roundAbs($scope.values.peak.value + ($scope.values.peak.value / 2));
                            }
                        }
                    }

                    if (billingData.PROJECTED_OFFPEAK_HOUR_UNITS || billingData.PROJECTED_OFFPEAK_UNITS) {
                        var val = billingData.PROJECTED_OFFPEAK_HOUR_UNITS || billingData.PROJECTED_OFFPEAK_UNITS;
                        $scope.values.offpeak.value =
                            $scope.values.offpeak.currentValue = getValue(val);
                        if (!params.offpeakunits) {
                            if ($scope.values.offpeak.value != undefined || $scope.values.offpeak.value != null) {
                                $scope.values.offpeak.original_value = utils.roundAbs($scope.values.offpeak.value);
                                $scope.values.offpeak.min = utils.roundAbs($scope.values.offpeak.value - ($scope.values.offpeak.value / 2));
                                $scope.values.offpeak.max = utils.roundAbs($scope.values.offpeak.value + ($scope.values.offpeak.value / 2));
                            }
                        }
                    }

                    if (billingData.PROJECTED_NIGHT_HOUR_UNITS || billingData.PROJECTED_NIGHT_UNITS) {
                        var val = billingData.PROJECTED_NIGHT_HOUR_UNITS || billingData.PROJECTED_NIGHT_UNITS;
                        $scope.values.night.value =
                            $scope.values.night.currentValue = getValue(val);
                        if (!params.nightunits) {
                            if ($scope.values.night.value != undefined || $scope.values.night.value != null) {
                                $scope.values.night.original_value = utils.roundAbs($scope.values.night.value);
                                $scope.values.night.min = utils.roundAbs($scope.values.night.value - ($scope.values.night.value / 2));
                                $scope.values.night.max = utils.roundAbs($scope.values.night.value + ($scope.values.night.value / 2));
                            }
                        }
                    }

                    if (billingData.PREVIOUS_BILL && utils.isNumeric(billingData.PREVIOUS_BILL)) {
                        $scope.values.bill.previous = Math.round(parseFloat(billingData.PREVIOUS_BILL));
                    }
                    if (billingData.PROJECTED_BILL && utils.isNumeric(billingData.PROJECTED_BILL)) {
                        $scope.values.bill.projected = Math.round(parseFloat(billingData.PROJECTED_BILL));
                    }
                    if (billingData.PROVISIONAL_BILL && utils.isNumeric(billingData.PROVISIONAL_BILL)) {
                        $scope.values.bill.provisional = Math.round(parseFloat(billingData.PROVISIONAL_BILL));
                    }
                    if (billingData.PREVIOUS_TO_PREVIOUS_BILL && utils.isNumeric(billingData.PREVIOUS_TO_PREVIOUS_BILL)) {
                        $scope.values.bill.previousToPrevious = Math.round(parseFloat(billingData.SECOND_PREVIOUS_BILL));
                    }
                    $scope.simulatedBill = $scope.values.bill.previous;
                    $scope.calculatePercentages();
                }
            }, function(error) {
                loading(false);
                $scope.refreshInProgress = false;
                $scope.serverNotRecheable = true;
            });
        }

        function getPerc(val1, val2) {
            val1 = parseFloat(val1);
            val2 = parseFloat(val2);
            if (val1 > 0) {
                var diff = val1 - val2;
                return Math.abs((100 * diff) / val1).toFixed(2);
            } else
                return "";
        }

        $scope.calculatePeakUnits = function(p, o, n) {
            if ($scope.values.consumption && $scope.values.consumption.original_value) {
                $scope.values.consumption.value = $scope.values.peak.currentValue + $scope.values.offpeak.currentValue + $scope.values.night.currentValue;
            }
        }

        $scope.calculatePercentages = function() {
            if ($scope.values.bill.previous) {
                if ($scope.values.bill.projected) {
                    $scope.values.bill.projectedUp = parseFloat($scope.values.bill.projected) > parseFloat($scope.values.bill.previous);
                    $scope.values.bill.projectedPerc = getPerc($scope.values.bill.previous, $scope.values.bill.projected);
                }
                if ($scope.values.bill.provisional) {
                    $scope.values.bill.provisionalUp = parseFloat($scope.values.bill.provisional) > parseFloat($scope.values.bill.previous);
                    $scope.values.bill.provisionalPerc = getPerc($scope.values.bill.previous, $scope.values.bill.provisional);
                }
                if ($scope.values.bill.previousToPrevious) {
                    $scope.values.bill.previousUp = parseFloat($scope.values.bill.previous) > parseFloat($scope.values.bill.previousToPrevious);
                    $scope.values.bill.previousPerc = getPerc($scope.values.bill.previous, $scope.values.bill.previousToPrevious);
                }
            }
        }

        $scope.getChangePerc = {
            res: {
                perc: 0,
                up: true
            },
            demand: function() {
                if ($scope.values.demand.currentValue && $scope.values.demand.original_value) {
                    this.res.up = $scope.values.demand.currentValue > $scope.values.demand.original_value;
                    this.res.perc = getPerc($scope.values.demand.original_value, $scope.values.demand.currentValue);
                }
                return this.res;
            },
            pf: function() {
                if ($scope.values.pf.currentValue && $scope.values.pf.original_value) {
                    this.res.up = $scope.values.pf.currentValue > $scope.values.pf.original_value;
                    this.res.perc = getPerc($scope.values.pf.original_value, $scope.values.pf.currentValue);
                }
                return this.res;
            },
            peak: function() {
                if ($scope.values.peak.currentValue && $scope.values.peak.original_value) {
                    this.res.up = $scope.values.peak.currentValue > $scope.values.peak.original_value;
                    this.res.perc = getPerc($scope.values.peak.original_value, $scope.values.peak.currentValue);
                }
                return this.res;
            },
            offpeak: function() {
                if ($scope.values.offpeak.currentValue && $scope.values.offpeak.original_value) {
                    this.res.up = $scope.values.offpeak.currentValue > $scope.values.offpeak.original_value;
                    this.res.perc = getPerc($scope.values.offpeak.original_value, $scope.values.offpeak.currentValue);
                }
                return this.res;
            },
            night: function() {
                if ($scope.values.night.currentValue && $scope.values.night.original_value) {
                    this.res.up = $scope.values.night.currentValue > $scope.values.night.original_value;
                    this.res.perc = getPerc($scope.values.night.original_value, $scope.values.night.currentValue);
                }
                return this.res;
            }
        };

        $scope.refresh = function() {
            $scope.getBillDetails();
            return;
        };

        $scope.isUndefined = function(thing) {
            return (typeof thing === "undefined");
        };
        $scope.$watch('localData.billingData', function(newVal) {
            if (newVal) {
                $scope.billingData = newVal;
                // console.log('billing data', $scope.billingData);
            }
        });
        $scope.$watch('localData.selectedBillingLocation', function(val) {
            if(val)
                $scope.refresh();
        });

        $scope.calculate = function(reset) {
            if (reset) {
                $scope.initValues();
                $scope.getBillDetails();
                $scope.isSimulated = false;

            } else {
                var params = {
                    recordeddemand: $scope.values.demand.currentValue,
                    pf: $scope.values.pf.currentValue,
                    peakunits: $scope.values.peak.currentValue,
                    nightunits: $scope.values.night.currentValue,
                    offpeakunits: $scope.values.offpeak.currentValue
                }
                $scope.getBillDetails(params);
            }
            return;
        };

        //$scope.refresh();

        // /* Bill Simulation */
        $scope.getSimulatedBill = function() {
            loading(true);
            $scope.refreshInProgress = true;
            $scope.isSimulated = false;
            var locationID = $scope.localData.selectedBillingLocation;
            var params = {
                recordeddemand: $scope.values.demand.currentValue,
                pf: $scope.values.pf.currentValue,
                peakunits: $scope.values.peak.currentValue,
                nightunits: $scope.values.night.currentValue,
                offpeakunits: $scope.values.offpeak.currentValue,
                locationid : locationID
            }
            apiService.billing_simulator_widgets(params).then(function(response) {
                loading(false);
                $scope.refreshInProgress = false;
                if (response.data.BILLING.PROJECTED_BILL && utils.isNumeric(response.data.BILLING.PROJECTED_BILL)) {
                    $scope.simulatedBill = Math.round(parseFloat(response.data.BILLING.PROJECTED_BILL));
                    $scope.isSimulated = true;
                }
            }, function(error) {
                loading(false);
                $scope.refreshInProgress = false;
                $scope.serverNotRecheable = true;
            });
            Analytics.trackEvent('Billing Insights', 'Simulating Bill', $state.current.name);
        }

        $('[data-toggle="popover"]').popover();
    }
]);

smartsenseApp.controller("BillingWidgetConsumptionController", ['$scope', '$rootScope', 'data', 'local', 'config','apiService',
    function($scope, $rootScope, data, local, config, apiService) {
        /* Set local data to use in other components */
        $scope.localData = local.data;

        $scope.options = {
            height: 150
        }

        $scope.colors = {
            offpeak: '#FFECB6',
            peak: '#FFA423',
            night: '#A39F89'
        }

        $scope.consumptionTrend = {
            today: {
                data: [],
                total: 0
            },
            month: {
                data: [],
                total: 0
            }
        }


        $scope.getConsumptionTrendForToday = function() {
            var locationID = $scope.localData.selectedBillingLocation;
            apiService.billing_get_consumption_details('today', locationID).then(function(response) {
                $scope.mapGraphDataForToday(response.data);
                $scope.consumptionTrend.today.total = $scope.getTotalConsumption(response.data.sum);
            });
        }

        $scope.optionsForToday = {
            xAxis: {
                minPadding: 0,
                maxPadding: 0,
                tickInterval: 3600 * 1000,
            },
            plotOptions: {
                column: {
                    dataLabels: {
                        enabled: false
                    }
                }
            },
            yAxis: {
                stackLabels: {
                    enabled: false
                }
            },
            tooltip: {
                headerFormat: '<b>{point.x:%d %b\'%y %H:%M}</b><br/>',
                pointFormat: '{series.name}: {point.y:.2f}<br/>',
                footerFormat: ''
            },
        }

        $scope.optionsForMonth = {
            xAxis: {
                // minPadding: 0,
                // maxPadding: 0,
                tickInterval: 3600 * 1000 * 24,
            },
            plotOptions: {
                column: {
                    dataLabels: {
                        enabled: false
                    }
                }
            },
            yAxis: {
                stackLabels: {
                    enabled: false
                }
            }
        }

        $scope.mapGraphDataForToday = function(APIData) {

            var timeSeries = APIData.data;
            var IndexMapping = utils.swap(APIData.mapping);
            var GraphData = [];

            angular.forEach(IndexMapping, function(value, key) {

                var data = {
                    name: utils.toTitleCase(value),
                    data: [],
                    color: $scope.colors[value]
                };

                angular.forEach(timeSeries[key], function(value, date) {
                    timeStamp = (new moment(date, "YYYY-MM-DD hh:mm:ss")).valueOf();
                    data.data.push([timeStamp, value]);

                });
                GraphData.push(data);

            });
            $scope.consumptionTrend.today.data = GraphData;
        }


        $scope.mapGraphDataForMonth = function(APIData) {

            var timeSeries = APIData.data;
            var IndexMapping = utils.swap(APIData.mapping);
            var GraphData = [];

            angular.forEach(IndexMapping, function(value, key) {

                var data = {
                    name: utils.toTitleCase(value),
                    data: [],
                    color: $scope.colors[value]
                };

                angular.forEach(timeSeries, function(values, date) {

                    timeStamp = (new moment(date, "YYYY-MM-DD")).valueOf();
                    data.data.push([timeStamp, values[key]]);

                });

                GraphData.push(data);

            });
            $scope.consumptionTrend.month.data = GraphData;
        }


        $scope.getTotalConsumption = function(consumptionArray) {
            var consumptionTrendTotal = 0;
            angular.forEach(consumptionArray, function(value, key) {
                consumptionTrendTotal += value;
            })
            return utils.formatData(consumptionTrendTotal, true, false);
        }


        $scope.getConsumptionTrendForMonth = function() {
            var locationID = $scope.localData.selectedBillingLocation;
            apiService.billing_get_consumption_details('', locationID).then(function(response) {
                $scope.mapGraphDataForMonth(response.data);
                $scope.consumptionTrend.month.total = $scope.getTotalConsumption(response.data.sum);
            });
        }

        $scope.getBillingCycle = function() {
            var locationID = $scope.localData.selectedBillingLocation;
            apiService.billing_get_bill_by_billing_cycle(locationID).then(function(response) {
                // console.log(response);
            })
        }

        $scope.$watch('localData.selectedBillingLocation', function(val) {
            if(val)
                $scope.refresh();
        });

        $scope.refresh = function(){
            /* Load ConsumptionTrend data for current billing cycle */
            $scope.getConsumptionTrendForMonth();
            $scope.getConsumptionTrendForToday();
            $scope.getBillingCycle();
            $('[data-toggle="popover"]').popover();
        }

        //$scope.refresh();
    }
]);

smartsenseApp.controller("BillingWidgetDemandController", ['$scope', '$rootScope', 'data', 'local', 'config',
    function($scope, $rootScope, data, local, config) {
        $scope.localData = local.data;
        $scope.refreshInProgress = true;
        $scope.$watch('localData.billingData', function(newVal) {
            $scope.refreshInProgress = false;
            $scope.demandData = newVal && newVal.demandData ? newVal.demandData : false;
            $scope.calculateAmounts();
            // console.log($scope.demandData);
        });

        $scope.calculateAmounts = function(){
            if(!$scope.demandData)
            {
                $scope.demandData = {
                }
            }
        };

        $scope.$watch('localData.billingDataLoading', function(newVal) {
            $scope.refreshInProgress = newVal;
        });
        $('[data-toggle="popover"]').popover();
    }
]);

smartsenseApp.controller("BillingWidgetEnergyConsumptionController", ['$scope', '$rootScope', 'data', 'local', 'config','apiService',
    function($scope, $rootScope, data, local, config, apiService) {
        /* Set local data to use in other components */
        $scope.localData = local.data;

        $scope.options = {
            cycleType: "today"
        }

        $scope.refreshInProgress = false;

        $scope.getConsumptionDetails = function() {
            $scope.refreshInProgress = true;
            var locationID = $scope.localData.selectedBillingLocation;
            var req = {
                readingtypeid: 2001,
                locationid : locationID
            };
            if ($scope.options.cycleType == "today")
                req.time_slot = "today";
            apiService.billing_get_consumption_details(req.time_slot, req.locationid, req.readingtypeid).then(function(data) {
                $scope.refreshInProgress = false;
                if (data) {
                    var consumptionData = data.data;
                    $scope.graphData = false;
                    if (consumptionData && consumptionData.sum && consumptionData.mapping) {
                        var info = {
                            peak: consumptionData.sum[consumptionData.mapping['peak']] || 0,
                            offpeak: consumptionData.sum[consumptionData.mapping['offpeak']] || 0,
                            night: consumptionData.sum[consumptionData.mapping['night']] || 0
                        };
                        info.peak = parseFloat(parseFloat(info.peak).toFixed(2));
                        info.offpeak = parseFloat(parseFloat(info.offpeak).toFixed(2));
                        info.night = parseFloat(parseFloat(info.night).toFixed(2));
                        info.total = parseFloat(parseFloat(info.peak + info.offpeak + info.night).toFixed(2));

                        info.peakPerc = $scope.getPercent(info.peak, info.total);
                        info.offpeakPerc = $scope.getPercent(info.offpeak, info.total);
                        info.nightPerc = $scope.getPercent(info.night, info.total);

                        consumptionData.info = info;
                        $scope.graphData = {
                            tooltip: {
                                pointFormatter: function() {
                                    return '<b>' + utils.formatData(this.value, true, true) + '</b> ('+this.perc+'%)';
                                },
                                shared: true
                            },
                            colorByPoint: true,
                            data: [{
                                name: "PEAK",
                                unit: '',
                                y: info.peak,
                                value: info.peak,
                                perc: info.peakPerc,
                                color: '#FFA423',
                                selected: true,
                            }, {
                                name: "OFF PEAK",
                                unit: '',
                                y: info.offpeak,
                                value: info.offpeak,
                                perc: info.offpeakPerc,
                                color: '#FFECB6'
                            }, {
                                name: "NIGHT",
                                unit: '',
                                y: info.night,
                                value: info.night,
                                perc: info.nightPerc,
                                color: '#A39F89'
                            }]
                        }
                    }
                    $scope.consumptionData = consumptionData;
                }
            }, function(error) {
                $scope.refreshInProgress = false;
                $scope.serverNotRecheable = true;
            });
        }

        $scope.getPercent = function(val, total){
            return parseFloat((100 * val)/total).toFixed(0);
        }

        $scope.$watch('localData.selectedBillingLocation', function(val) {
            if(val)
                $scope.refresh();
        });

        $scope.refresh = function() {
            $scope.getConsumptionDetails();
            return;
        };

        // $scope.refresh();
        $('[data-toggle="popover"]').popover();
    }
]);

smartsenseApp.controller("BillingWidgetPFController", ['$scope', '$rootScope', 'local', 'config', 'apiService',
    function($scope, $rootScope, local, config, apiService) {
        /* Set local data to use in other components */
        $scope.localData = local.data;
        $scope.refreshInProgress = false;
        $scope.pfDetails = {};

        $scope.getPFDetails = function() {
            $scope.refreshInProgress = true;
            var locationID = $scope.localData.selectedBillingLocation;
            apiService.billing_get_pf_details(locationID).then(function(data) {
                $scope.refreshInProgress = false;
                if(data && data.data)
                    $scope.pfDetails = data.data;
            }, function(error) {
                $scope.refreshInProgress = false;
                $scope.serverNotRecheable = true;
            });
        }

        $scope.refresh = function() {
            $scope.getPFDetails();
            return;
        };

        $scope.isUndefined = function (thing) {
            return (typeof thing === "undefined");
        };

        $scope.$watch('localData.billingData', function(newVal) {
            if(newVal && newVal.rebatePenalty)
                $scope.pfDetails.rebatePenalty = newVal.rebatePenalty;
            else
                $scope.pfDetails.rebatePenalty = undefined;
        });

        $scope.$watch('localData.selectedBillingLocation', function(val) {
            if(val)
                $scope.refresh();
        });

        // $scope.refresh();
        $('[data-toggle="popover"]').popover();
    }
]);

smartsenseApp.controller("BillingWidgetSolarPVController", ['$scope', '$rootScope', 'billingInsightsService', 'data', 'local', 'config', 'loading', '$state', 'Analytics','apiService',
    function($scope, $rootScope, billingInsightsService, data, local, config, loading, $state, Analytics, apiService) {
        $scope.localData = local.data;
        $scope.refreshInProgress = false;

        $scope.solarPV = {
            cities : [{id: 0, city: "Loading...", state: "Loading...", country: "Loading..."}],
            areaUnits : billingInsightsService.areaUnits,
            powerUnits : billingInsightsService.powerUnits,
            areaUnit : 'ft',
            consumptionUnit : 'kwh'
        }

        $scope.init = function(){
            apiService.billing_get_city_list().then(function(data){
                $scope.solarPV.cities = data.data;
            })
        }

        /* Simulation */
        $scope.simulateSolarPV = function() {
            loading(true);
            $scope.refreshInProgress = true;
            // Allowed Methods: [ POST, OPTIONS ]
            // Description:
            // Author : Hardik Chauhan Date : 17-Feb-2017 Usage : Solar PV calculator. Parameters : [ area - Mandatory area_unit - Mandatory avg_monthly_units - Mandatory avg_monthly_bill - Mandatory solar_efficiency - Mandatory (must be in percentage) avg_cost_per_unit - Mandatory city - Mandatory ]
            //area, area_unit, avg_monthly_units, avg_monthly_bill, solar_efficiency, avg_cost_per_unit, city
            apiService.billing_simulate_solar_pv(
                $scope.solarPV.area,
                $scope.solarPV.areaUnit,
                $scope.solarPV.avgMonthlyConsumption,
                $scope.solarPV.avgMonthlyBill,
                14,
                $scope.solarPV.avgCostOfPurchase,
                $scope.solarPV.selectedCity.id
            ).then(function(response){
                loading(false);
                $scope.refreshInProgress = false;
                $scope.solarPV.result = response.data;
                $scope.solarPV.result.energy_unit = $scope.solarPV.consumptionUnit + '';
                $scope.hasResult = true;
            }, function(){
                loading(false);
                $scope.refreshInProgress = false;
                $scope.hasResult = false;
            });
            Analytics.trackEvent('Billing Insights', 'Simulating Solar PV', $state.current.name);
        }

        $scope.reset = function(){
            $scope.hasResult = false;
            $scope.solarPV = {
                cities : $scope.solarPV.cities
            }
            $scope.resetActionFormValidation();
        };

        $scope.setForm = function(form){
            $scope.solarPVForm = form;
        }

        $scope.resetActionFormValidation = function(){
            var form = $scope.solarPVForm;
            if(!form)
                return;
            if(form.$setPristine){
                form.$setPristine();
            } else {
                form.$pristine = true;
                form.$dirty = false;
                angular.forEach(form, function (input, key) {
                    if (input.$pristine)
                        input.$pristine = true;
                    if (input.$dirty) {
                        input.$dirty = false;
                    }
                });
            }
        };

        $('[data-toggle="popover"]').popover();
        $scope.init();
    }
]);

var networktree = smartsenseApp.directive('networktree', function($state, data, local) {
    return {
        restrict: 'E',
        scope: {
            json: '=json',
            options: '=options',
            readingtype: '=readingtype',
            sensorHealth: '=sensorHealth',
            notifications: '=notifications'
        },
        transclude: true,
        template: "<div class='loading-chart tree-view-wrapper'>Loading....<div class='loading-indicator'></div></div>",
        link: function(scope, elem, attrs) {
            scope.localData = local.data;
            var watchMethod;
            var sensorHealth;
            var notifications;
            var delay = (function() {
                var timer = 0;
                return function(callback, ms) {
                    clearTimeout(timer);
                    timer = setTimeout(callback, ms);
                };
            })();

            function getUsagePerc(data, parentData) {
                if (data >= 0 && parentData >= 0) {
                    parentData = parentData || 1;
                    var percantage = (data * 100) / parentData;
                    percantage = percantage > 100 ? 100 : percantage;
                    return (parseFloat(percantage, 2)).toFixed(2) + "%";
                } else {
                    return "N/A";
                }
            }
            watchMethod = scope.$watch('json', function(treeView) {

                if (treeView && treeView.data) {
                    //return false;
                    var tree = $('<ul class="filetree"></ul>');

                    function buildTree(curNode, data, parent) {
                        if (data && data.length == undefined)
                            data = data.data;
                        data = data.sort(function(a, b) {
                            var aLen = a.child ? a.child.length : 0;
                            var bLen = b.child ? b.child.length : 0;
                            if (a.sensors) {
                                for (var j = 0; j < a.sensors.length; j++) {
                                    var sensor = a.sensors[j];
                                    if (sensor.sensortypeid !== 1001 && sensor.sensortypeid !== 1002 && sensor.sensortypeid !== 1003) {
                                        aLen++;
                                    }
                                }
                            }
                            if (b.sensors) {
                                for (var j = 0; j < b.sensors.length; j++) {
                                    var sensor = b.sensors[j];
                                    if (sensor.sensortypeid !== 1001 && sensor.sensortypeid !== 1002 && sensor.sensortypeid !== 1003) {
                                        bLen++;
                                    }
                                }
                            }

                            if (aLen < bLen)
                                return 1;
                            if (aLen > bLen)
                                return -1;
                            return 0;
                        });
                        if (data && data.length > 0) {
                            var sensorTree = $('<ul></ul>');
                            var parentData = parent && parent.consumption ? parent.consumption : 0;
                            for (var i = 0; i < data.length; i++) {
                                var curLocation = data[i];
                                var curSensor = curLocation;
                                var id = curSensor.sensorid ;
                                if(!id){
                                    var sensors = curSensor.sensors;
                                    if(sensors){
                                        sensors.forEach(function(cur){
                                            if(cur.sensortypeid == 1001 || cur.sensortypeid == 1002 || cur.sensortypeid == 1003){
                                                curSensor.sensorid = curSensor.sensorid || "";
                                                curSensor.sensorid = curSensor.sensorid + ',' + cur.sensorid;
                                            }
                                        });
                                    }
                                }

                                id = curSensor.sensorid || curSensor.locationid || curSensor.id;

                                if (id) {
                                    if (!curLocation.is_virtual) {
                                        if (curSensor.sensors) {
                                            var consumption = 0;
                                            var generation = 0;
                                            var backup = 0;

                                            for (var j = 0; j < curSensor.sensors.length; j++) {
                                                var sensor = curSensor.sensors[j];
                                                if (sensor.sensortypeid == 1001) {
                                                    consumption = consumption || 0;
                                                    if (sensor.value != null)
                                                        consumption += parseFloat(sensor.value);
                                                } else if (sensor.sensortypeid == 1002) {
                                                    if (sensor.value != null)
                                                        generation += parseFloat(sensor.value);
                                                } else if (sensor.sensortypeid == 1003) {
                                                    if (sensor.value != null)
                                                        backup += parseFloat(sensor.value);
                                                } else {
                                                    curSensor.child = curSensor.child || [];
                                                    if (sensor.value != null)
                                                        sensor.consumption = sensor.value;
                                                    else
                                                        sensor.consumption = 0;
                                                    curSensor.child.unshift(sensor);
                                                }
                                            }
                                            if (typeof consumption != "undefined")
                                                curSensor.consumption = consumption;
                                            if (typeof generation != "undefined")
                                                curSensor.generation = generation;
                                            if (typeof backup != "undefined")
                                                curSensor.backup = backup;
                                        }
                                    }

                                    var name = curSensor.name || curSensor.locationname;
                                    var _name = curSensor.name || curSensor.locationname;
                                    var value, valueObject, className;
                                    var unit = scope.readingtype.unit;

                                    if (curSensor.consumption) {

                                        value = curSensor.consumption;
                                        valueObject = utils.formatValue(value, unit);

                                        name += " <span class='treeview-data consumption'>" + valueObject.value + ' ' + valueObject.unit + "</span>";

                                        if (scope.options.showPercentage) {
                                            name += " <span class='treeview-data-perc consumption'>" + getUsagePerc(value, parentData) + "</span>";
                                        }

                                    } else if (curSensor.generation) {

                                        value = curSensor.generation;
                                        valueObject = utils.formatValue(value, unit);

                                        name += " <span class='treeview-data generation'>" + valueObject.value + ' ' + valueObject.unit + "</span>";

                                        if (scope.options.showPercentage) {
                                            name += " <span class='treeview-data-perc generation'>" + getUsagePerc(value, parentData) + "</span>";
                                        }

                                    } else if (curSensor.backup) {

                                        value = curSensor.backup;
                                        valueObject = utils.formatValue(value, unit);

                                        name += " <span class='treeview-data backup'>" + valueObject.value + ' ' + valueObject.unit + "</span>";

                                        if (scope.options.showPercentage) {
                                            name += " <span class='treeview-data-perc backup'>" + getUsagePerc(value, parentData) + "</span>";
                                        }

                                    } else if (curSensor.consumption == curSensor.generation == curSensor.backup == 0) {

                                        value = curSensor.consumption;
                                        valueObject = utils.formatValue(value, unit);

                                        name += " <span class='treeview-data consumption'>" + valueObject.value + ' ' + valueObject.unit + "</span>";

                                        if (scope.options.showPercentage) {
                                            name += " <span class='treeview-data-perc consumption'>" + getUsagePerc(value, parentData) + "</span>";
                                        }

                                    } else {
                                        name += " <span class='treeview-data invisible'>&nbsp;</span>";
                                    }

                                    var description = curSensor.description;
                                    description = $.trim(description);
                                    var curChild = $('<li><div class="sensor" sensorid="' + id + '"" _name="'+_name+'"> <span class="name">' + name + '</span> <span style="display:none;" data-html="true" data-toggle="popover" data-trigger="hover" data-placement="right" title="Sensor Description" data-content="here the description of sensor will be shown" class="info"><i class="fa fa-info-circle"></i></span> <span style="display:none;" data-html="true" data-toggle="popover" data-trigger="hover" data-placement="right" title="Sensor Health" data-content="here the data of sensor will be shown" class="unhealthy"><i class="fa fa-exclamation-triangle"></i></span> <span style="display:none;" data-html="true" data-toggle="popover" data-trigger="hover" data-placement="right" title="Status" data-content="" class="status"><i class="fa fa-exclamation-circle"></i></span> </div></li>');
                                    if (curSensor.child) {
                                        if (curSensor.locationid)
                                            curChild.find("div.sensor").find(".name").wrap('<a href="#/dashboard/' + curSensor.locationid + '"></a>');
                                        buildTree(curChild, curSensor.child, curSensor);
                                    }
                                    sensorTree.append(curChild);
                                    
                                    if(description != null && description != '') {
                                        var popover;
                                        popover = curChild.find("span.info").show().addClass('visible');
                                        var content = "";
                                        content = "<div class='custom-popup-text'>" + description ;
                                        if(popover)
                                            popover.attr("data-content", content);
                                    }
                                }
                            }
                            curNode.append(sensorTree);
                        }
                    }

                    function filterTreeByHealth(type) {
                        var note = $('.tree-view-filter-note').hide();
                        var tree = $("#minimap").next().find(".filetree");
                        tree.find("li").show().removeClass('hidden-filter-item filter-result');
                        if (type == "active") {
                            note.show().find(".type").text("Healthy");
                            tree.find("li").addClass('hidden-filter-item');
                            tree.find("li.filter-result").removeClass('filter-result');
                            tree.find("span.unhealthy:not(.visible)").each(function(){
                                $(this).closest('li').removeClass("hidden-filter-item").addClass('filter-result');
                            });
                            tree.find("li.filter-result").parent().removeClass("hidden-filter-item");

                        } else if (type == "inactive") {
                            note.show().find(".type").text("Unhealthy");
                            tree.find("li").addClass('hidden-filter-item');
                            tree.find("li.filter-result").removeClass('filter-result');
                            tree.find("span.unhealthy.visible").each(function(){
                                $(this).closest('li').removeClass("hidden-filter-item").addClass('filter-result');
                            });
                            tree.find("li.filter-result").parents(".hidden-filter-item").removeClass("hidden-filter-item");
                        }
                        if (type != "all") {
                            if (tree.find("li:not(.parent):visible").length > 0) {
                                note.find(".note").show();
                                note.find(".no-items").hide();
                            } else {
                                note.find(".note").hide();
                                note.find(".no-items").show();
                            }
                        }
                        renderMiniMap(scope.parentTree);
                    }

                    function filterTree(phrase) {
                        var tree = $("#minimap").next().find(".filetree");
                        if (phrase) {
                            tree.find("li").addClass('hidden-result-item');
                            tree.find("li.search-result").removeClass('search-result');
                            tree.find("li:containsIN('" + phrase + "')").removeClass("hidden-result-item").addClass('search-result');
                            tree.find("li.search-result").parent().removeClass("hidden-result-item");
                        } else {
                            tree.find("li.hidden-result-item").removeClass('hidden-result-item');
                            tree.find("li.search-result").removeClass('search-result');
                        }
                        renderMiniMap(scope.parentTree);
                    }

                    function searchMiniMapNode() {
                        $("#location-search").unbind("keyup").keyup(function(evt) {
                            var evt = (evt) ? evt : ((event) ? event : null);
                            var phrase = $(this).val();
                            delay(function() {
                                filterTree(phrase);
                            }, 500);
                        });
                    }

                    function renderMiniMap(parentTree) {
                        var tree = parentTree;
                        var minimap = $("#minimap");
                        var clone = tree.clone();
                        clone.removeProp("id");
                        clone.attr("id", "locationTreeviewMinimal");
                        var panelHeight = tree.height();
                        var panelWidth = tree.width();
                        var minimapHeight = minimap.height() - 10;
                        var minimapWidth = minimap.width() - 10;
                        minimap.empty().append(clone.addClass("minimal"));

                        var sliderHeight = Math.round((tree.parent().height() * minimapHeight) / panelHeight);
                        if (sliderHeight < 20)
                            sliderHeight = 20;

                        var panelAspectRatioWidth = (panelHeight * minimapWidth) / panelWidth;
                        var panelAspectRatioHeight = (panelWidth * minimapHeight) / panelHeight;
                        var width, height;
                        if (panelAspectRatioWidth <= minimapWidth) {
                            width = panelAspectRatioWidth;
                            height = (width * panelHeight) / panelWidth;
                        } else if (panelAspectRatioHeight <= minimapHeight) {
                            height = panelAspectRatioHeight;
                            width = (height * panelWidth) / panelHeight;
                        }
                        var aspectMatched;
                        if (height < minimapHeight) {
                            var tempHeight = minimapHeight;
                            var tempWidth = (width * minimapHeight) / height;
                            if (tempWidth < minimapWidth) {
                                width = tempWidth;
                                height = tempHeight;
                                aspectMatched = true;
                            }
                        }
                        if (!aspectMatched && width < minimapWidth) {
                            var tempWidth = minimapWidth;
                            var tempHeight = (height * minimapWidth) / width;
                            if (tempHeight < minimapHeight) {
                                width = tempWidth;
                                height = tempHeight;
                                aspectMatched = true;
                            }
                        }
                        var widthPerc = (Math.round(width) * 100) / panelWidth;
                        var heightPerc = (Math.round(height) * 100) / panelHeight;
                        clone.css("transform", "scale3d(" + Math.round(widthPerc) * 0.01 + "," + Math.round(heightPerc) * 0.01 + ",1)");
                        minimap.append('<div class="slider" style="height:' + sliderHeight + 'px"></div><div class="minimap-overlay"></div>');

                        minimap.find(".slider").draggable({
                            containment: "parent",
                            drag: function(event, ui) {
                                var curPos = ui.position;
                                var toTop = (panelHeight * curPos.top) / minimapHeight;
                                tree.parent().scrollTop(toTop);
                                // var toLeft = (panelWidth * curPos.left) / minimapWidth;
                                // tree.parent().scrollLeft(toLeft);
                            }
                        });
                        minimap.find(".minimap-overlay").click(function(evt) {
                            var offsetY = evt.offsetY - 20;
                            minimap.find(".slider").css("top", evt.offsetY);
                            var toTop = (panelHeight * offsetY) / minimapHeight;
                            tree.parent().scrollTop(toTop);
                        });

                        tree.parent().on("scroll", function(evt) {
                            var offsetY = $(this).scrollTop();
                            var toTop = ((minimapHeight * offsetY) / panelHeight);
                            // if (offsetY + $(this).height() >= panelHeight) {
                            //     toTop = minimapHeight - 20;
                            // }
                            //console.log(offsetY, panelHeight, $(this).height());
                            minimap.find(".slider").css("top", toTop);
                        })
                    }

                    var treeData;
                    var locationParentName = "Building tree..";
                    if (treeView && treeView.data && treeView.data.length > 0) {
                        scope.treeData = treeView.data;
                        buildTree(tree, treeView.data);
                        scope.locationParentName = treeView.clientName || "Not available";
                        searchMiniMapNode();
                    }
                    scope.locationParentName = scope.locationParentName || "Not available";
                    var parentTree = $('<ul><li class="parent"><a href="javascript:void(0);"><strong><i class="fa fa-sitemap"></i> ' + scope.locationParentName + '</strong></a></li></ul>');
                    parentTree.find(".parent").append(tree);
                    $(elem).empty().append('<div class="tree-wrapper"><div class="minimap" id="minimap"></div></div>');
                    $(elem).find("div.tree-wrapper").append(parentTree);
                    parentTree.attr("id", "locationTreeview");
                    parentTree.treeview({
                        collapsed: true,
                        animated: "medium",
                        control: "#networkTreeCollapseAll",
                        toggle: function() {
                            renderMiniMap(parentTree);
                        }
                    });

                    $("#locationTreeview li.parent > ul.filetree").show();
                    $("#locationTreeview li.parent").removeClass("expandable lastExpandable").addClass("collapsable lastCollapsable")
                    $("#locationTreeview li.parent > div").removeClass("expandable-hitarea lastExpandable-hitarea").addClass("collapsable-hitarea lastCollapsable-hitarea")

                    $('.tree-view-filter-note').find(".reset-tree-filter").unbind().click(function() {
                        $('.treeview-option[_type="all"]').trigger('click');
                        return false;
                    });

                    $("#networkTreeCollapseAll").unbind().click(function(evt) {
                        if ($(this).data("expanded")) {
                            $(this).removeData("expanded");
                            // $(this).text("- Collapse All");
                        } else {
                            $(this).data("expanded", "expanded");
                            // $(this).text("+ Expand All");
                        }
                        var that = $(this);
                        setTimeout(function() {
                            if (that.data("expanded")) {
                                $(".expandable-hitarea:not(.parent-hitarea)", parentTree.find(".collapsable")).click();
                            } else {
                                $(".collapsable-hitarea:not(.parent-hitarea)", parentTree.find(".collapsable")).click();
                            }
                        }, 200);

                        evt.preventDefault();
                        evt.stopPropagation();
                        return false;
                    }).data("expanded", "expanded");

                    $('.treeview-option').click(function() {
                        $('.treeview-option').find(".fa").removeClass('fa-check-circle-o').addClass('fa-circle-thin');
                        $(this).find(".fa").addClass('fa-check-circle-o').removeClass('fa-circle-thin');
                        filterTreeByHealth($(this).attr("_type"));
                    });
                    searchMiniMapNode();
                    renderMiniMap(parentTree);
                    scope.parentTree = parentTree;
                    showInactiveSensors(sensorHealth);
                    showNotifications(notifications);
                }
            });

            function formatDate(date) {
                if (date) {
                    return moment(date).format("DD/MM/YYYY hh:mm:ss A")
                }
                return "-";
            }

            function showNotifications(data){
                if (data) {
                    var sensors = data;
                    var tree = $('#locationTreeview');
                    tree.find("span.status").hide();
                    for (var sensor in sensors) {
                        var curSensorId = sensor;
                        if (curSensorId) {
                            var popover;
                            tree.find("[sensorid]").each(function(){
                                var sensors = $(this).attr("sensorid").split(",");
                                if(sensors.has(curSensorId+"")){
                                    popover = $(this).find("span.status").show().addClass('visible');
                                }
                            });
                            var content = "";
                            content = "<div class='custom-popup-text'>Total " + sensors[sensor].length + " error(s) reported. <br>Click to check all errors.</div>";
                            if(popover)
                                popover.attr("data-content", content);
                        }
                    }
                    $('.treeview-option:first').parent().show();
                    $('.treeview-option').find(".fa-check-circle-o").closest(".treeview-option").click();
                }
                $('[data-toggle="popover"]').popover();
            }

            function showInactiveSensors(data){
                if (data && data.sensor_health_details) {
                    var sensors = data.sensor_health_details;
                    var tree = $('#locationTreeview');
                    tree.find("span.unhealthy").hide();
                    for (var i = 0; i < sensors.length; i++) {
                        var curSensor = sensors[i];
                        if (curSensor && curSensor.sensor_id && curSensor.sensor_status != "active") {
                            var id = curSensor.sensor_id;
                            var popover;
                            tree.find("[sensorid]").each(function(){
                                var sensors = $(this).attr("sensorid").split(",");
                                if(sensors.has(id+"")){
                                    popover = $(this).find("span.unhealthy").show().addClass('visible');
                                }
                            });
                            var content = "";
                            content = "<div class='custom-popup-text'><strong>Status: </strong> " + curSensor.sensor_status + "<br><strong>Last Communication : </strong> " + formatDate(curSensor.last_communicated) + "</div>";
                            if(popover)
                                popover.attr("data-content", content);
                        }
                    }
                    $('.treeview-option:first').parent().show();
                    $('.treeview-option').find(".fa-check-circle-o").closest(".treeview-option").click();
                }
                $('[data-toggle="popover"]').popover();
            }

            $(document).on("click", "span.status", function(){
                scope.localData.locateDMRCErrors = true;
                scope.localData.locateErrorsFilter = $(this).closest('div.sensor').attr("sensorid") + "|" + $(this).closest('div.sensor').attr("_name");
                $state.go("home.dmrcdashboard");
                $(document).trigger("click");
                return false;
            });

            scope.$watch('sensorHealth', function(data) {
                sensorHealth = data;
                showInactiveSensors(data);
            });

            scope.$watch('notifications', function(data) {
                notifications = data;
                showNotifications(notifications);
            });
        }
    };
});

networktree.$inject = ['$state', 'data', 'local'];

var networktreedmrc = smartsenseApp.directive('networktreedmrc', function($state, data, local) {
    return {
        restrict: 'E',
        scope: {
            json: '=json',
            options: '=options',
            readingtype: '=readingtype',
            sensorHealth: '=sensorHealth',
            notifications: '=notifications'
        },
        transclude: true,
        template: "<div class='loading-chart tree-view-wrapper'>Loading....<div class='loading-indicator'></div></div>",
        link: function(scope, elem, attrs) {
            scope.localData = local.data;
            var watchMethod;
            var sensorHealth;
            var notifications;
            var delay = (function() {
                var timer = 0;
                return function(callback, ms) {
                    clearTimeout(timer);
                    timer = setTimeout(callback, ms);
                };
            })();

            function getUsagePerc(data, parentData) {
                if (data >= 0 && parentData >= 0) {
                    parentData = parentData || 1;
                    var percantage = (data * 100) / parentData;
                    percantage = percantage > 100 ? 100 : percantage;
                    return (parseFloat(percantage, 2)).toFixed(2) + "%";
                } else {
                    return "N/A";
                }
            }
            watchMethod = scope.$watch('json', function(treeView) {

                if (treeView && treeView.data) {
                    //return false;
                    var tree = $('<ul class="filetree"></ul>');

                    function buildTree(curNode, data, parent) {
                        if (data && data.length == undefined)
                            data = data.data;
                        data = data.sort(function(a, b) {
                            var aLen = a.child ? a.child.length : 0;
                            var bLen = b.child ? b.child.length : 0;
                            if (a.sensors) {
                                for (var j = 0; j < a.sensors.length; j++) {
                                    var sensor = a.sensors[j];
                                    if (sensor.sensortypeid !== 1001 && sensor.sensortypeid !== 1002 && sensor.sensortypeid !== 1003) {
                                        aLen++;
                                    }
                                }
                            }
                            if (b.sensors) {
                                for (var j = 0; j < b.sensors.length; j++) {
                                    var sensor = b.sensors[j];
                                    if (sensor.sensortypeid !== 1001 && sensor.sensortypeid !== 1002 && sensor.sensortypeid !== 1003) {
                                        bLen++;
                                    }
                                }
                            }

                            if (aLen < bLen)
                                return 1;
                            if (aLen > bLen)
                                return -1;
                            return 0;
                        });
                        if (data && data.length > 0) {
                            var sensorTree = $('<ul></ul>');
                            var parentData = parent && parent.consumption ? parent.consumption : 0;
                            for (var i = 0; i < data.length; i++) {
                                var curLocation = data[i];
                                var curSensor = curLocation;
                                var id = curSensor.sensorid ;
                                if(!id){
                                    var sensors = curSensor.sensors;
                                    if(sensors){
                                        sensors.forEach(function(cur){
                                            if(cur.sensortypeid == 1001 || cur.sensortypeid == 1002 || cur.sensortypeid == 1003){
                                                curSensor.sensorid = curSensor.sensorid || "";
                                                curSensor.sensorid = curSensor.sensorid + ',' + cur.sensorid;
                                            }
                                        });
                                    }
                                }

                                id = curSensor.sensorid || curSensor.locationid || curSensor.id;

                                if (id) {
                                    if (!curLocation.is_virtual) {
                                        if (curSensor.sensors) {
                                            var consumption = 0;
                                            var generation = 0;
                                            var backup = 0;

                                            for (var j = 0; j < curSensor.sensors.length; j++) {
                                                var sensor = curSensor.sensors[j];
                                                if (sensor.sensortypeid == 1001) {
                                                    consumption = consumption || 0;
                                                    if (sensor.value != null)
                                                        consumption += parseFloat(sensor.value);
                                                } else if (sensor.sensortypeid == 1002) {
                                                    if (sensor.value != null)
                                                        generation += parseFloat(sensor.value);
                                                } else if (sensor.sensortypeid == 1003) {
                                                    if (sensor.value != null)
                                                        backup += parseFloat(sensor.value);
                                                } else {
                                                    curSensor.child = curSensor.child || [];
                                                    if (sensor.value != null)
                                                        sensor.consumption = sensor.value;
                                                    else
                                                        sensor.consumption = 0;
                                                    curSensor.child.unshift(sensor);
                                                }
                                            }
                                            if (typeof consumption != "undefined")
                                                curSensor.consumption = consumption;
                                            if (typeof generation != "undefined")
                                                curSensor.generation = generation;
                                            if (typeof backup != "undefined")
                                                curSensor.backup = backup;
                                        }
                                    }

                                    var name = curSensor.name || curSensor.locationname;
                                    var _name = curSensor.name || curSensor.locationname;
                                    var value, valueObject, className;
                                    var unit = scope.readingtype.unit;

                                    // if (curSensor.consumption) {

                                    //     value = curSensor.consumption;
                                    //     valueObject = utils.formatValue(value, unit);

                                    //     name += " <span class='treeview-data consumption'>" + valueObject.value + ' ' + valueObject.unit + "</span>";

                                    //     if (scope.options.showPercentage) {
                                    //         name += " <span class='treeview-data-perc consumption'>" + getUsagePerc(value, parentData) + "</span>";
                                    //     }

                                    // } else if (curSensor.generation) {

                                    //     value = curSensor.generation;
                                    //     valueObject = utils.formatValue(value, unit);

                                    //     name += " <span class='treeview-data generation'>" + valueObject.value + ' ' + valueObject.unit + "</span>";

                                    //     if (scope.options.showPercentage) {
                                    //         name += " <span class='treeview-data-perc generation'>" + getUsagePerc(value, parentData) + "</span>";
                                    //     }

                                    // } else if (curSensor.backup) {

                                    //     value = curSensor.backup;
                                    //     valueObject = utils.formatValue(value, unit);

                                    //     name += " <span class='treeview-data backup'>" + valueObject.value + ' ' + valueObject.unit + "</span>";

                                    //     if (scope.options.showPercentage) {
                                    //         name += " <span class='treeview-data-perc backup'>" + getUsagePerc(value, parentData) + "</span>";
                                    //     }

                                    // } else if (curSensor.consumption == curSensor.generation == curSensor.backup == 0) {

                                    //     value = curSensor.consumption;
                                    //     valueObject = utils.formatValue(value, unit);

                                    //     name += " <span class='treeview-data consumption'>" + valueObject.value + ' ' + valueObject.unit + "</span>";

                                    //     if (scope.options.showPercentage) {
                                    //         name += " <span class='treeview-data-perc consumption'>" + getUsagePerc(value, parentData) + "</span>";
                                    //     }

                                    // } else {
                                        name += " <span class='treeview-data invisible'>&nbsp;</span>";
                                    // }

                                    var description = curSensor.description;
                                    description = $.trim(description);
                                    var curChild = $('<li><div class="sensor" sensorid="' + id + '"" _name="'+_name+'"> <span class="name">' + name + '</span> <span style="display:none;" data-html="true" data-toggle="popover" data-trigger="hover" data-placement="right" title="Sensor Description" data-content="here the description of sensor will be shown" class="info"><i class="fa fa-info-circle"></i></span> <span style="display:none;" data-html="true" data-toggle="popover" data-trigger="hover" data-placement="right" title="Sensor Health" data-content="here the data of sensor will be shown" class="unhealthy"><i class="fa fa-exclamation-triangle"></i></span> <span style="display:none;" data-html="true" data-toggle="popover" data-trigger="hover" data-placement="right" title="Status" data-content="" class="status"><i class="fa fa-exclamation-circle"></i></span> </div></li>');
                                    if (curSensor.child) {
                                        // if (curSensor.locationid)
                                        //     curChild.find("div.sensor").find(".name").wrap('<a href="#/dashboard/' + curSensor.locationid + '"></a>');
                                        buildTree(curChild, curSensor.child, curSensor);
                                    }
                                    sensorTree.append(curChild);
                                    
                                    if(description != null && description != '') {
                                        var popover;
                                        popover = curChild.find("span.info").show().addClass('visible');
                                        var content = "";
                                        content = "<div class='custom-popup-text'>" + description ;
                                        if(popover)
                                            popover.attr("data-content", content);
                                    }
                                }
                            }
                            curNode.append(sensorTree);
                        }
                    }

                    function filterTreeByHealth(type) {
                        var note = $('.tree-view-filter-note').hide();
                        var tree = $("#minimap").next().find(".filetree");
                        tree.find("li").show().removeClass('hidden-filter-item filter-result');
                        if (type == "active") {
                            note.show().find(".type").text("Healthy");
                            tree.find("li").addClass('hidden-filter-item');
                            tree.find("li.filter-result").removeClass('filter-result');
                            tree.find("span.unhealthy:not(.visible)").each(function(){
                                $(this).closest('li').removeClass("hidden-filter-item").addClass('filter-result');
                            });
                            tree.find("li.filter-result").parent().removeClass("hidden-filter-item");

                        } else if (type == "inactive") {
                            note.show().find(".type").text("Unhealthy");
                            tree.find("li").addClass('hidden-filter-item');
                            tree.find("li.filter-result").removeClass('filter-result');
                            tree.find("span.unhealthy.visible").each(function(){
                                $(this).closest('li').removeClass("hidden-filter-item").addClass('filter-result');
                            });
                            tree.find("li.filter-result").parents(".hidden-filter-item").removeClass("hidden-filter-item");
                        }
                        if (type != "all") {
                            if (tree.find("li:not(.parent):visible").length > 0) {
                                note.find(".note").show();
                                note.find(".no-items").hide();
                            } else {
                                note.find(".note").hide();
                                note.find(".no-items").show();
                            }
                        }
                        renderMiniMap(scope.parentTree);
                    }

                    function filterTree(phrase) {
                        var tree = $("#minimap").next().find(".filetree");
                        if (phrase) {
                            tree.find("li").addClass('hidden-result-item');
                            tree.find("li.search-result").removeClass('search-result');
                            tree.find("li:containsIN('" + phrase + "')").removeClass("hidden-result-item").addClass('search-result');
                            tree.find("li.search-result").parent().removeClass("hidden-result-item");
                        } else {
                            tree.find("li.hidden-result-item").removeClass('hidden-result-item');
                            tree.find("li.search-result").removeClass('search-result');
                        }
                        renderMiniMap(scope.parentTree);
                    }

                    function searchMiniMapNode() {
                        $("#location-search").unbind("keyup").keyup(function(evt) {
                            var evt = (evt) ? evt : ((event) ? event : null);
                            var phrase = $(this).val();
                            delay(function() {
                                filterTree(phrase);
                            }, 500);
                        });
                    }

                    function renderMiniMap(parentTree) {
                        var tree = parentTree;
                        var minimap = $("#minimap");
                        var clone = tree.clone();
                        clone.removeProp("id");
                        clone.attr("id", "locationTreeviewMinimal");
                        var panelHeight = tree.height();
                        var panelWidth = tree.width();
                        var minimapHeight = minimap.height() - 10;
                        var minimapWidth = minimap.width() - 10;
                        minimap.empty().append(clone.addClass("minimal"));

                        var sliderHeight = Math.round((tree.parent().height() * minimapHeight) / panelHeight);
                        if (sliderHeight < 20)
                            sliderHeight = 20;

                        var panelAspectRatioWidth = (panelHeight * minimapWidth) / panelWidth;
                        var panelAspectRatioHeight = (panelWidth * minimapHeight) / panelHeight;
                        var width, height;
                        if (panelAspectRatioWidth <= minimapWidth) {
                            width = panelAspectRatioWidth;
                            height = (width * panelHeight) / panelWidth;
                        } else if (panelAspectRatioHeight <= minimapHeight) {
                            height = panelAspectRatioHeight;
                            width = (height * panelWidth) / panelHeight;
                        }
                        var aspectMatched;
                        if (height < minimapHeight) {
                            var tempHeight = minimapHeight;
                            var tempWidth = (width * minimapHeight) / height;
                            if (tempWidth < minimapWidth) {
                                width = tempWidth;
                                height = tempHeight;
                                aspectMatched = true;
                            }
                        }
                        if (!aspectMatched && width < minimapWidth) {
                            var tempWidth = minimapWidth;
                            var tempHeight = (height * minimapWidth) / width;
                            if (tempHeight < minimapHeight) {
                                width = tempWidth;
                                height = tempHeight;
                                aspectMatched = true;
                            }
                        }
                        var widthPerc = (Math.round(width) * 100) / panelWidth;
                        var heightPerc = (Math.round(height) * 100) / panelHeight;
                        clone.css("transform", "scale3d(" + Math.round(widthPerc) * 0.01 + "," + Math.round(heightPerc) * 0.01 + ",1)");
                        minimap.append('<div class="slider" style="height:' + sliderHeight + 'px"></div><div class="minimap-overlay"></div>');

                        minimap.find(".slider").draggable({
                            containment: "parent",
                            drag: function(event, ui) {
                                var curPos = ui.position;
                                var toTop = (panelHeight * curPos.top) / minimapHeight;
                                tree.parent().scrollTop(toTop);
                                // var toLeft = (panelWidth * curPos.left) / minimapWidth;
                                // tree.parent().scrollLeft(toLeft);
                            }
                        });
                        minimap.find(".minimap-overlay").click(function(evt) {
                            var offsetY = evt.offsetY - 20;
                            minimap.find(".slider").css("top", evt.offsetY);
                            var toTop = (panelHeight * offsetY) / minimapHeight;
                            tree.parent().scrollTop(toTop);
                        });

                        tree.parent().on("scroll", function(evt) {
                            var offsetY = $(this).scrollTop();
                            var toTop = ((minimapHeight * offsetY) / panelHeight);
                            // if (offsetY + $(this).height() >= panelHeight) {
                            //     toTop = minimapHeight - 20;
                            // }
                            //console.log(offsetY, panelHeight, $(this).height());
                            minimap.find(".slider").css("top", toTop);
                        })
                    }
                    var treeData;
                    var locationParentName = "Building tree..";
                    if (treeView && treeView.data && treeView.data.length > 0) {
                        scope.treeData = treeView.data;
                        buildTree(tree, treeView.data);
                        scope.locationParentName = treeView.clientName || "Not available";
                        searchMiniMapNode();
                    }
                    scope.locationParentName = scope.locationParentName || "Not available";
                    var parentTree = $('<ul><li class="parent"><a href="javascript:void(0);"><strong><i class="fa fa-sitemap"></i> ' + scope.locationParentName + '</strong></a></li></ul>');
                    parentTree.find(".parent").append(tree);
                    $(elem).empty().append('<div class="tree-wrapper"><div class="minimap" id="minimap"></div></div>');
                    $(elem).find("div.tree-wrapper").append(parentTree);
                    parentTree.attr("id", "locationTreeview");
                    parentTree.treeview({
                        collapsed: true,
                        animated: "medium",
                        control: "#networkTreeDMRCCollapseAll",
                        toggle: function() {
                            renderMiniMap(parentTree);
                        }
                    });

                    $('.tree-view-filter-note').find(".reset-tree-filter").unbind().click(function() {
                        $('.treeview-option[_type="all"]').trigger('click');
                        return false;
                    });

                    $("#networkTreeDMRCCollapseAll").unbind().click(function(evt) {
                        if ($(this).data("expanded")) {
                            $(this).removeData("expanded");
                            // $(this).text("- Collapse All");
                        } else {
                            $(this).data("expanded", "expanded");
                            // $(this).text("+ Expand All");
                        }
                        var that = $(this);
                        setTimeout(function() {
                            if (that.data("expanded")) {
                                $(".expandable-hitarea:not(.parent-hitarea)", parentTree.find(".collapsable")).click();
                            } else {
                                $(".collapsable-hitarea:not(.parent-hitarea)", parentTree.find(".collapsable")).click();
                            }
                        }, 200);

                        evt.preventDefault();
                        evt.stopPropagation();
                        return false;
                    }).data("expanded", "expanded");

                    $('.treeview-option').click(function() {
                        $('.treeview-option').find(".fa").removeClass('fa-check-circle-o').addClass('fa-circle-thin');
                        $(this).find(".fa").addClass('fa-check-circle-o').removeClass('fa-circle-thin');
                        filterTreeByHealth($(this).attr("_type"));
                    });
                    searchMiniMapNode();
                    renderMiniMap(parentTree);
                    scope.parentTree = parentTree;
                    showInactiveSensors(sensorHealth);
                    showNotifications(notifications);
                }
            });

            function formatDate(date) {
                if (date) {
                    return moment(date).format("DD/MM/YYYY hh:mm:ss A")
                }
                return "-";
            }

            function showNotifications(data){
                if (data) {
                    var sensors = data;
                    var tree = $('#locationTreeview');
                    tree.find("span.status").hide();
                    for (var sensor in sensors) {
                        var curSensorId = sensor;
                        if (curSensorId) {
                            var popover;
                            tree.find("[sensorid]").each(function(){
                                var sensors = $(this).attr("sensorid").split(",");
                                if(sensors.has(curSensorId+"")){
                                    popover = $(this).find("span.status").show().addClass('visible');
                                }
                            });
                            var content = "";
                            content = "<div class='custom-popup-text'>Total " + sensors[sensor].length + " error(s) reported. <br>Click to check all errors.</div>";
                            if(popover)
                                popover.attr("data-content", content);
                        }
                    }
                    $('.treeview-option:first').parent().show();
                    $('.treeview-option').find(".fa-check-circle-o").closest(".treeview-option").click();
                }
                $('[data-toggle="popover"]').popover();
            }

            function showInactiveSensors(data){
                if (data && data.sensor_health_details) {
                    var sensors = data.sensor_health_details;
                    var tree = $('#locationTreeview');
                    tree.find("span.unhealthy").hide();
                    for (var i = 0; i < sensors.length; i++) {
                        var curSensor = sensors[i];
                        if (curSensor && curSensor.sensor_id && curSensor.sensor_status != "active") {
                            var id = curSensor.sensor_id;
                            var popover;
                            tree.find("[sensorid]").each(function(){
                                var sensors = $(this).attr("sensorid").split(",");
                                if(sensors.has(id+"")){
                                    popover = $(this).find("span.unhealthy").show().addClass('visible');
                                }
                            });
                            var content = "";
                            content = "<div class='custom-popup-text'><strong>Status: </strong> " + curSensor.sensor_status + "<br><strong>Last Communication : </strong> " + formatDate(curSensor.last_communicated) + "</div>";
                            if(popover)
                                popover.attr("data-content", content);
                        }
                    }
                    $('.treeview-option:first').parent().show();
                    $('.treeview-option').find(".fa-check-circle-o").closest(".treeview-option").click();
                }
                $('[data-toggle="popover"]').popover();
            }

            $(document).on("click", "span.status", function(){
                scope.localData.locateDMRCErrors = true;
                scope.localData.locateErrorsFilter = $(this).closest('div.sensor').attr("sensorid") + "|" + $(this).closest('div.sensor').attr("_name");
                $state.go("home.dmrcdashboard");
                $(document).trigger("click");
                return false;
            });

            scope.$watch('sensorHealth', function(data) {
                sensorHealth = data;
                showInactiveSensors(data);
            });

            scope.$watch('notifications', function(data) {
                notifications = data;
                showNotifications(notifications);
            });
        }
    };
});

networktreedmrc.$inject = ['$state', 'data', 'local'];

smartsenseApp.directive('treeSelector', [
    '$filter',
    '$state',
    '$timeout',
    '$rootScope',
    'focus',
    'Analytics',
    function($filter, $state, $timeout, $rootScope, focus, Analytics) {
        return {
            restrict: 'EA',
            scope: {
                data: '=',
                blacklist: '=',
                model: '=',
                defaultText: '=',
                locationid: '='
            },
            templateUrl: 'shared/location-selector/treeSelectorView.html',
            link: function(scope, el) {
                scope.current = {};
                scope.currentIndex = 0;
                scope.treeData = {};
                scope.searchText = null;
                scope.defaultText = scope.defaultText || "Select Location";
                scope.isBlackListed = function(locationid) {
                    return scope.blacklist && scope.blacklist.indexOf(scope.getByLocationId(locationid)) != -1;
                }

                scope.render = function(locationid) {
                    scope.currentIndex = locationid == null ? 0 : locationid;
                    if (!scope.currentIndex) {
                        scope.current = {};
                    } else {
                        scope.current = scope.getByLocationId(scope.currentIndex);
                    }
                    scope.children = scope.treeData[scope.currentIndex];
                    $('#locationSelect').isolatedScroll();
                    $('#locationDropdown').unbind().bind("shown.bs.dropdown", function(){
                        Analytics.trackEvent('Navigation', 'Location Selection Menu', 'Opened');
                    });
                }

                scope.getByLocationId = function(locationid) {
                    return $filter('filter')(scope.data, function(d) {
                        return d.locationid === locationid;
                    })[0];
                }


                scope.hasChildren = function(locationid) {
                    return (scope.treeData[locationid] && scope.treeData[locationid].length);
                }

                scope.getParent = function(locationid) {
                    var location = scope.getByLocationId(locationid);
                    if (location && location.parentlocationid) {
                        return scope.getByLocationId(location.parentlocationid);
                    } else {
                        return {};
                    }
                }

                scope.selectItem = function(locationid) {
                    if (locationid && scope.getByLocationId(locationid)) {
                        scope.model = scope.getByLocationId(locationid);
                    } else {
                        scope.model = false;
                    }
                    $rootScope.$broadcast("locationSelected", scope.model);
                }

                scope.loadChild = function(locationid) {
                    scope.searchText = null;
                    if (!locationid) {
                        $timeout(scope.render(0), 5000);
                    } else if (scope.hasChildren(locationid)) {
                        $timeout(scope.render(locationid), 5000);
                    } else {}
                }

                function generateTree(rawData) {
                    var result = {};
                    if (rawData && rawData.length > 0) {
                        for (var i = 0; i < rawData.length; i++) {
                            var parent = rawData[i].parentlocationid || 0;
                            if (!angular.isArray(result[parent])) {
                                result[parent] = [];
                            }
                            result[parent].push(rawData[i]);
                        }
                    }
                    return result;
                }
                scope.focusSearch = function() {
                    scope.searchText = null;
                    focus('searchText');
                }

                scope.$watch('data', function(newVals, oldVals) {
                    scope.treeData = generateTree(newVals);
                    if (scope.currentIndex && scope.hasChildren(scope.currentIndex)) {
                        scope.render(scope.currentIndex);
                    } else {
                        scope.render(0);
                    }
                }, true);

                scope.$watch('blacklist', function(newVals, oldVals) {
                    scope.treeData = generateTree(scope.data);
                    if (scope.currentIndex && scope.hasChildren(scope.currentIndex)) {
                        scope.render(scope.currentIndex);
                    } else {
                        scope.render(0);
                    }
                }, true);


                scope.$watch('locationid', function(newVals, oldVals) {
                    if (newVals) {
                        newVals = parseInt(newVals);
                        scope.selectItem(newVals);
                        var parent = scope.getParent(newVals);
                        scope.render(parent.locationid);
                    }
                }, true);
            }
        }
    }
]);
